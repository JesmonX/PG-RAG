ASAM OpenSCENARIO® 2.0.0

ASAM OpenSCENARIO® 2.0.0



Release date: 2022-07-20








Disclaimer

This document is the copyrighted property of ASAM e. 
V.
In alteration to the regular license terms, ASAM allows unrestricted distribution of this standard.
§2 (1) of ASAM’s regular license terms is therefore substituted by the following clause: "The licensor grants everyone a basic, non-exclusive and unlimited license to use the standard ASAM OpenSCENARIO".






This documentation landing page is intended as a starting point to get familiar with ASAM OpenSCENARIO 2.0.0.


The ASAM OpenSCENARIO documentation helps to understand how to use, apply and implement the ASAM OpenSCENARIO standard.




Features of this documentation


This section explains enhanced functionality for accessing the content of this standard.


On the top right, a full text search is present.
When entering one or more terms into the search bar, the entire content of the standard is searched and topics that contain those terms are listed.


On the right, a table of contents for subsections is present.
This additional table enables easier access to subtopics.


Within continuous text, content is linked where it is useful to provide related and additional content or more specific explanations to a subject.


To return to this page click on ASAM OpenSCENARIO in the table of contents on the left hand side.


In addition to this document ASAM OpenSCENARIO provides the following documents for download:




An introduction to ASAM OpenSCENARIO, the different versions currently released and their differences as well as an initial roadmap by ASAM on the next plans for ASAM OpenSCENARIO (non-normative)


A consolidated extended Backus–Naur form (EBNF) for ASAM OpenSCENARIO


The full domain model as a library, standard.osc (non-normative)










Documents 2) and 3) are consolidations of the normative content in Section 7.2.2, "Grammar of ASAM OpenSCENARIO" and  Section 8, "Domain model reference" and are provided as a convenience to users of ASAM OpenSCENARIO.







Entry points


This section provides common entry points where to start reading, depending on knowledge, interests and needs.


Getting familiar with ASAM OpenSCENARIO

The Introduction provides an overview about ASAM OpenSCENARIO, the target group, and the deliverables provided with ASAM OpenSCENARIO.



Understanding the concept of ASAM OpenSCENARIO

Section 6, "Conceptual overview" provides a summary of the features, terminology and specific concepts used in ASAM OpenSCENARIO.



ASAM OpenSCENARIO language specification

Section 7, "Language reference manual" contains the normative specification of the language, its syntax, grammar, semantics and more.
This documentation helps to start creating scenarios right away, and in getting familiar with the domain-specific language that is used in ASAM OpenSCENARIO.



Using the domain model

Section 8, "Domain model reference" contains information how to use the domain model.
The documentation defines the different entities in the "world" of ASAM OpenSCENARIO.



Using ASAM OpenSCENARIO

Section 9, "User guide" contains guidelines how to write reusable scenarios, and how to properly format ASAM OpenSCENARIO code.


Section 9.3, "Extending the domain model" contains explanations, how to define various entities in ASAM OpenSCENARIO, for example actors, structs or actions.
New entities can then be added and used in scenarios.



Migrating from ASAM OpenSCENARIO 1.2.0

Section 10, "Migrating from ASAM OpenSCENARIO 1.2.0" provides information about how to migrate to this version of ASAM OpenSCENARIO for an audience already familiar with ASAM OpenSCENARIO 1.2.0.
The migration guide focuses on converting existing ASAM OpenSCENARIO 1.2.0 scenarios to this version of ASAM OpenSCENARIO.
A collection of examples shows best practices of a smooth migration.









This version of ASAM OpenSCENARIO uses a different approach to describe scenarios, and has a richer set of features.
ASAM OpenSCENARIO 1.2.0 is based on an XML format.
This version of ASAM OpenSCENARIO is based on a programing language.


Please consult the documentation of this version of ASAM OpenSCENARIO, even if the primary interest is in migrating from ASAM OpenSCENARIO 1.2.0.









Foreword



Foreword
Foreword ASAM e. 
V. 
(Association for Standardization of Automation and Measuring Systems) is a non-profit organization that promotes standardization of tool chains in automotive development and testing. 
Our members are international car manufacturers, suppliers, tool vendors, engineering service providers, and research institutes. 
ASAM standards are developed by experts from our member companies and are thus based on real use cases. 
They enable easy exchange of data or tools within a tool chain. 
ASAM is the legal owner of these standards and is responsible for their distribution and marketing. 
ASAM standards define file formats, data models, protocols, and interfaces for tools that are used for the development, test, and validation of electronic control units (ECUs) and of the entire vehicle. 
The standards enable easy exchange of data and tools within a tool chain. 
They are applied worldwide. 
ASAM OpenSCENARIO Introduction

Introduction
Introduction Overview To verify the safety and the correct functionality of an Autonomous Vehicle (AV) or an Advanced Driver Assistance System (ADAS), it is necessary to observe its behavior in various evolving situations. 
These evolving situations are called scenarios. 
Using ASAM OpenSCENARIO, scenarios can be created that describe the behavior of the autonomous vehicle as well as other actors or entities in the environment. 
ASAM OpenSCENARIO covers the following key concepts: ASAM OpenSCENARIO is a domain-specific language. 
The language is tailored for describing complex traffic system scenarios at various abstraction levels. 
ASAM OpenSCENARIO also provides a domain model that captures the central concepts of dynamic traffic systems in the form of types and actions that can be used as the basic building blocks when modeling scenarios. 
ASAM OpenSCENARIO scenarios can be high-level abstract descriptions. 
Many specific variants of a scenario can be created by varying the scenario parameters, for example, speed, vehicle type, weather conditions, and so on. 
Tools that support ASAM OpenSCENARIO can generate these variants automatically, within the constraints that can be specified. 
These tools then collect and aggregate parameter data from successful tests. 
This data enables to measure the safety of autonomous vehicles. 
ASAM OpenSCENARIO is a programming language. 
When designing and specifying scenarios, it is essential to think of them as software programs. 
To define complex behaviors, scenarios can be composed in different ways. 
For example, scenarios can invoke other scenarios in sequence or in parallel. 
One scenario can be chosen as the entry point for execution; executing this scenario leads to the execution of the behaviors that it is composed of. 
ASAM OpenSCENARIO is a declarative language. 
The language describes what should happen, rather than instructing how it should happen. 
The language uses constraints to specify these expectations. 
ASAM OpenSCENARIO is a constraint-based language. 
Concrete values can be specified for parameters, for example, vehicle speeds, scenario durations, execution orders, and so on. 
Also, constraints can be specified over these parameters. 
This allows to define scenarios in a more abstract way: A scenario model can be created that encompasses a whole family of many concrete scenarios. 
ASAM OpenSCENARIO is an aspect-oriented programming language. 
Given a base scenario model, its behavior can be modified to suit particular purposes: The whole behavior or aspects of the behavior can be modified. 
The behavior of some or of all instances of an object can be modified. 
The behavior can be modified to suit a particular test or simulation. 
All this can be done without disturbing the original description of the scenario. 
Chapter overview ASAM OpenSCENARIO consists of the following parts: Section 6, "Conceptual overview" The conceptual overview describes central concepts of ASAM OpenSCENARIO, particularly scenarios and key terminology. 
Section 7, "Language reference manual" The language reference manual contains a complete definition of the domain-specific language that is used to describe scenarios. 
Section 8, "Domain model reference" The domain model defines the entities needed to build scenarios. 
It defines different actions and properties of these entities. 
Section 9, "User guide" The user guide contains extension guidelines that explain how additional entities can be created and added to the domain model. 
It also provides guidelines on writing reusable scenarios and styling of ASAM OpenSCENARIO syntax. 
Section 10, "Migrating from ASAM OpenSCENARIO 1.2.0" The migration guide is a useful source of information for an audience that is already familiar with ASAM OpenSCENARIO 1.2.0 and would like to migrate scenarios to this version of ASAM OpenSCENARIO. 
Target group The following users were explicitly considered during the creation of ASAM OpenSCENARIO: Auditors/regulators AV/ADAS developer companies Content or model developers Development project leaders Researchers Safety engineers Service providers Software developers Stakeholders System engineers Test engineers Tool developers Tool providers or consumers Conventions and notation Units See Section 7.3.4, "Physical types and units". 
Modal verbs To ensure compliance with the ASAM OpenSCENARIO standard, users need to be able to distinguish between mandatory requirements, recommendations, permissions, as well as possibilities and capabilities. 
The following rules for using modal verbs apply: Table 1. 
Rules for using modal verbs Provision Verbal form Requirements Requirements shall be followed strictly in order to conform to the standard. 
Deviations are not allowed. 
shall shall not Recommendations Recommendations indicate that one possibility out of the several available is particularly suitable, without mentioning or excluding the other possibilities. 
should should not Permissions Permissions indicate a course of action permissible within the limits of ASAM OpenSCENARIO deliverables. 
may need not Possibilities and capabilities Verbal forms used to state possibilities or capabilities, whether technical, material, physical, etc. 
can cannot Obligations and necessities Verbal forms used to describe legal, organizational, or technical obligations and necessities that are not regulated or enforced by the ASAM OpenSCENARIO standard. 
must must not Normative and informative content Content in this standard can be normative or informative. 
The sections listed in Table 2 are normative or informative per definition. 
Table 2. 
Normative and informative sections Section Indication Foreword Informative Introduction Informative Scope Normative Normative references Informative Terms and definitions Normative Abbreviations Normative Annexes Annexes can be normative or informative. 
The annex heading contains the indication "(normative)" or "(informative)". 
Bibliography Informative All other sections in this standard are normative as long as not explicitly stated otherwise. 
Informative sections are highlighted using the non-normative tag: Please note that the following section and its sub-sections are non-normative. 
The non-normative tag is valid for the section and all of its sub-sections. 
Typographic conventions Table 3. 
Typographic conventions Mark-up Definition Code elements This format is used for code elements, such as technical names of classes and attributes, as well as attribute values. 
Terms This format is used to introduce glossary terms and new terms and to emphasize terms. 
Notes for this version of ASAM OpenSCENARIO This is the first release of the language. 
Scenario developers can find themselves in need of functionality that either does not exist yet or may have been left to be implementation-specific. 
The language offers self-extension capabilities as well as the ability to bind to external software (methods that are implemented in a different language or mechanism). 
Consult the instructions on extending the domain model to use entities, actors, or actions that are not currently defined in the domain model (see Section 9.3, "Extending the domain model"). 
Scenario developers can use calls to external functions if they have to implement missing functionality. 
For example, this version of ASAM OpenSCENARIO does not define a built-in distribution function for parameter values. 
Such distribution functions can be implemented by an external method (see Section 7.3.7, "Methods" for the definition of external methods). 
Parameters can be constrained by such an external method (see Section 10.2, "Parameters" for an example). 
Foreword 1 Scope

1 Scope
1 Scope ASAM OpenSCENARIO comprises the specification of a domain-specific language and a domain model. 
The standard is intended for the description of dynamic behaviors and environments for driving simulation applications or any application that utilizes scenario descriptions. 
The primary use of ASAM OpenSCENARIO is the description and construction of complex scenarios. 
These scenarios include maneuvers that involve: Multiple vehicles Other participants Complex environmental interactions Complex variations of testing parameters Evaluation and analysis of complex or compound measurement criteria ASAM OpenSCENARIO is used in: Virtual development Testing Validation of functions for: Driver assistance Automated driving Autonomous driving ASAM OpenSCENARIO is also suitable for the following applications: Testing on test tracks or proving grounds Testing in a mixed environment (HiL) Decoding real-word driving data ASAM OpenSCENARIO may be used in conjunction with ASAM OpenDRIVE and ASAM OpenCRG. 
These standards describe detailed information of the road network and surface in driving simulations. 
ASAM OpenSCENARIO introduces the concept of a domain-specific language into scenario description. 
The language has the properties of a software language. 
Introduction 2 Normative references

2 Normative references
2 Normative references The following documents are referred to in the text in such a way that some or all of their content constitutes some of the requirements set out in this document. 
For dated references, only the edition cited applies. 
For undated references, the latest edition of the referenced document (including any amendments) applies. 
ASAM OpenSCENARIO is part of the ASAM simulation standards that focus on simulation data for the automotive environment. 
The standard can be used together with road network descriptions that are defined according to the standard ASAM OpenDRIVE and the description of the road surface described by ASAM OpenCRG. 
The three standards complement each other. 
Together they define the content that is required to describe the simulated world. 
When combined, all three standards provide a scenario-based description of traffic simulation that contains both static and dynamic content. 
Other ASAM standards referenced here are aimed at supplying operational design domain (ODD) information (ASAM OpenODD concept), or scenario labeling (ASAM OpenLABEL). 
In future revisions, the domain model will be synchronized with ASAM OpenXOntology. 
Members of the OpenX-family of standards and their current version: ASAM OpenCRG 1.2.0 [1] ASAM OpenDRIVE 1.7.0 [2] ASAM OpenLABEL 1.0.0 [3] ASAM OpenODD concept paper [4] ASAM OpenSCENARIO 1.1.0 [5] ASAM OpenXOntology concept paper [6] ASAM OpenSCENARIO 2.0.0 is designed to support a set of standards aimed at scenario-based approaches and methodologies for the verification of Automated Driving Systems (ADS). 
Among them are: ISO 34502 (in development) "Scenario based safety evaluation framework for ADS" ISO 21448 [20] ASAM OpenSCENARIO is designed to be ready to support ODD definitions based on: BSI PAS 1883 [9] ISO 34503 (in development) SAE J3259 (in development) The standard is compatible with: ISO 8601 [7] ISO 8855 [8] SAE J3016 (2021) [10] 1 Scope 3 Terms and definitions

3 Terms and definitions
3 Terms and definitions Abstract scenario A formal scenario that conceptualizes scenarios to the level of the scenario intent. 
For more information, see the detailed abstract scenario definition. 
Abstraction Generalization of one or more related specific implementations or situations. 
In this standard, abstraction refers to the generalization of scenarios. 
Abstraction is the opposite of concretization. 
For more information, see the detailed abstraction definition. 
Abstraction levels Gradation spectrum of generalization (abstraction) of a scenario. 
For more information, see the detailed abstraction levels definition. 
Action A fundamental, non-decomposable behavior of an actor. 
An action is a piece of behavior that can be executed or observed. 
Actions are abstract and their actual implementation is platform-specific and outside of the scope of this standard. 
For more information, see the detailed action definition. 
Actor A participant in a scenario who can perform actions. 
Agnostic The method or format of data is irrelevant to the device or program’s function. 
Concrete scenario A scenario for which the exact evolution of any of its parameters and variables is completely determined to a fixed value for any point in time. 
For more information, see the detailed concrete scenario definition. 
Concretization The opposite of abstraction. 
Ego vehicle The vehicle actor that is the focus of a scenario, meaning the vehicle under test. 
Entity Generic name for an element of the domain model. 
Entities can be classes, interfaces, or enums. 
Event A named trigger indicating the occurrence of a particular situation. 
Functional scenario Non-formal natural language description of a scenario. 
For more information, see the detailed functional scenario definition. 
Logical scenario A scenario that does not specify all values for all parameters but provides a range of values that can be selected. 
For more information, see the detailed logical scenario definition. 
Operational design domain (ODD) The complete range of space where the system under test is expected to operate. 
OpenSCENARIO file A file that contains code from ASAM OpenSCENARIO version 2.0.0 or greater and can be parsed by a compatible tool. 
Such files should make use of the file extension .osc to identify them. 
This differentiates them from the XML-based OpenSCENARIO files of previous versions that use the .xosc file extension. 
Parameterization The use of parameters. 
Scenario A description of the behavior or temporal evolution of physical objects and environmental conditions on the driving infrastructure over an interval of time, including the movement of traffic participants or the change of environmental conditions. 
For more information, see the detailed scenario definition. 
Scenario instance The scenario that is executed, whether it is passively observed or actively controlled. 
For more information, see the detailed scenario instance definition. 
2 Normative references 4 Abbreviations

4 Abbreviations
4 Abbreviations ADAS Advanced Driver Assistance System ARN Abstract Road Network ASAM Association for Standardization of Automation and Measuring systems AV Autonomous Vehicle DUT Device Under Test ECU Electronic Control Units HiL Hardware in the Loop Testing method for embedded systems. 
HOV High-Occupancy Vehicle A road vehicle that carries a lot of people. 
KPI Key Performance Indicator A metric that shows how well something is doing. 
LHS Left Hand Side Refers to an element on the left side of an equation or assignment. 
MiL Model in the Loop Testing method for model-based testing of embedded systems. 
NCAP New Car Assessment Program A government car safety evaluation program. 
ODD Operational Design Domain OSC Short for OpenSCENARIO. 
OSI Open Simulation Interface RHS Right Hand Side Refers to an element on the right side of an equation or assignment. 
SOTIF Safety Of The Intended Functionality Part of functional safety. 
Defined in ISO/PAS 21448:2019 [20]. 
SI Système International d’unités The International System of units. 
SiL Software in the Loop Testing method in software development. 
UNECE United Nations Economic Commission for Europe Regional commission of the United Nations to promote pan-European economic integration. 
ViL Vehicle in the Loop Testing method with a real vehicle under test. 
VRU Vulnerable Road Users Non-motorised road users, such as pedestrians and cyclists as well as motor-cyclists and persons with disabilities or reduced mobility and orientation. 
V&V Verification & Validation Independent procedures used together in quality management. 
3 Terms and definitions 5 Backward compatibility

5 Backward compatibility
5 Backward compatibility This version of ASAM OpenSCENARIO is the first release of the second generation of ASAM OpenSCENARIO. 
Previous releases of ASAM OpenSCENARIO such as ASAM OpenSCENARIO 1.2.0 are based on an XML representation and are not compatible with this version of ASAM OpenSCENARIO. 
ASAM plans to continue the evolution of ASAM OpenSCENARIO 1.2.0 to meet market requirements, while next revisions of this version of ASAM OpenSCENARIO will be developed. 
It is intended to converge the two versions of the standard into a single stream, based on this version of ASAM OpenSCENARIO. 
It is expected that converters will be developed to convert scenarios from ASAM OpenSCENARIO 1.2.0 to this version of ASAM OpenSCENARIO. 
4 Abbreviations 6 Conceptual overview

6 Conceptual overview
6 Conceptual overview Please note that the following section and its sub-sections are non-normative. 
The conceptual overview provides a summary of the features, terminology, and specific concepts used in ASAM OpenSCENARIO. 
This conceptual overview contains: Section 6.1, "ASAM OpenSCENARIO scenarios" This section describes some of the core features found in ASAM OpenSCENARIO and how they can be used to write scenarios using ASAM OpenSCENARIO. 
Section 6.2, "Key terminology" This section provides a summary of key terminology used throughout this standard. 
Section 6.3, "Scenario abstraction" This section defines the abstraction spectrum and the terms used throughout this standard regarding scenario abstraction levels. 
It also provides guidelines on transitioning between levels throughout the spectrum. 
5 Backward compatibility 6.1 ASAM OpenSCENARIO scenarios

6.1 ASAM OpenSCENARIO scenarios
6.1 ASAM OpenSCENARIO scenarios 6.1.1 Writing ASAM OpenSCENARIO scenarios ASAM OpenSCENARIO is a domain-specific language that is designed for describing scenarios where actors move through an environment, for example, vehicles and pedestrians. 
These scenarios have parameters that let you control and constrain the actors, their movements and their environment. 
ASAM OpenSCENARIO is designed to facilitate the composition of scenarios and tests, which makes it possible to define complex behaviors by using your own methodology. 
There is a minimal, extensible set of actors, scenarios, and actions provided by the domain model, which are the fundamental building blocks for defining more complex behaviors. 
For example, there is a vehicle.drive() action that can be used to compose a more complex behavior, such as "a vehicle is approaching a yield sign". 
Behaviors can be composed serially or in parallel. 
For example, a weather scenario can be executed in parallel with a vehicle scenario to model a vehicle scenario that is taking place in specific weather conditions. 
New actors and new scenarios can be created as needed, either from scratch, based on the building blocks supplied by the domain model, or by building on what you have defined so far. 
6.1.1.1 Scenario creation tutorial This tutorial is a quick guide for scenario creation. 
Scenario developers should start here when they read or write a scenario for the first time. 
6.1.1.1.1 About this tutorial This tutorial explains the following components for creating scenarios and setting goals: The language concepts The building blocks The mindset 6.1.1.1.2 The cut-out scenario example The cut-out scenario introduces three vehicles. 
A lead vehicle cuts out in front of the ego vehicle, exposing a stopped other vehicle. 
The functional description of the scenario in naturally spoken English language is as follows: The start_driving phase Three vehicles start driving. 
The lead_vehicle phase The lead_vehicle gets in front of the ego vehicle, while the other_vehicle gets to a desired position and stops. 
The cut_out phase The lead_vehicle cuts out to the left or the right, while the other_vehicle remains stopped. 
At this phase, the ego vehicle is challenged to avoid a collision safely and conveniently. 
The cut-out scenario can take place in multiple driving circumstances, for example: On different roads With different speeds With different distances between the vehicles In different weather conditions The ASAM OpenSCENARIO language allows users to capture the essence of the cut-out scenario in a format that is both human- and machine-readable. 
This level of abstraction is called an abstract scenario description. 
Later users may ask ASAM OpenSCENARIO technology to perform this scenario with multiple necessary conditions. 
For more information on abstraction levels, see Section 6.3.1, "Levels of scenario abstraction". 
6.1.1.1.3 A world built of actors and actions The main building blocks of scenarios are actors that perform actions. 
Examples of actors include: Vehicles Pedestrians Traffic lights A rock on the road Weather Actors can perform actions. 
Actions are behaviors. 
Examples: Vehicles can drive Pedestrians can walk In the cut-out example, three actors are involved: The ego vehicle, which is the vehicle-under-test. 
The lead vehicle. 
The other vehicle. 
The following code shows how actors are instantiated in an example scenario. 
Code 1. 
Actors within a cut-out scenario scenario cut_out: (1) lead_vehicle: vehicle (2) other_vehicle: vehicle # this is a comment (3) The ego vehicle instance exists and does not need to be instantiated as part of the cut-out. 
1 scenario keyword with the name cut_out 2 lead_vehicle instantiation The ASAM OpenSCENARIO language uses the modern popular Python syntactic conventions. 
The lead_vehicle actor is of struct vehicle. 
The vehicle struct and a basic set of attributes, such as vehicle_category and vehicle_color, are provided in the ASAM OpenSCENARIO domain model. 
Since all attributes of the vehicles are yet unspecified, they may be initialized to arbitrary values, possibly randomized, as long as these values satisfy the constraints that will be added to the scenario as the scenario is developed further. 
Note that indentation matters. 
The four spaces before the lead_vehicle definition mean, that the lead_vehicle is within the cut_out scenario definition. 
3 other_vehicle instantiation This line contains a comment that starts with a hash character (#), and extends to the end of the line. 
For more information about the built-in domain model, see Section 8, "Domain model reference". 
At this point, the behavior of the actors is not yet defined. 
This happens within the scenario’s do block. 
6.1.1.1.4 Describing actions over time The following code illustrates the do block: Code 2. 
Scenario behavior within the do block do serial(): (1) start_driving: parallel(): (2) sut.vehicle.drive() (3) lead_vehicle.drive() (3) other_vehicle.drive() (3) lead: parallel(): (4) sut.vehicle.drive() lead_vehicle.drive() with: lane(same_as: sut.vehicle, at: end) position([20m..200m], ahead_of: sut.vehicle, at: end) other_vehicle.drive() with: lane(same_as: sut.vehicle, at: end) speed(0kph, at: end) position([20m..200m], ahead_of: lead_vehicle, at: end) cut_out: parallel(duration: [1s..4s]): (5) sut.vehicle.drive() lead_vehicle.drive() with: lane(side_of: sut.vehicle, side: side, at: end) other_car.drive() with: speed(speed: 0kph) 1 do block The do block contains invocations of actions and scenarios that can happen serially or in parallel. 
In this example, scenario defines three phases that run in series, while each phase describes the behavior of the participating vehicles happening in parallel. 
2 start_driving phase A label, such as the start_driving label shown here, allows for referencing and refining this part of the scenario later. 
For example, this scenario can be refined to an edge case with high-speed aggressive driving (see more on this further below). 
3 start_driving phase Within the start_driving phase, the vehicles are driving. 
Note that there is no initial speed or position defined. 
ASAM OpenSCENARIO allows scenario designers to keep scenarios abstract. 
This is important, since determining the right initialization values requires engineering time. 
Hard-coding the scenario for specific values also means less reuse and limits the ability to explore unknown variations of scenarios. 
4 lead phase In this phase, each vehicle set to a desired position and speed. 
You can define specific values for the speed or location of a vehicle at the beginning, end, or throughout the phase. 
Modifiers, such as lane and position modifiers, provide simplified means of control of the drive action. 
In the example the lead_vehicle should drive in the following way: On the same lane as the ego (lane(same_as: sut.vehicle, at: end)). 
20 to 200 meters in front of the ego (position([20m..200m], ahead_of: sut.vehicle, at: end)), while the other_vehicle stops (speed(speed: 0kph)). 
5 cut_out phase Here the vehicles keep driving, while the lead_vehicle performs the cut-out. 
6.1.1.1.5 Setting the scenario goals The abstract scenario shown in Code 2 can produce an unlimited amount of concrete scenarios. 
ASAM OpenSCENARIO provides functional coverage features. 
These can be used to set measurable goals to determine if sufficient testing was performed. 
The goal for this example is: Exercise at least 10 cut-outs to the right and 10 cut-outs to the left. 
This is how to set the scenario goals: Code 3. 
Setting the scenario goals. 
extend cut_out: cover(side, event: end, target: 10) (1) 1 The key coverage attributes include what expression to sample, and when to sample it. 
In this case, sampling the side expression at the end of the scenario. 
The scenario’s built-in end event is used for that. 
The ASAM OpenSCENARIO breadth of coverage features allows users to precisely describe any ODD, project or scenario need. 
Examples of coverage features include: Ignoring specific values. 
Defining ranges to measure continuous values, such as speeds or distances. 
Cross-covering of more than a single item (for example to try all vehicle categories cutting out for both sides). 
…​ For more information on ASAM OpenSCENARIO coverage features, please refer to Section 7.5, "Coverage". 
6.1.1.1.6 Layering constraints to fill a coverage hole If a coverage goal is not reached, ASAM OpenSCENARIO allows to layer a constraint to steer the ASAM OpenSCENARIO technology and fill the missing scenario. 
If the coverage result did not observe enough cut-out scenarios from the right side, an extension can correct this. 
The following code tunes the result to make only cut-outs from the right. 
Code 4. 
Extending the cut-out extend cut_out: (1) keep(side == right) 1 The extension can be placed in a separate file and be loaded together with the original scenario definition. 
This separation allows defining a single abstract reusable scenario that can be tuned to achieve various purposes, without modifying the original code. 
For more information on constraint layering and extensions, please refer to Section 9.3, "Extending the domain model". 
6.1.1.2 Implementing ASAM OpenSCENARIO 6.1.1.2.1 Language characteristics The language is a "Python style" language. 
This implies, that line breaks and indentation have meaning, and are part of the language structure. 
An ASAM OpenSCENARIO scenario may look like this: Code 5. 
An ASAM OpenSCENARIO scenario scenario vehicle.two_phases: do serial (duration : [10s..30s]): phase1: actor.drive() with: speed(speed: 0kph, at: start) speed(speed: 10kph, at: end) phase2: actor.drive() with: speed(speed: [10kph..15kph]) This is only an example, some details may be omitted. 
The key building blocks of ASAM OpenSCENARIO can be seen as data structures: Simple structs Basic entities containing attributes, constraints, and so on Actors Are like structs, but also contain scenarios Scenarios Describe the behavior of actors These structures have attributes that hold scalar values, lists, or other structures. 
Attribute values can be described as expressions or calculated by external method definitions. 
You can control attribute values with keep() constraints, for example: keep(car1.speed < 50kph) The language has additional building blocks like: Parameters Modifiers Events …​ The language reference manual presents all the constructs of the language as well as its types and expressions. 
6.1.1.2.2 Parts of the domain model The ASAM OpenSCENARIO domain model contains the following entities that can be used for scenario implementation: Vehicles and vehicle properties You can find how to define a vehicle, or what properties or attributes a vehicle can have. 
Coordinate systems Geometrical definitions such as: struct position_3d: x: distance y: distance z: distance Environment For example, the weather conditions. 
Units Units are based on the International System of Units (SI). 
Road abstraction The domain model specification has a chapter on road abstraction. 
The approach of this version of ASAM OpenSCENARIO enables scenario developers to describe the road network, on which the scenario occurs, in an abstract way. 
You can refer to the road network within the scenario. 
Using this level of abstraction, scenarios can be matched to various locations on a given map topology. 
6.1.1.2.3 Building a simulation engine Since this version of ASAM OpenSCENARIO is a declarative and constraint-based language, this standard provides a declarative language semantics definition that is based on the notion of trace acceptance: It defines which behaviors (executions) of a traffic system are valid with respect to a given ASAM OpenSCENARIO model. 
Implementers of an ASAM OpenSCENARIO simulation engine may be interested in operational semantics that define how such an engine shall perform the next step in an ongoing execution. 
However, this standard does not provide any particular operational semantics description. 
Instead, implementers are free to choose an operational interpretation of the declarative semantics, as long as the behaviors produced are valid with respect to the declarative semantics in this standard. 
Depending on the use case, one of the following behaviors of an ASAM OpenSCENARIO simulation engine may be desired: Produce only one execution of all the valid executions. 
This may be sufficient in some cases. 
Produce a representative subset of all the valid executions. 
Produce executions in a way that efficiently satisfies certain coverage goals. 
However, this standard does not define any specific requirements in that regard. 
6 Conceptual overview 6.2 Key terminology

6.2 Key terminology
6.2 Key terminology This section provides a summary of key terminology used throughout this standard. 
6.2.1 Operational design domain (ODD) The complete range of space where the system under test is expected to operate. 
6.2.2 Action A fundamental, non-decomposable behavior of an actor. 
An action is a piece of behavior that can be executed or observed. 
Actions are abstract and their actual implementation is platform-specific and outside of the scope of this standard. 
6.2.2.1 Action details Actions are used whenever the state of an actor is expected to change. 
Typical examples include: A vehicle changing speed, changing lanes, or activating a turn signal. 
Pedestrians walking on the sidewalk or crossing the street. 
A traffic light changing color. 
Actors may perform multiple actions simultaneously. 
6.2.2.2 More information about actions Actions constitute the fundamental building block for scenarios and a typical scenario is a composite of multiple actions (and, potentially, other scenarios). 
The temporal or logical organization of actions within the scenario is achieved through temporal operators (for example, serial, parallel, or one_of) using events to trigger the start or end of an action, or both. 
Unlike scenarios, actions are not intended to be decomposed into smaller parts. 
Actions can consume zero or non-zero (simulation- or clock-) time to be executed. 
Actions can be interrupted by instantiation of another action or invocation of another scenario. 
6.2.3 Scenario A description of the behavior or temporal evolution of physical objects and environmental conditions on the driving infrastructure over an interval of time, including the movement of traffic participants or the change of environmental conditions. 
It is a base building block of the storyboard hierarchy. 
It can represent a definition of a single action. 
It can use composition operators to define equivalents to Event, Maneuver, Act, Story, and all the levels up to a description of a complete scenario of ASAM OpenSCENARIO 1.2.0. 
Scenarios can be expressed in multiple levels of abstraction. 
An ASAM OpenSCENARIO scenario can be used to define scenarios in the following contexts: SOTIF (ISO 21448 – Safety of the intended functionality) UNECE/WP.29 Regulations – World Forum For harmonization of vehicle regulations [Euro] NCAP – New Car Assessment Program Other safety or regulation frameworks 6.2.3.1 Scenario details A full scenario description should answer the following questions: Where does the scenario take place? Answer: On the driving infrastructure of the driving domain (N1). 
The driving infrastructure includes the road layout, road furniture, and other static objects (like buildings and vegetation). 
Who participates in the scenario? Answer: Actors (like vehicles, objects, people, and traffic lights) participate in the scenario; environmental conditions (N2) (like weather and lighting) can be set or changed in the scenario, or both. 
What do the participants do? Answer: Actions describe the behavior of the actors; environmental actions (N2) describe changing environmental conditions during the scenario. 
When do the actions take place? Answer: This is achieved through the following language elements: Compositional operators Temporal directives Events OpenSCENARIO compositional operators - such as serial, parallel, one_of, and so on - allow users to construct phases or temporal labels for when a scenario invocation or action instantiation occurs. 
Temporal directives - such as wait, on, or until - reference events. 
ASAM OpenSCENARIO events resolve to a specific point in time within the scenario. 
This allows users to: Resolve the start and/or end of a phase. 
Resolve a moment to take a measurement in the scenario. 
6.2.3.2 More information about scenarios A scenario may include a specification of validity criteria. 
OpenSCENARIO language enables a scenario to include commands to control the test execution platform. 
A scenario may refer to simulations, physical tests, driving data, or any combination thereof. 
There is not necessarily a one-to-one relation between one scenario and one ASAM OpenSCENARIO file. 
A single ASAM OpenSCENARIO file can contain several scenarios, or the definition of a single scenario can be distributed across different ASAM OpenSCENARIO files, or both. 
6.2.4 Scenario instance The scenario that is executed, whether it is passively observed or actively controlled. 
By definition, the scenario instance is concrete. 
For example, a user may ask for a cut-in scenario (scenario request), execute it and observe the scenario instance that might be different from the scenario request. 
6.2.5 Abstraction Generalization of one or more related specific implementations or situations. 
In this standard, abstraction refers to the generalization of scenarios. 
Abstraction is the opposite of concretization. 
The degree of abstraction is defined as abstraction levels. 
6.2.6 Abstraction levels Gradation spectrum of generalization (abstraction) of a scenario. 
The following definitions list the different levels of abstractions in which a scenario can be specified: Concrete scenario - A scenario for which the exact evolution of any of its parameters and variables is completely determined to a fixed value for any point in time. 
Logical scenario - A scenario that does not specify all values for all parameters but provides a range of values that can be selected. 
Abstract scenario - A formal scenario that conceptualizes scenarios to the level of the scenario intent. 
Functional scenario - Non-formal natural language description of a scenario. 
This picture from [24] shows the different levels of abstraction in which a scenario can be specified. 
Figure 1. 
Levels of scenario abstraction (Source: [24]) Abstraction levels are a spectrum and not limited to the four layers. 
The levels of abstraction and other of their key aspects are discussed in more detail in Section 6.3, "Scenario abstraction". 
Guidelines on how to move a scenario more towards either end of this spectrum are described in Concretization and abstraction guidelines. 
6.1 ASAM OpenSCENARIO scenarios 6.3 Scenario abstraction

6.3 Scenario abstraction
6.3 Scenario abstraction This section defines the abstraction spectrum and the terms used throughout this standard regarding scenario abstraction levels. 
It also provides guidelines on transitioning between levels throughout the spectrum. 
6.3.1 Levels of scenario abstraction Concretization and abstraction are concepts working in opposite directions. 
Concretization is sometimes also called refinement. 
6.3.1.1 Level definitions Abstracting a scenario means that the legal space captured by a scenario is enlarged. 
Concretizing a scenario means that the legal space captured by a scenario is reduced. 
In the case of two scenarios - scenario A and scenario B - this means: If the legal space that is captured by scenario A is a subset of the legal space that is captured by scenario B, then scenario A is a concretization of scenario B. 
If the legal space that is captured by scenario A is a superset of the legal space that is captured by scenario B, then scenario A is an abstraction of scenario B. 
The mechanisms of concretization and abstraction create a spectrum of abstraction degrees. 
In theory, this spectrum is continuous. 
6.3.1.2 Level spectrum structure To give more structure to this spectrum, different abstraction levels are defined. 
The most common ones are the following scenario levels: Concrete Logical Abstract Concrete, logical and abstract scenarios constitute a spectrum of abstraction levels. 
The abstraction can be on the actor, maneuver, or road element levels, allowing a tool to accept abstract user descriptions with multiple dependencies and produce multiple concrete scenarios that adhere to an abstract description. 
Within the same abstraction level, different degrees of abstraction exist. 
For example, a certain abstract scenario may be more abstract than another abstract scenario although they belong to the same abstraction level. 
Stepping from the abstract to the concrete scenario level means: A concrete scenario needs to choose specific values from the parameter ranges of an abstract scenario to be a concretization of it. 
If all the parameter ranges of a concrete scenario meet all the constraints of an abstract scenario, then the concrete scenario is a concretization of that abstract scenario. 
6.3.1.2.1 Concrete scenario A scenario for which the exact evolution of any of its parameters and variables is completely determined to a fixed value for any point in time. 
There are two possibilities to specify such a scenario: Specify concrete locations and trajectories. 
Reference deterministic models. 
Deterministic models determine the evolution of values during scenario execution. 
Examples are driver, traffic, weather, or vehicle dynamics. 
"Deterministicly assigning values" refers to all variables that may influence how the system behaves and how its resulting behavior is measured. 
There are two levels of concrete scenarios that can be specified using ASAM OpenSCENARIO: Trajectory-level concrete In a trajectory-level concrete specification, the position and status of each actor is provided for any execution time. 
The example of a concrete scenario demonstrates an attribute-level concrete scenario. 
Attribute-level concrete In an attribute-level concrete scenario, all attribute values are specified by the user but the corresponding actual trajectories are still determined by ASAM OpenSCENARIO 2.0 technology. 
6.3.1.2.2 Logical scenario A scenario that does not specify all values for all parameters but provides a range of values that can be selected. 
The goal is to allow a variation of parameter values during simulation or testing by choosing concrete values out of the ranges. 
This can be done in one of the following ways: Predefined steps Distribution function Randomly The free dimensions of the logical scenario constitute a scenario space. 
Once a single parameter value of a concrete scenario is not provided, the scenario becomes a logical scenario. 
6.3.1.2.3 Abstract scenario A formal scenario that conceptualizes scenarios to the level of the scenario intent. 
This level of abstraction is a formal, declarative description. 
This level is both machine- and human-readable. 
This level can be read and processed by tools to generate scenario descriptions at more concrete levels of abstraction. 
Abstract scenarios may capture dependencies and relations between attributes and behaviors using constraints. 
The level of abstraction applies to scenario maneuvers, locations, and ODD needs. 
Examples: "An emergency vehicle in a three-lane motorway." "An aggressive cut-in by a large vehicle." 6.3.1.2.4 Functional scenario Non-formal natural language description of a scenario. 
This description is not machine-readable. 
Conversion of functional scenarios to abstract scenarios is often dependent on user experience or subjective interpretation, or both. 
Note that abstract scenarios can also be expressed in natural language. 
The difference between functional and abstract scenario is that the abstract scenario is formal and machine-readable. 
6.3.1.3 Level examples This section contains examples for the three most commonly used types of scenarios as well as an example for different degrees of abstraction between two abstract scenarios. 
6.3.1.3.1 Concrete scenario Code 1. 
A concrete scenario scenario my_concrete_scenario: map.set_map_file("my_map.xodr") my_road: route = map.create_route(get_odr_points(my_file)) car1: vehicle with: keep(car1.color == red) keep(car1.model == lincoln_mkz2017) keep(car1.category == car) do serial: car1.drive(duration: 24s) with: along(my_road) speed(0kph, at:start) speed(60kph, at: end) lane(3) position(distance:50m, at:start) position(distance:250m, at:end) acceleration(...) All attributes are fully specified for any point in time. 
This includes: Map Specific path Distances Speed All drive attributes 6.3.1.3.2 Logical scenario Code 2. 
A logical scenario scenario my_logical_scenario: map.set_map_file("my_map.xodr") my_road: route = map.create_route(get_odr_points(my_file)) car1: vehicle with: keep(car1.color in [red,green]) keep(car1.model == lincoln_mkz2017) keep(car1.category == car) do serial: car1.drive(duration: 24s) with: along(my_road) speed([0kph..20kph], at:start) speed([40kph..80kph], at: end) lane([2..4]) position(distance:[25m..60m],at:start) position(distance:[150m..350m],at:end) The logical scenario space might include non-feasible scenarios. 
For example, the combination of certain values for duration, distance, and speed may break real-life physical laws of speed, time, and distance. 
The same combination of values may also exceed the length of the provided road segment without fulfilling the desired maneuver. 
6.3.1.3.3 Abstract scenario Code 3. 
An abstract scenario scenario sut.right_cut_in_by_emergency_vehicle: # any road that matches these constraints and not hardcoded to any specific map my_road: road with: keep(it.min_lanes>=2) #object constraints my_emergency_car: emergency_vehicle #emergency_vehicle would need to be extension of the domain model do cut_in() with: #cut_in would need to be an extension to actions or within composable scenarios. 
keep(side == right) keep(road == my_road) keep(car1 == my_emergency_car) This scenario abstracts Locations Any location with more than two lanes. 
Actors Emergency that may have different structures and attributes. 
Maneuvers Cut-in from the left. 
The following example is a more abstracted scenario that mixes the abstract scenario with other components: Code 4. 
An abstract that uses composition scenario sut.cut_in_and_danger: # Getting more abstract p: person road: road do parallel(duration:[20s..40s]): right_cut_in_by_emergency_vehicle(my_road: road) p.cross_road(my_road:road) one_of: #one of several bad things snow_storm() mechanical_failure() ... 
This second example shows how a few scenarios can be mixed to create interesting, potentially unpredictable scenarios. 
6.3.1.3.4 Comparison of two abstract scenarios Consider the following examples: Code 5. 
An abstract scenario scenario sut.right_cut_in_emergency_vehicle: my_emergency_car: emergency_vehicle my_road: road with: keep(it.min_lanes>=2) # this scenario invokes a previously defined cut_in scenario do cut_in() with: keep(side == right) keep(road == my_road) keep(vehicle1 == my_emergency_car) The emergency vehicle actor can be randomized into a police car, an ambulance, or a fire truck. 
Once randomized, it drives using the randomized vehicle dynamics. 
Code 6. 
A more concrete abstract scenario scenario sut.right_cut_in_police_vehicle: my_police_car: police_vehicle my_road: road with: keep(it.min_lanes>=2) do cut_in() with: keep(side == right) keep(road == my_road) keep(vehicle1 == my_police_car) Code 5 is more abstract than Code 6 because the second example is hard-coding the emergency vehicle to be a police car. 
Therefore the second example is the more concrete version. 
Another example is an abstract scenario that takes place in a specified location. 
The timing and orchestration can be inferred by tooling that takes into account all constraints and dependencies, but the location itself is specified. 
Note that even if all the attributes of an abstract scenario are specified, the scenario is still not trajectory-level concrete (meaning not all the locations and attributes are specified for any given point at all time of the scenario execution). 
This last step of trajectory level concretization may be specified by the user or left for an ASAM OpenSCENARIO tool to determine. 
6.3.2 Concretization and abstraction guidelines As part of the development and V&V tasks, multiple scenarios in different levels of abstraction are produced. 
Users often need to manually or automatically shift the level of abstraction. 
The following chapters provide guidelines and tips on circumstances, methodology, and ASAM OpenSCENARIO language capabilities to move between the abstraction levels. 
6.3.2.1 Moving from abstract to concrete Humans think and communicate in an abstract way. 
When friends are talking about an aggressive cut-in that took place on their way to the office, they do not need to detail the car trajectories or specifics to comprehend the dangerous scenario. 
Natural language verification plans can use a similar level of abstraction. 
They can also be open to human interpretation, inviting to close the gap in different ways. 
The verification plan may call for an aggressive cut-in with a few specific values or location characteristics. 
Then test writers need to describe the rest using their own judgment. 
Executing or observing a scenario on any execution platform requires concrete attributes. 
A vehicle always drives on a specific road and on a specific trajectory. 
ASAM OpenSCENARIO allows capturing the validation and verification plan or specification in an abstract way including the definition of the relationship between actors and activities. 
Implementations can then translate this abstract specification into one or more concrete executions that follow the user-specified abstract scenario. 
Figure 2. 
From abstract to concrete 6.3.2.2 Moving from abstract to concrete in ASAM OpenSCENARIO An abstract scenario can be moved to a concrete scenario when all values for all scenario attributes are specified. 
This includes location, weather conditions, and more. 
Users have two possibilities to move to a concrete scenario: Derive from an abstract scenario and specify a value for each attribute to make it concrete. 
Extend the abstract scenarios. 
There are differences between the two kinds of use cases: Users need to execute any concrete scenario. 
At this point, an automated concretization is desired. 
Users wish to take full control and they want to manually assign all values for a specified scenario. 
Even if users are willing to do all the concretization work, having the abstract scenario is still useful for checking that the concrete values do not break the abstract scenario dependencies. 
With an abstract scenario, users can also decide if the concrete values are consistent. 
Note that it is impossible to convert an abstract scenario to a finite set of logical scenarios. 
On any given map there are endless numbers of locations, possible speeds, or latencies. 
Their dependencies result in an infinite number of logical scenarios with different ranges. 
6.3.2.3 Moving from concrete to abstract A provided concrete scenario often holds an interesting high-level intent that scenario developers may wish to duplicate. 
For example, specific trajectories of two cars can be provided without explicitly stating that the scenario is a cut-in scenario. 
Abstracting the high-level intent of the scenario allows replicating the intent and achieving a diverse set of similar scenarios. 
Examples include: Developers create a concrete scenario to check a specific driving function. 
Then they deliver the scenario to the V&V team to create more scenarios similar to this simple scenario. 
A concrete collision in the field. 
Multiple concrete scenarios are defined based on a specific traffic accident in order to challenge the driving function and better understand the root cause. 
A concrete bug is identified using random scenario generation on a virtual platform. 
The virtual platform can be, for example, a simulator. 
In this case, users analyze the cause of a failure or a unique combination of events. 
Then they decide that this combination represents a category of scenarios that is not mentioned in the plan. 
Users can abstract the combination and replicate its essence in multiple circumstances. 
A verification plan that goes into detail. 
To achieve an abstract scenario, users need to: Analyze the concrete scenario. 
Understand the relations or combinations that make the scenario special. 
Codify the dependencies in ASAM OpenSCENARIO formal description. 
Once the intent is captured in an abstract description, multiple scenario instances can be produced automatically. 
Figure 3. 
From concrete to abstract 6.3.2.4 Moving from concrete to abstract in ASAM OpenSCENARIO ASAM OpenSCENARIO allows users to capture the abstract intent of the scenario. 
To generalize concrete scenarios, they need to analyze the essence of the scenarios and capture the essence in ASAM OpenSCENARIO code. 
For example, the essence of a cut-in is that a car in a different lane moves in front of another car. 
On top of just capturing the intent, users can replace concrete values or the location with randomized attributes and ranges. 
It is important to capture the dependencies between such attributes to ensure that the resulting scenario is consistent. 
For example, specifying a velocity of 5 kph for 2 s forces a specific distance. 
Picking a different value causes an infeasible scenario. 
6.2 Key terminology 7 Language reference manual

7 Language reference manual
7 Language reference manual The language reference manual contains a complete definition of the domain-specific language that is used to describe scenarios. 
This chapter contains the following parts: Section 7.1, "Introduction" Section 7.2, "Language structure and syntax" Section 7.3, "Types" Section 7.4, "Expressions" Section 7.5, "Coverage" Section 7.6, "Semantics" Section 7.7, "Library mechanisms" 6.3 Scenario abstraction 7.1 Introduction

7.1 Introduction
7.1 Introduction 7.1.1 Scope This language reference manual provides the normative description of the ASAM OpenSCENARIO domain-specific language. 
It forms a part of the overall ASAM OpenSCENARIO standard specification, besides other parts, like the domain model specification, domain model extension guidelines, scenario creation guidelines, and the migration guidelines. 
This reference manual specifies the syntax and semantics of the ASAM OpenSCENARIO domain-specific language. 
It is to be understood in combination with the other specification parts: The domain model specification, in particular, which gives the definition of all domain-specific types that can be employed with the language. 
The language reference manual is structured into the following sections: Section 7.2, "Language structure and syntax" defines the overall structure and syntax of the language. 
Section 7.3, "Types" defines the type system and the various compound type declarations that form the main part of the language. 
Section 7.4, "Expressions" defines the expression language, which is employed in various places across the language. 
Section 7.5, "Coverage" defines the measurement and coverage mechanisms of the language. 
Section 7.6, "Semantics" provides the overall formal semantics of the language through the use of denotational trace semantics. 
Section 7.7, "Library mechanisms" defines the mechanisms that the language provides for library creation and use. 
7.1.2 Language overview In order to verify the safety and functionality of an autonomous vehicle (AV) or an advanced driver assistance system (ADAS), its behavior needs to be observed in various situations or scenarios. 
A scenario is a timed sequence of actions by one or more actors. 
Typical actors in scenarios might include vehicles, pedestrians, the environment, and the AV itself. 
ASAM OpenSCENARIO is aimed at supporting the creation, execution, and observation of scenarios across the complex challenge of AV simulation, verification, and validation. 
More specifically, ASAM OpenSCENARIO aims to support scenarios ranging from simple to complex, and from abstract to concrete. 
The domain-specific language described in Section 7, "Language reference manual" is intended to form a core basis for achieving those goals as a central part of the overall ASAM OpenSCENARIO specification. 
7.1.2.1 Domain-specific language The ASAM OpenSCENARIO language is a domain-specific language: It was developed from the ground up to support the specification of scenarios. 
It is centered in its definitions around the domain of AV/ADAS development, validation, and verification. 
It supports a human-readable Python-like syntax, that provides for a lower learning curve for domain experts while supporting a domain model that is directly recognizable by domain experts. 
The concepts that were integrated into the language are all directly applicable to the domain at hand, whereas purely implementation-centric features were avoided wherever possible. 
7.1.2.2 Declarative language The ASAM OpenSCENARIO language is a declarative language: It is describing "what should happen", rather than focusing on "how it should be performed". 
For example, the language can describe a vehicle changing its velocity from 30 kph to 90 kph. 
Any profile of this velocity change matches the declarative description (see Section 7.6, "Semantics"). 
The ASAM OpenSCENARIO language is designed to support a wide span of abstraction levels. 
These levels can vary from an abstract scenario description down to very concrete and detailed scenarios. 
An abstract scenario description includes very few specific values, like target speeds, or specific positions: It leaves those values open to further refinement in concretizations of the abstract scenario. 
In a very concrete scenario, however, all the values are set and defined, leaving no value open for interpretation. 
The language supports abstraction and concretization of scenarios through its parameter, constraint, and modifier mechanisms. 
7.1.2.3 Scenario variation By allowing the specification of scenarios with higher levels of abstraction, the ASAM OpenSCENARIO language supports the derivation of a variety of concrete scenarios from those abstract descriptions. 
It supports this specifically through the incremental refinement of parameter values via constraints, constraint aggregation, and the ability to randomize parameter values within the given constraint bounds. 
Typical parameters that may vary include: Speed Vehicle type Lighting conditions …​ In a similar manner, a user can randomize or control the overlap of multiple scenarios in a scenario mix or parallel composition. 
7.1.2.4 Hierarchical scenario composition The ASAM OpenSCENARIO language supports the composition of scenarios hierarchically from other scenarios. 
This allows for the reuse of existing scenarios, as well as the incremental build-up of more complex scenarios from simpler pieces. 
Through its composition operators, in combination with the event system, the language allows for emergent behavior from composed scenarios in a controlled fashion. 
7.1.2.5 Modification of object behavior and properties The ASAM OpenSCENARIO language is an object-oriented and aspect-oriented language. 
This means that the user can modify the behavior or other aspects of some or all instances of an object, whether user-defined or system-supplied. 
The objects in the case of the ASAM OpenSCENARIO language can be actors, actions, scenarios, modifiers, or simple data structures. 
The mechanisms used to modify objects allow for the original descriptions to remain undisturbed while adapting objects to a particular scenario or purpose. 
In this way reuse and incremental development of libraries is supported. 
7.1.2.6 Standard actors and extensibility The ASAM OpenSCENARIO language is used to: Identify actors Capture behavior of actors in scenarios For simplification and productivity, the ASAM OpenSCENARIO domain model provides some predefined actors, like vehicles, routes, or environmental conditions. 
The ASAM OpenSCENARIO domain model also provides basic actions that are associated with those actors, such as drive(). 
Starting from this basis, users can define new actors and actions, or refine existing ones. 
These extensions can then be packaged into reusable libraries, distributed, and used in the definition of complex scenarios or even higher-level libraries. 
7.1.2.7 Scenario monitoring The declarative nature of the ASAM OpenSCENARIO language provides for the duality of a scenario specification: It can be taken as a prescription of what scenario to execute. 
It can, however, also be looked at as a specification of what scenario should have happened. 
The language also provides for the specification of measurement points, as described in Section 7.5, "Coverage". 
With this monitoring it is possible to determine whether the criteria for successful completion of a scenario have been met. 
A scenario of ASAM OpenSCENARIO can also contain coverage recording and aggregation constructs in order to aggregate data from successful scenario executions. 
Assuming that you have specified goals for each scenario or type of scenario, you can easily identify scenarios that require more testing. 
7 Language reference manual 7.2 Language structure and syntax

7.2 Language structure and syntax
7.2 Language structure and syntax A ASAM OpenSCENARIO file is processed by an implementation in two phases: Lexical analysis breaks the character stream into individual tokens, yielding a token stream. 
Parsing then processes the token stream into the abstract syntax tree. 
The lexical analysis phase is set out in Section 7.2.1, “Lexical structure”. 
The grammar governing the parsing process is set out in Section 7.2.2, “Grammar of ASAM OpenSCENARIO”. 
A modified BNF grammar notation is used as mentioned in Python 3.10 documentation section 1.2. 
7.2.1 Lexical structure This section provides the lexical analysis definitions for ASAM OpenSCENARIO. 
7.2.1.1 Character set ASAM OpenSCENARIO files use the Unicode character set and must use the UTF-8 encoding. 
Whitespace consists of space (U+0020) and tab (U+0009) characters. 
7.2.1.2 Line structure Like Python, ASAM OpenSCENARIO is based on a logical line structure. 
An ASAM OpenSCENARIO file consists of logical lines: Each statement is fully contained within a logical line. 
Each logical line is constructed from one or more physical lines, using a set of line-joining rules. 
A physical line is a sequence of characters terminated by an end-of-line sequence. 
The end-of-line sequence can be either the CR (U+000D) character, the LF (U+000A) character, or the sequence CR (U+000D) LF (U+000A) characters. 
The end of input/file also serves as an implicit end-of-line sequence. 
Multiple physical lines can be joined into one logical line in the following two ways: A physical line can be explicitly joined to the next physical line by placing the \ backslash (U+005C) character directly before the end-of-line sequence of the previous line. 
The backslash must be placed outside of a string literal or comment. 
A physical line can be implicitly joined to the next physical line by splitting the line inside an expression that employs parentheses or square brackets. 
Logical lines that contain only whitespace, formfeed (U+000C) characters, and possibly a comment, are ignored. 
Each logical line ends with a NEWLINE token indicating the end of the logical line. 
7.2.1.3 Comments Comments start with a number sign character (#, U+0023) that is outside of a string literal. 
They end at the end of the physical line. 
Comments are ignored by the syntax given in Section 7.2.2, “Grammar of ASAM OpenSCENARIO”. 
7.2.1.4 Indentation Whitespace at the beginning of a logical line is considered to be indentation. 
For the purposes of indentation calculation, tab characters are replaced with spaces with the assumption that tab stops are every 8 characters. 
Formfeed characters at the start of a line are ignored for indentation calculations. 
Based on changes to the amount of whitespace on a line after the replacements mentioned above, INDENT and DEDENT tokens are generated using the algorithm specified in Python 3.10 section 2.1.8. 
7.2.1.5 Tokenization Tokens are separated by whitespace, except where indicated otherwise. 
When splitting the input into tokens, tokens comprise the longest possible match that forms a legal token, when read from left to right. 
Besides the already mentioned NEWLINE, INDENT, and DEDENT tokens, the following tokens are recognized in lexical analysis. 
7.2.1.5.1 Keywords and identifiers Identifiers are unlimited in length. 
Case is significant. 
Valid identifiers match the following productions: identifier ::= ( id-start-char id-char* ) | ( '|' non-vertical-line-char+ '|' ) where id-start-char matches all characters of the following Unicode character categories: Ll — Lowercase Letter Lm — Modifier Letter Lo — Other Letter Lt — Titlecase Letter Lu — Uppercase Letter Nl — Letter Number It also matches the underscore character _ (U+005F). 
id-char matches all characters that id-start-char matches, and additionally all characters of the following Unicode character categories: Mc — Spacing Combining Mark Mn — Nonspacing Mark Nd — Decimal Number Pc — Connector Punctuations non-vertical-line-char matches all Unicode characters, except the vertical line | (U+007C) character. 
The second clause in the identifier production defines an alternative way of writing identifiers: It allows the use of characters that normally are not allowed in identifiers, by delimiting the identifier using |. 
Besides allowing the use of any other character in identifiers, such identifiers do not need to be separated by whitespace. 
Certain identifiers are reserved as keywords for use in ASAM OpenSCENARIO built-in language constructs. 
Note however that those keywords are only recognized as keywords in the places identified in the grammar. 
This means that those identifiers should be treated as normal identifier tokens in all other places. 
Table 4. 
List of reserved keywords action actor as bool call cover def default do elapsed emit enum event every expression extend external fall float global hard if import inherits int is it keep list of on one_of only parallel range record remove_default rise scenario serial SI string struct type uint undefined unit until var wait with 7.2.1.5.2 Literals The following literals are recognized by lexical analysis: String literals String literals are constant string expressions matching the following production: string-literal ::= shortstring | longstring shortstring ::= ('"' shortstring-elem* '"') | ("'" shortstring-elem* "'") longstring ::= ('"""' longstring-elem* '"""') | ("'''" longstring-elem* "'''") shortstring-elem ::= shortstring-char | string-escape-seq longstring-elem ::= longstring-char | string-escape-seq string-escape-seq ::= '\' any-char where shortstring-char matches any Unicode character except \, the quote character used to introduce the string or any end-of-line character. 
longstring-char matches any Unicode character except \, and any-char matches any Unicode character. 
Boolean literals The tokens true and false represent the logically true and false Boolean values. 
They are of type bool. 
bool-literal ::= 'true' | 'false' Integer literals Positive integer literals produce an uint value. 
This will be cast implicitly to int type in the appropriate contexts. 
Negative integer literals produce an int value. 
Positive integer literals can also be provided in hexadecimal base through the prefix '0x'. 
It is an error to include a positive integer literal in ASAM OpenSCENARIO source code that cannot be represented using the uint type. 
It is an error to include a negative integer literal in ASAM OpenSCENARIO source code that cannot be represented using the int type. 
integer-literal ::= uint-literal | hex-uint-literal | int-literal uint-literal ::= digit+ hex-uint-literal ::= '0x' hex-digit+ int-literal ::= '-' digit+ digit ::= '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' hex-digit ::= digit | 'A' | 'a' | 'B' | 'b' | 'C' | 'c' | 'D' | 'd' | 'E' | 'e' | 'F' | 'f' Floating-point literals Floating-point literals produce a float value. 
It is an error to include a float literal in ASAM OpenSCENARIO source code that cannot be represented using the float type. 
float-literal ::= ['+' | '-'] digit* '.' digit+ [('e' | 'E') ['+'|'-'] digit+] Physical type literals Physical type literals are literals that produce a valid physical type value. 
physical-literal ::= (float-literal | integer-literal) unit-name unit-name ::= identifier A physical type literal is created when an identifier naming a valid unit is included directly after a valid float or integer literal without any intervening whitespace separating the two parts. 
7.2.1.5.3 Operators and delimiters The following tokens are recognized operators and delimiters of the language: Table 5. 
List of operator and delimiter tokens ' " . 
, : = @ -> | ( ) [ ] ? => and or not == !=  >= in + - * / % 7.2.2 Grammar of ASAM OpenSCENARIO The following grammar is structured for explanatory and normative purposes, not necessarily for parser implementation purposes. 
For example, implementers might want to eliminate left recursions and need to take into account the interactions between lexical analysis and parser for their particular implementation approach. 
7.2.2.1 Top-level structure An ASAM OpenSCENARIO file consists of prelude statements and top-level declarations. 
osc-file ::= prelude-statement* osc-declaration* 7.2.2.1.1 Prelude statements Prelude statements must occur before all other statements in the file. 
prelude-statement ::= import-statement Import statement The import statement makes all definitions found in the referenced file effective as if they had been included in the referencing file. 
import-statement ::= 'import' import-reference NEWLINE import-reference ::= string-literal | structured-identifier structured-identifier ::= identifier | structured-identifier '.' identifier 7.2.2.1.2 Top-level declarations All top-level declarations are currently considered type declarations that are described in detail in the next section. 
osc-declaration ::= physical-type-declaration | unit-declaration | enum-declaration | struct-declaration | actor-declaration | action-declaration | scenario-declaration | modifier-declaration | type-extension | global-parameter-declaration 7.2.2.2 Type declarations Type declarators are the set of all built-in and user-defined types that can be used to declare the type of an entity. 
Note that modifier declarations are not considered to define a type that can be used to declare the type of an entity. 
Modifier names are therefore not considered type declarators. 
type-declarator ::= non-aggregate-type-declarator | aggregate-type-declarator non-aggregate-type-declarator ::= primitive-type | physical-type-name | enum-name | struct-name | actor-name | qualified-behavior-name aggregate-type-declarator ::= list-type-declarator list-type-declarator ::= 'list' 'of' non-aggregate-type-declarator primitive-type ::= 'int' | 'uint' | 'float' | 'bool' | 'string' 7.2.2.2.1 Physical types and units Physical types represent physical quantities and are associated with units. 
physical-type-declaration ::= 'type' physical-type-name 'is' base-unit-specifier NEWLINE physical-type-name ::= identifier unit-declaration ::= 'unit' unit-name 'of' physical-type-name 'is' unit-specifier NEWLINE base-unit-specifier ::= SI-base-unit-specifier unit-specifier ::= SI-unit-specifier SI-base-unit-specifier ::= 'SI' '(' SI-base-exponent-list ')' SI-base-exponent-list ::= SI-base-exponent (',' SI-base-exponent)* SI-base-exponent ::= SI-base-unit-name ':' integer-literal SI-unit-specifier ::= 'SI' '(' SI-base-exponent-list [',' SI-factor] [',' SI-offset] ')' SI-factor ::= 'factor' ':' ( float-literal | integer-literal ) SI-offset ::= 'offset' ':' ( float-literal | integer-literal ) SI-base-unit-name ::= 'kg' | 'm' | 's' | 'A' | 'K' | 'mol' | 'cd' | 'rad' 7.2.2.2.2 Enumerations Enumeration types are the basic user-defined data types. 
They enumerate a finite but extensible set of possible values. 
enum-declaration ::= 'enum' enum-name ':' '[' enum-member-decl (',' enum-member-decl)* ']' NEWLINE enum-member-decl ::= enum-member-name [ '=' enum-member-value ] enum-name ::= identifier enum-member-name ::= identifier enum-member-value ::= uint-literal | hex-uint-literal enum-value-reference ::= [enum-name '!'] enum-member-name 7.2.2.2.3 Structured types Structured types provide a way to build complex types from simpler ones. 
A structured type acts as a container for its members. 
The ASAM OpenSCENARIO language offers four kinds of structured types: Structs Actors Scenarios Actions Structs struct-declaration ::= 'struct' struct-name ['inherits' struct-name ['(' field-name '==' (enum-value-reference | bool-literal) ')']] ( (':' NEWLINE INDENT struct-member-decl+ DEDENT) | NEWLINE ) struct-member-decl ::= event-declaration | field-declaration | constraint-declaration | method-declaration | coverage-declaration struct-name ::= identifier field-name ::= identifier Actors actor-declaration ::= 'actor' actor-name ['inherits' actor-name ['(' field-name '==' (enum-value-reference | bool-literal) ')']] ( (':' NEWLINE INDENT actor-member-decl+ DEDENT) | NEWLINE ) actor-member-decl ::= event-declaration | field-declaration | constraint-declaration | method-declaration | coverage-declaration actor-name ::= identifier Scenarios scenario-declaration ::= 'scenario' qualified-behavior-name ['inherits' qualified-behavior-name ['(' field-name '==' (enum-value-reference | bool-literal) ')']] ( (':' NEWLINE INDENT (scenario-member-decl | behavior-specification)+ DEDENT) | NEWLINE ) scenario-member-decl ::= event-declaration | field-declaration | constraint-declaration | method-declaration | coverage-declaration | modifier-application qualified-behavior-name ::= [actor-name '.'] behavior-name behavior-name ::= identifier Actions action-declaration ::= 'action' qualified-behavior-name ['inherits' qualified-behavior-name ['(' field-name '==' (enum-value-reference | bool-literal) ')']] ( (':' NEWLINE INDENT (scenario-member-decl | behavior-specification)+ DEDENT) | NEWLINE ) 7.2.2.2.4 Modifiers Modifiers provide a means of modifying object behavior. 
Compound modifiers can have the same members that scenario and action structured types allow, with the exception of do directives. 
They allow the modification of behaviors, like scenario, action, or composition operator invocations. 
modifier-declaration ::= 'modifier' [actor-name '.'] modifier-name ['of' qualified-behavior-name] ( (':' NEWLINE INDENT (scenario-member-decl | on-directive)+ DEDENT) | NEWLINE ) modifier-name ::= identifier 7.2.2.2.5 Type extension type-extension ::= enum-type-extension | structured-type-extension enum-type-extension ::= 'extend' enum-name ':' '[' enum-member-decl (',' enum-member-decl)* ']' NEWLINE structured-type-extension ::= 'extend' extendable-type-name ':' NEWLINE INDENT extension-member-decl+ DEDENT extendable-type-name ::= struct-name | actor-name | qualified-behavior-name extension-member-decl ::= struct-member-decl | actor-member-decl | scenario-member-decl | behavior-specification 7.2.2.3 Global parameter declarations Global parameter declarations are declarations of typed parameters that are accessible globally. 
global-parameter-declaration ::= 'global' parameter-declaration 7.2.2.4 Structured type members The following entities are usable as members in structured type declarations, depending on the structured type. 
7.2.2.4.1 Events Events are named entities, signifying a zero-time occurrence in time. 
They can optionally have parameters describing that occurrence. 
Event specifications are specifications of conditions for the occurrence of an event. 
They are used in different places, such as the on or wait directives, or as a formula for an event declaration. 
event-declaration ::= 'event' event-name ['(' argument-list-specification ')'] ['is' event-specification] NEWLINE event-specification ::= event-reference [ [event-field-decl] 'if' event-condition ] | event-condition event-reference ::= '@' event-path event-field-decl ::= 'as' event-field-name event-field-name ::= identifier event-name ::= identifier event-path ::= [expression '.'] event-name event-condition ::= bool-expression | rise-expression | fall-expression | elapsed-expression | every-expression rise-expression ::= 'rise' '(' bool-expression ')' fall-expression ::= 'fall' '(' bool-expression ')' elapsed-expression ::= 'elapsed' '(' duration-expression ')' every-expression ::= 'every' '(' duration-expression [',' 'offset' ':' duration-expression] ')' bool-expression ::= expression duration-expression ::= expression 7.2.2.4.2 Fields Fields represent named data members inside compound types and modifiers. 
field-declaration ::= parameter-declaration | variable-declaration parameter-declaration ::= field-name (',' field-name)* ':' type-declarator ['=' default-value] [parameter-with-declaration] NEWLINE variable-declaration ::= 'var' field-name (',' field-name)* ':' type-declarator ['=' default-value | sample-expression ] NEWLINE sample-expression ::= 'sample' '(' expression ',' event-specification [',' default-value] ')' default-value ::= expression Parameter declarations can contain with blocks that provide relevant constraint declarations. 
parameter-with-declaration ::= 'with' ':' NEWLINE INDENT parameter-with-member+ DEDENT parameter-with-member ::= constraint-declaration 7.2.2.4.3 Constraints Constraints restrict the range of possible values that fields may have during scenario execution. 
constraint-declaration ::= keep-constraint-declaration | remove-default-declaration keep-constraint-declaration ::= 'keep' '(' [constraint-qualifier] constraint-expression ')' NEWLINE constraint-qualifier ::= 'default' | 'hard' constraint-expression ::= expression remove-default-declaration ::= 'remove_default' '(' parameter-reference ')' NEWLINE parameter-reference ::= field-name | field-access 7.2.2.4.4 Methods Methods are member functions defined within a structured type or modifier. 
method-declaration ::= 'def' method-name '(' [argument-list-specification] ')' ['->' return-type] method-implementation NEWLINE return-type ::= type-declarator method-implementation ::= 'is' [method-qualifier] ('expression' expression | 'undefined' | 'external' structured-identifier '(' [argument-list] ')') method-qualifier ::= 'only' method-name ::= identifier 7.2.2.4.5 Coverage Coverage and reporting use similar syntax with the goal of storing data expected to be observed throughout validation or for later analysis. 
coverage-declaration ::= ('cover' | 'record') '(' argument-list ')' NEWLINE 7.2.2.4.6 Modifier application Modifier application syntax. 
modifier-application ::= [actor-expression '.'] modifier-name '(' [argument-list] ')' NEWLINE 7.2.2.4.7 Behavior specification Behavior specifications, in the form of on and do directives provide the behavior description of scenarios and actions. 
behavior-specification ::= on-directive | do-directive On directive on-directive ::= 'on' event-specification ':' NEWLINE INDENT on-member+ DEDENT on-member ::= call-directive | emit-directive do-directive ::= 'do' do-member do-member ::= [label-name ':'] ( composition | behavior-invocation | wait-directive | emit-directive | call-directive ) label-name ::= identifier Composition composition ::= composition-operator ['(' argument-list ')']':' NEWLINE INDENT do-member+ DEDENT [behavior-with-declaration] composition-operator ::= 'serial' | 'one_of' | 'parallel' Behavior invocation behavior-invocation ::= [actor-expression '.'] behavior-name '(' [argument-list] ')' [behavior-with-declaration] NEWLINE behavior-with-declaration ::= 'with' ':' NEWLINE INDENT behavior-with-member+ DEDENT behavior-with-member ::= constraint-declaration | modifier-application | until-directive actor-expression ::= expression Wait directive wait-directive ::= 'wait' event-specification NEWLINE Emit directive emit-directive ::= 'emit' event-name ['(' argument-list ')'] NEWLINE Call directive call-directive ::= 'call' method-invocation NEWLINE method-invocation ::= postfix-exp '(' [argument-list] ')' Until directive until-directive ::= 'until' event-specification NEWLINE 7.2.2.5 Common productions 7.2.2.5.1 Argument list specification argument-list-specification ::= argument-specification (',' argument-specification)* argument-specification ::= argument-name ':' type-declarator ['=' default-value] argument-name ::= identifier 7.2.2.5.2 Argument list argument-list ::= positional-argument (',' positional-argument)* (',' named-argument)* | named-argument (',' named-argument)* positional-argument ::= expression named-argument ::= argument-name ':' expression 7.2.2.6 Expressions expression ::= implication | ternary-op-exp 7.2.2.6.1 Ternary operator ternary-op-exp ::= implication '?' expression ':' expression 7.2.2.6.2 Logical operators implication ::= disjunction ('=>' disjunction)* disjunction ::= conjunction ('or' conjunction)* conjunction ::= inversion ('and' inversion)* inversion ::= 'not' inversion | relation 7.2.2.6.3 Relational operators relation ::= sum | relation relational-op sum relational-op ::= '==' | '!=' | '' | '>=' | 'in' 7.2.2.6.4 Arithmetics operators sum ::= term | sum additive-op term additive-op ::= '+' | '-' term ::= factor | term multiplicative-op factor multiplicative-op ::= '*' | '/' | '%' factor ::= postfix-exp | '-' factor 7.2.2.6.5 Postfix operators postfix-exp ::= primary-exp | cast-exp | type-test-exp | element-access | function-application | field-access cast-exp ::= postfix-exp '.' 'as' '(' type-declarator ')' type-test-exp ::= postfix-exp '.' 'is' '(' type-declarator ')' element-access ::= postfix-exp '[' expression ']' function-application ::= postfix-exp '(' [argument-list] ')' field-access ::= postfix-exp '.' field-name 7.2.2.6.6 Primary expressions primary-exp ::= value-exp | 'it' | identifier | '(' expression ')' value-exp ::= integer-literal | float-literal | physical-literal | bool-literal | string-literal | enum-value-reference | list-constructor | range-constructor 7.2.2.6.7 List and range constructors list-constructor ::= '[' expression (',' expression)* ']' range-constructor ::= 'range' '(' expression ',' expression ')' | '[' expression '..' expression ']' 7.1 Introduction 7.3 Types

7.3 Types
7.3 Types 7.3.1 Type system ASAM OpenSCENARIO is designed to be strong and statically typed. 
All expressions of ASAM OpenSCENARIO have a statically defined type. 
ASAM OpenSCENARIO source code can be type-checked before runtime, ensuring that only well-formed scenarios can be executed. 
The types are classified according to two properties: A type is either built-in or user-defined. 
A type is either composed of other types or not. 
This leads to the following classes of types: Primitive types Primitive types are the built-in basic types. 
Primitive types include the following types: Boolean Integer Floating point String Enumeration types These are user-defined basic types, allowing the user to define purpose-built enumerations of values. 
Physical types These are user-defined basic types that enable the user to define types for physical quantities. 
All physical types include unit information. 
Conversions between physical types take those units into account. 
List types These user-defined aggregate types provide containers for the elements of one type. 
The elements in a list can be any other type, except another list type. 
Compound types These user-defined types can compose other arbitrary types. 
This includes other composed and non-composed types, as well as methods and further components, depending on the kind of compound type. 
The simplest compound types are structs, which contain fields and methods. 
Scenarios comprise fields and methods. 
Scenarios also contain a behavior specification in the form of a do statement. 
Actors comprise fields and methods. 
Actors can also contain actions. 
7.3.2 Primitive types Primitive types are the basic built-in data types natively supported by the language. 
7.3.2.1 Boolean type The Boolean type, called bool, represents binary logical values, which can be either true or false. 
The two values are represented by the literals true and false. 
Code 1. 
Boolean field declaration my_bool: bool = true 7.3.2.2 Integer types The two primitive integer types are int and uint: int A primitive integer type that holds signed integer values with 64-bit size. 
It supports the range of whole values from -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 inclusively. 
Integer literals can be denoted in decimal using unadorned integer literals, like -42. 
They can also be denoted in hexadecimal, using a prefix of 0x, for example, `0x0539`. 
uint A primitive integer type that holds unsigned integer values with 64-bit size. 
It supports the range of whole values from 0 to 18,446,744,073,709,551,615 inclusively. 
Integer literals can be denoted in decimal using unadorned integer literals, like 42. 
They can also be denoted in hexadecimal, using a prefix of 0x, for example, `0x0539`. 
Code 2. 
Integer field declarations my_int: int = -42 my_hexa_int: int = 0x0539 my_uint: uint = 42 my_hexa_uint: uint = 0x0539 7.3.2.3 Floating-point type The floating-point type, called float, holds floating-point values according to the ANSI/IEEE Std 754-2019 binary64 (formerly called double precision) basic floating-point format. 
Floating-point literals are denoted in decimal using the following format: ["+"|"-"]number[.number]["e"|"E"["+"|"-"]number] The conversion from int and uint to float is implicit, but the conversion from float to int or uint requires explicit conversion operators. 
Automatic conversion from int or uint to float can lead to loss of precision for values that are not representable exactly in the 53-bit mantissa of binary64 floating-point format. 
Code 3. 
Floating-point field declarations my_float: float = 3.14159 my_exp_float: float = 42.0E4 7.3.2.4 String type The string type represents strings of Unicode characters. 
It is considered a primitive built-in basic type in ASAM OpenSCENARIO. 
No separate type for individual characters is provided. 
String literals are denoted using a subset of the Python string literal syntax, as specified in Section 7.2, "Language structure and syntax". 
Code 4. 
String field declarations my_string1: string = "Hello, World!" my_string2: string = 'String Value' 7.3.3 Enumeration types Enumeration types are the basic user-defined data types. 
They enumerate a finite but extensible set of possible values. 
An enumeration type consists of a set of named unique members. 
Already declared enumeration types can be extended, extending the set of named unique members. 
Each instance of an enumeration type can hold one of the members at any one point in time. 
Each enumeration member is assigned a unique unsigned integer value, either explicitly or implicitly. 
By default, the implicit enumeration member values are derived automatically using succeeding integer values from the last explicitly given integer value, or from 0 if no such value exists. 
If enumeration types are extended, then implicit integer values will be derived as above, with the last existing enumeration member giving the starting point, until an explicit value is given. 
Code 5. 
Enumeration type definitions enum rgb_color: [red, green, blue] enum cmyk_color: [cyan = 1, magenta = 2, yellow, black] extend rgb_color: [alpha] All conversions between integer and enumeration types have to be performed using explicit conversion operators. 
Code 6. 
Conversion # Example enumeration fields my_rgb_color: rgb_color = green my_cmyk_color: cmyk_color = black my_new_rgb_color: rgb_color = alpha # Conversion to integer x: int = my_rgb_color.as(int) # x == 1 y: int = my_new_rgb_color.as(int) # y == 3 z: uint = my_cmyk_color.as(uint) # z == 4 # Conversion from integer my_car_color: cmyk_color = 3.as(cmyk_color) # my_car_color == yellow The named members of an enumeration type are available as literals of that type. 
If multiple enumeration types use the same literal, then the literal is overloaded: Which literal and hence value the literal is evaluated to will depend on the type requirements of the place it is used in. 
If this ambiguity cannot be resolved uniquely, meaning multiple choices would remain valid after type resolution, an error is signaled. 
In order to avoid the potential for such errors, or to be specific which enumeration type is needed, enumeration members can be referenced with the enumeration type prefixed with a separating ! character. 
Code 7. 
Overloading and using explicit literals # Extend rgb_color again, adding black, which overloads black with cmyk_color!black extend rgb_color: [black] # Example enumeration fields my_rgb_color: rgb_color = rgb_color!green # Can always use long name my_cmyk_color: cmyk_color = black # Resolved to cmyk_color!black my_new_rgb_color: rgb_color = black # Resolved to rgb_color!black # Resolution in expressions field1: bool = (black == black) # Could be either type -> error signalled field2: bool = (rgb_color!black == rgb_color!black) # True 7.3.4 Physical types and units In addition to the pure numeric basic types, ASAM OpenSCENARIO supports the definition of physical types. 
Physical types represent physical quantities. 
The definition of a physical type has to provide two parts: The basis for representing a physical quantity (like mass). 
A base unit that is used to measure that quantity. 
The definition of additional units for a given physical type allows the use of other, more common units to define or represent that physical quantity. 
Performing unit and dimension checks on all physical calculations is still possible with these newly defined types. 
The physical types are commonly used in the domain model, mainly to define entity properties that are of a physical nature. 
The unit system employed in ASAM OpenSCENARIO is based on the approach taken in the "Functional Mock-Up Interface for Model Exchange and Co-Simulation", Version 2.0.2. 
This approach is based on the International System of Units (SI). 
Units are defined by specifying the following properties: The exponents of the 7 SI base units (kg, m, s, A, K, mol, cd). 
The exponent of the radian (rad). 
A factor. 
An offset. 
The following unit definition specifies 1 as the exponent to the SI base unit meter and 1000.0 as the factor. 
Code 8. 
Defining a new physical unit 'km' unit km of length is SI(m: 1, factor: 1000.0) All units of a physical type have identical exponents for all SI base units and the radian. 
All units can therefore be converted directly. 
For conversion the base unit value is calculated from the unit value specified according to the following formula: base_unit_value = unit_value * factor + offset The basic physical types in ASAM OpenSCENARIO are: mass length time angle temperature luminous_intensity electrical_current amount_of_substance The base units of these types are the SI base units. 
Other types and units (like speed, angular_rate, pressure, and illuminance, among others) are defined in the domain model. 
Physical types and units are defined using the following syntax: type  is SI(: [,...,:]) unit  of  is SI(:[,...,:], factor: , offset: ) Code 9. 
More examples for defining units type length is SI(m: 1) unit m of length is SI(m: 1) unit foot of length is SI(m: 1, factor: 0.3048) type speed is SI(m: 1, s: -1) type acceleration is SI(m: 1, s: -2) unit |foot/s| of speed is SI(m: 1, s: -1, 0.3048) unit |foot/s^2| of acceleration is SI(m: 1, s: -2) unit |foot/s/s| of acceleration is SI(m: 1, s: -2) unit g of acceleration is SI(m: 1, s: -2, factor: 9.80665) unit kmh of speed is SI(m: 1, s: -1, factor: 0.27777777778, offset: 0.0) unit deg of angle is SI(rad: 1, factor: 0.0174532925199, offset: 0.0) unit F of temperature is SI(K: 1, factor: 0.5555555556, offset: 255.372222222) Units are specified in physical type literals by giving the unit name directly after the float literal. 
Code 10. 
Specifying units in physical type literals my_dist: length keep(my_dist == 15|foot/s| * 3s + 10m) keep(my_dist == 10m) my_speed: speed keep(my_speed == 5m / 2s) A unit specification is a mandatory part of any physical type literal. 
Unit names form their own separate global namespace. 
All unit names must be globally unique within that namespace. 
The design of the units does not currently allow the definition of units defined by logarithmic factors of the quantity (for example dBW). 
This feature might be included in future extensions of the standard. 
7.3.5 Compound types ASAM OpenSCENARIO provides for several compound types that are a means to group together elements that are logically related. 
This chapter gives an overview of the compound types available in the language. 
Compound types are grouped into Section 7.3.5.1, “Structured types” and Section 7.3.5.2, “Aggregate types”. 
7.3.5.1 Structured types Structured types provide a way to build complex types from simpler ones. 
A structured type acts as a container for its members. 
The ASAM OpenSCENARIO language offers four kinds of structured types: Structs Actors Scenarios Actions Additionally, ASAM OpenSCENARIO provides modifiers, which are similarly structured as scenarios and actions but are not considered a proper structured type in their own right (see Section 7.3.5.1.5, “Modifiers”). 
All of these structured types, as well as modifiers, may contain the following kinds of members: Fields Methods Event definitions Constraints Coverage Specific structured types can have additional kinds of members. 
Fields represent data members inside structured types. 
Each field has a defined type. 
When instantiating a structured type, each field holds an instance of its respective type. 
A field can be defined as a parameter or a variable. 
Methods describe and implement the behavior of an object, which is an instantiation of a class. 
Fields, methods, and events are named and must have a unique name within the type. 
Structured types may be extended, which means they can be modified after their initial declaration (see Section 7.3.9, “Extension”). 
They may also be derived from existing structured types (see Section 7.3.8, “Inheritance”). 
However, a structured type may only be derived from the same kind of type: For example, a scenario cannot be derived from a struct. 
The difference between inheritance and extension is that the former creates a new type, while the latter modifies an existing type without creating a new one. 
7.3.5.1.1 Structs There are many situations where multiple values, methods, and other elements belong to a larger entity. 
The struct types provide the most basic way of composing these into a more complex data type. 
Code 11. 
struct definition enum traffic_light_colors: [red, amber, green] struct traffic_light: id: int name: string pose: pose_3d active_colors: list of traffic_light_colors country: string Structs do not offer any additional members beyond the common ones. 
7.3.5.1.2 Actors The actor keyword can be used to declare user-defined types of actors. 
Actors are entities that can perform actions within a scenario. 
Code 12. 
actor definition actor rock: kind: string weight: mass extent: length position: position_3d Actors do not offer any additional members beyond the common ones. 
7.3.5.1.3 Scenarios A scenario is a structured type that describes the behavior of one or more actors in a traffic system. 
It can optionally be associated with an actor that can be referenced within the scenario via the implicit actor field. 
This actor is called the associated actor and can be interpreted as the actor performing the behavior described in the scenario. 
However, within a scenario, the actor field and other parameter fields can be used in the same way. 
A scenario can have at most one associated actor, but an actor can have multiple associated scenarios. 
In addition to the general structured type members, a scenario can contain behavior specifications, in the form of on and do directives. 
Not more than one do directive can be effectively present in any scenario or action. 
Multiple on directives may be present. 
The do directive allows the specification of unconditional behavior of the scenario, by invoking other behaviors (actions and scenarios). 
The temporal relationships behaviors invoked by a scenario are described using scenario composition operators (see Section 7.3.13, “Scenario composition”). 
Scenarios can also contain modifier applications (see Section 7.3.12, “Modifiers”). 
A behavior invocation can include a with block that can contain constraint declarations, modifier applications, and until directives. 
Inside the with block, the special expression it can be used to reference the invocation that the with block is attached to. 
Code 13. 
scenario definition scenario pass_ego: ego: vehicle passing_car: vehicle do parallel: ego.drive() with: speed(50kph) passing_car.drive() with: lane(left_of: ego) speed(70kph) The on directive allows the invocation of emit and wait directives when the event that is specified in the on directive occurs (see Section 7.3.10, “Event definitions”). 
When invoking behaviors (actions and scenarios) or applying modifiers, arguments passed in through the argument list result in constraints on the parameter fields of the behavior or modifier as follows: If a single value of the given declared type (or a subtype thereof) is passed in, an equality constraint between the parameter and this value is active during the invocation: do ego.change_speed(target: 10kph) is semantically equivalent to the following constraint being applied inside the action: keep(target == 10kph) If a range expression is passed in for a parameter with a declared numeric type, an in-range constraint between the parameter and this range is active during the invocation: do ego.change_speed(target: [10kph..25kph]) is semantically equivalent to the following constraint being applied inside the action: keep(target in [10kph..25kph]) The argument list can make use of positional or named arguments, as described in Section 7.4.2.1, "Method application". 
The inheritance of scenarios is restricted in that scenarios associated with an actor must only inherit from a scenario associated with an actor of the same type, or associated with an actor of a more general type. 
Scenarios associated with no actor must only inherit from a scenario associated with no actor. 
7.3.5.1.4 Actions Actions are similar to scenarios in that they can have the same members, including optional behavior specifications. 
Actions differ from scenarios in that, from the perspective of an ASAM OpenSCENARIO specification, they are seen as atomic behavior descriptions that cannot be further decomposed: Their internal structure, if any, is to be considered opaque from the point of view of the user. 
Implementations are therefore free to implement actions specified in the domain model in implementation-defined ways or using the ASAM OpenSCENARIO language features as they see fit. 
For the specialization of actions via inheritance, the same restrictions regarding associated actors apply as for scenarios (see Section 7.3.5.1.3, “Scenarios”). 
7.3.5.1.5 Modifiers Compound modifier declarations can have the same members as scenario and action structured type declarations, except do directives. 
Modifiers can influence the behavior by applying them to actors, scenarios, and behavior invocations as well as scenario composition operators. 
They are however not considered proper structured types, since they cannot be used as types for fields or arguments, nor do they support inheritance or extension. 
Instances of modifiers are only implicitly created through modifier applications. 
Modifiers are described in more detail in Section 7.3.12, “Modifiers”. 
7.3.5.2 Aggregate types Aggregate types serve as containers for uniform members of another type. 
Currently, ASAM OpenSCENARIO provides only the list type as an aggregate type. 
7.3.5.2.1 Lists A list is an ordered container of unnamed members. 
Each list is declared with a specific member type. 
All members shall be of this type or of a type derived from it (see Section 7.3.8, “Inheritance”). 
The list’s element type can be any type, except another list. 
Lists have a variable size, but the size can be constrained. 
Basic operations on lists are: access a member by index retrieve the number of contained elements (i.e. 
the list’s size) filter (create a new list with only selected items) check if a list contains a specific object / all objects of another list compare two lists for equality Lists can be initialized with comma separated elements in square brackets. 
List types are the only types that don’t have a name. 
car_list: list of vehicle = [car1, car2] List operators are discussed in Section 7.4, "Expressions". 
7.3.6 Fields Fields belong to structs, actors, scenarios, actions, or modifiers. 
They represent named data members inside those compound types. 
Each field has a name, a defined type, and a value. 
At runtime, a field holds a value of the defined type. 
A field can be defined as a parameter or a variable: A parameter field can be assigned a value through constraints. 
A variable field can be assigned a value through procedural code assignment. 
Code 14. 
driving_speed struct driving_speed: area: area_kind speed: speed keep(area == city => speed  speed  speed = 0kph) All of the fields in the declaration have the same type, default value, and constraints. 
7.3.6.1 Difference between parameters and variables Within ASAM OpenSCENARIO, fields are separated into parameters and variables. 
Parameters and variables are used to define usability and mutability during two processing stages. 
The first stage is scenario initialization and the second one is scenario execution. 
Parameters are assigned their values during scenario initialization through constraint propagation. 
The values assigned remain constant over the subsequent scenario execution stage. 
Variables can change over time, including scenario initialization and scenario execution stages. 
7.3.6.1.1 Parameters Parameters are fields that are evaluated and fixed before scenario execution. 
An example is the maximal acceleration property of a vehicle behavioral model. 
This parameter must be set before the scenario execution. 
Parameters have the following properties: All fields are parameters by default, if not specified otherwise. 
Parameters are bound during the scenario initialization stage and are fixed from start of scenario execution. 
A parameter value is selected from all the possible values of the field type that comply with all the constraints applicable to that parameter. 
The selection between multiple possible values is arbitrary. 
For example, it can be randomized. 
To set a parameter to a specific value, write a constraint that requires that value. 
An equality constraint is an example of a constraint that can be used in that case. 
Parameters have an optional default value specification. 
Specifying a default value is exactly equivalent to providing an equality constraint of strength default with the left-hand side being the parameter, and the right-hand side being the default value expression. 
Parameter field declarations can also include an optional with block with additional constraint declarations. 
Inside the with block, the special expression it can be used to reference the field that the with block is attached to. 
See Code 17 for an example of the with block as applied to field declarations. 
7.3.6.1.2 Variables Variables are fields that are allowed to change over time. 
A variable receives a default value if no value is assigned to it. 
The default value is specified using a default value specification or as part of a sample expression. 
The default value is evaluated at the time the instance that contains the variable is instantiated. 
A value can be assigned either explicitly or through the connection of the variable to the simulation state. 
An example is the current velocity of a vehicle during scenario runtime. 
At runtime, a driver model controls the current velocity value. 
Variables have the following properties: Variables must be specified explicitly with the keyword var. 
Variables always have a value. 
Variables are modified and handled by external sources such as driver models or simulators and by the sample construct. 
Variables cannot be constrained. 
But parameters can be constrained by sampling the values of the variables during constraint resolution. 
If a variable of structured type is declared, this results in all its fields behaving as variables, even if they are not declared as variables themselves. 
Code 16. 
Constraining parameters by variable value sampling scenario vehicle.follow_vehicle: other: vehicle distance: length do actor.change_space_gap(target: distance, direction: behind, reference: other) scenario main: ego: vehicle car1, car2: vehicle var dist: length = sample(ego.object_distance(reference: car1, direction: longitudinal), every(2s)) do serial: parallel: car1.drive() with: speed(50kph) ego.drive() with: position(behind: car1) car2.follow_vehicle(other: ego, distance: dist) 7.3.6.2 Field examples 7.3.6.2.1 Scalar field declarations The following example shows an actor with two fields of type speed: A variable named current_speed that holds a value specifying the current speed. 
Most likely this variable is assigned different values while a scenario is running. 
A parameter named max_speed that has a default constraint. 
This variable receives a value during the pre-run generation of 120 kmph, unless its constraint is overridden. 
Code 17. 
Scalar field declarations actor my_car inherits vehicle (vehicle_category == car): var current_speed: speed max_speed: speed with: keep(default it == 120kmph) 7.3.6.2.2 Scenario field This example shows a struct field storm_data instantiated in a scenario called env.snowstorm. 
Constraints are set on the two fields of storm_data. 
The wind_velocity field is monitored for coverage. 
Code 18. 
Scenario field enum storm_type: [rain_storm, ice_storm, snow_storm] struct storm_data: storm: storm_type wind_velocity: speed scenario env.snowstorm: storm_data: storm_data with: keep(it.storm == snow_storm) keep(default it.wind_velocity >= 30kmph) cover(wind_velocity, expression: it.wind_velocity, unit: kmph) 7.3.6.2.3 Structured type variables This example shows a struct variable current_position instantiated in an actor car. 
Code 19. 
Structured type variable struct position: x: float y: float z: float actor car: var current_position: position keep(current_position.x  int is expression arg1.filter(it % 2 == 0) def my_add(x: float, y: float) -> float is expression x+y def my_sin(x: float) -> float is external com.example.cpp(identifier: "sin") def my_distance(x1: float, y1: float, x2: float, y2: float) -> float is undefined def my_distance(x1: float, y1: float, x2: float, y2: float) -> float is only external com.example.python(module: "mymod", name: "my_dist") Each method has a fully specified type signature, which is given as part of the declaration of the method: Code 21. 
Method declaration syntax def () [-> ]  For each method argument, its name and type are specified: Code 22. 
Method definition def my_add(x: float, y: float) -> float is expression x+y Optionally default values can be specified for arguments: Code 23. 
Method definition def my_add(x: float, y: float = 1.0) -> float is expression x+y This allows the caller of a method to not provide a value for a given argument. 
Inside the method body, the argument will then have the value of the expression given as the default value. 
This expression is evaluated at the time of the method invocation, prior to the execution of the method implementation. 
It is only evaluated when no value for the argument is passed in the invocation of the method. 
The optional type of the returned value of the method is specified after the argument list declaration. 
Methods without a declared return type can only be invoked with the call directive in behavior specifications. 
They cannot be invoked in other expressions. 
Code 24. 
External logging method def my_value_logger(val: float) is external com.example.cpp(identifier: "my_logger") A method declaration is followed by the method implementation. 
There are two basic kinds of implementations for a method: Expression methods are implemented by providing an ASAM OpenSCENARIO expression that yields the return value as the result of its evaluation. 
External methods are implemented outside of ASAM OpenSCENARIO. 
The mechanism to bind implementations to the method declaration is implementation-specific. 
7.3.7.1 Undefined methods Additionally, a method can be explicitly left unimplemented, making it an undefined method: Code 25. 
Undefined method syntax def () [-> ] is [only] undefined An undefined method can only be invoked if an overriding implementation is provided through inheritance or extension. 
If an undefined method is invoked without an implementation, an error is raised. 
It is intentionally left open whether implementations will only detect this at runtime or can already detect this at compile time through static analysis. 
In either case, an error is only raised if an undefined method is actually invoked, not if there is just the potential that it could be invoked. 
7.3.7.2 Overriding methods When methods are overridden through inheritance or extension mechanisms, the overriding method implementation must contain an only qualifier. 
Otherwise, an error is raised. 
An error is raised if the method type signature of an overriding method is different from the method it is overriding. 
It is not an error if a method definition contains an only qualifier and there is no existing method to be overridden. 
7.3.7.3 Expression methods Expression methods are implemented by providing an ASAM OpenSCENARIO expression that yields the return value for a method invocation. 
The expression can reference the named arguments of the method as well as all other fields that are in scope. 
Code 26. 
Expression method syntax def () [-> ] is [only] expression  7.3.7.4 External methods The implementation of an external method can be defined in any programming language that is supported by the ASAM OpenSCENARIO implementation: The structured identifier in combination with the optional argument list provides an implementation-defined specification of the external method definition. 
The ASAM OpenSCENARIO implementation uses this information to locate the external method implementation. 
A future release of ASAM OpenSCENARIO might standardize specifications for the support of certain external languages. 
For this reason, a set of identifiers is reserved for use in future versions of the specification. 
Any structured identifier starting with the identifier osc is reserved for future use. 
Code 27. 
External method syntax def () [-> ] is [only] external () 7.3.8 Inheritance Inheritance in ASAM OpenSCENARIO takes on a role similar to other class-oriented languages. 
It is a mechanism of basing a class upon another class, retaining its members and behavior while allowing the new class to modify them to its needs. 
Inheritance can be applied to structs, actors, scenarios, and actions. 
ASAM OpenSCENARIO provides two types of inheritance: Unconditional inheritance Conditional inheritance 7.3.8.1 Unconditional inheritance ASAM OpenSCENARIO allows single inheritance between extensible classes. 
This works like inheritance in most OO programming languages: A new subtype is declared, endowed with all the features of the parent type (supertype). 
Both types are accessible. 
Modifications to the supertype are automatically applied to the subtype. 
Changes to the subtype do not affect the supertype. 
Code 28. 
Unconditional inheritance struct base: f1: bool struct derived inherits base: f2: bool #derived has both f1 and f2 fields The inherited structured type members are retained in the inheriting type. 
The inheriting type can add new structured type members that are valid for the structured type. 
For method members, the inheriting type can also override existing method implementations as specified in Section 7.3.7.2, “Overriding methods”. 
Any added members must, in combination with any existing members, still fulfill all relevant restrictions for the specific compound type: For example, not more than one do directive can be effectively present in any scenario or action. 
The inheritance of scenarios and actions is restricted in that: scenarios and actions belonging to an actor must only inherit from a scenario or action belonging to an actor of the same type, or an actor of a more general type, and scenarios and actions not belonging to an actor must only inherit from a scenario or action not belonging to an actor. 
7.3.8.2 Conditional inheritance Conditional inheritance enables the creation of subtypes that depend upon a value of a Boolean or enumerated field in the base type. 
The condition always sets a single field to a specific value. 
The field value (determinant) is a constant literal that is fixed during execution. 
Conditional inheritance is specified by declaring the field and value that defines the dynamic subtype. 
7.3.8.2.1 Defining conditional inheritance Code 29. 
Conditional inheritance extend vehicle: is_electric: bool actor truck inherits vehicle (vehicle_category == truck): ... 
# Fields / methods / events unique to truck actor electric_vehicle inherits vehicle(is_electric == true): ... 
# Fields / methods /events unique to electric_vehicle Why is conditional inheritance based on attributes? Because this allows for multiple orthogonal dimensions. 
Like truck, bus, and so on, but also electric_vehicle versus non-electric. 
Because it lets you add constraints on the attributes. 
For example, "I want 20% trucks", or "No electric buses". 
Because in verification, initially, you do not know if you want sub-types. 
Perhaps you just have the is_electric: bool field, and later you want to make it into a sub-type (for example, to add the remaining_charge field). 
7.3.8.2.2 When to use conditional inheritance Use conditional inheritance in the following cases: When you want the type to auto-specialize to the "right" sub-type. 
For example, define tp: traffic_participant and it becomes a person / animal / vehicle. 
Use unconditional inheritance in the following cases: When you do not want the type to auto-specialize to the "right" sub-type. 
For example, define r: road, and it will not become child-of-road. 
There is no way to auto-specialize in unconditional inheritance. 
The reasons are: It is unclear, which sub-types can live together. 
It is unclear, if you need to specialize. 
For example, if you only created sub-types for the "special" cases, but the parent actor can also be used sometimes. 
7.3.8.2.3 Relations between conditional and unconditional Inheritance The rule governing the relationship between these two kinds of inheritance is as follows: Rule 1: A conditional type cannot be inherited unconditionally. 
Inheritance relationships form a tree whose trunk is the predefined types. 
Main limbs are inherited unconditionally. 
The final branches of the unconditional inheritance tree can be the roots of conditionally inherited sub-trees. 
7.3.8.2.4 Relations between conditional subtypes Any pair of conditional subtypes (types conditionally inherited from the same supertype) have one of the following relationships: One of the types can be a supertype of the other. 
Both types have a common supertype (meaning they are orthogonal). 
7.3.8.2.5 Type membership Consider a field declared as type car. 
It may be assigned an object whose emergency_vehicle field is set to true. 
Because the field is declared as type car, its value must be an instance of car, and only features of car are accessible. 
The language also provides type-membership checking, using the is() and as() operators. 
Using type checking, you can access features under an active subtype, even though it is not the declared type. 
Such active but undeclared subtypes (police_car in this example) are called latent subtypes. 
This is summarized by the following two rules: Rule 2: The declared type determines the type membership of an object. 
Rule 3: Dynamic type check allows access to latent subtype features. 
extend vehicle: emergency_vehicle: bool actor car inherits vehicle (vehicle_category == car): ... 
# Fields / methods /events unique to car actor police_car inherits car(emergency_vehicle == true): ... 
# Fields / methods /events unique to police_car 7.3.9 Extension An extension enables the user to manipulate elements that are already defined in the code. 
Manipulation in this case means adding, changing, or fine-tuning. 
All instances of a type are endowed with the union of features declared in all the extensions of that type. 
Features in an extension cannot shadow previously declared features. 
But some features, like method declarations, allow overrides. 
Extension modifies the type being extended. 
All instances of the type get the newly added features. 
For instance, adding a weight field to the car actor adds this field to every car in every scenario. 
Extension is different from inheritance, where you define a new type. 
Extension is helpful if a library of inter-related actors and scenarios already exists, and you just want to add some fields, constraints, scenarios, or other features to accommodate project-specific needs. 
Extension can be applied to the following entities: Enumerated types Adding new items to an already defined enumerated type. 
Structs, actors, scenarios, actions Adding new structured type members, for example, fields, methods, or events - or overriding method implementations. 
Coverage Fine-tuning coverage item behavior. 
Extensions are applied at compile time. 
Any added members must, in combination with any existing members, still fulfill all relevant restrictions for the specific compound type: For example, not more than one do directive can be effectively present in any scenario or action. 
7.3.10 Event definitions 7.3.10.1 Introduction Events are named entities, signifying a zero-time occurrence in time. 
Events can optionally have parameters describing that occurrence. 
Typically, events are used to indicate the occurrence of a particular situation. 
The start, end, or failure of a scenario are predefined events. 
Via event specifications, events can be specified to occur when a certain condition renders true. 
Events can also be emitted and waited for by scenarios, which provides means for synchronizing concurrently active scenarios. 
Events are defined using the event structured type member declaration. 
For example: event car_arrived # An event with no parameter event accident_occurred(other_car: vehicle) # An event with a single parameter event e1 is @e2 if (x > y) # An event with a formula Event specifications are specifications of conditions for the occurrence of an event. 
They are used in different places, such as the wait statement, to specifically describe the event that is waited for, or in the on directives, to specify the event that shall trigger a specific behavior. 
Event specifications can also be used in an event declaration to describe a condition under which the event occurs. 
For example: on @x.accident: # When the event happens, do something call dut_error(...) wait distance_to(car2)  y) # Emits e1 when e2 happens and the Boolean expression returns true 7.3.10.2 Events Syntax: event  [()] [is ] Events are declared as members of any structured object. 
Events have a name, and optional arguments (parameters). 
The arguments are specified like the arguments to a method definition: Each argument has a name, a type, and an optional default value. 
The default value expression is evaluated at the time of an event being emitted if no value is provided for the given argument. 
The result of evaluating the default expression is then used as the value for the argument as if provided by the event emitter. 
An event can have an event specification that describes an event or a condition, or both, under which the event is emitted. 
An event specification is only allowed to be provided for events with no parameters. 
Events are inherited as any other structured type members. 
Their declaration can be overridden by inheriting types. 
Events are emitted in one of the following ways: Via emit directives Through external code By declaring an event with an event specification that specifies a condition under which the event occurs Executing scenarios triggers certain built-in scenario life cycle events (see Section 7.3.10.3, “Pre-defined events”) The emit directive emits an event and specifies values for all parameters (for events with parameters). 
emit  [()] 7.3.10.3 Pre-defined events The following events are pre-defined for all scenarios: The start event marks the beginning of the execution of a scenario. 
The end event is emitted when a scenario execution is finished. 
The fail event is emitted if the scenario cannot reach its end – for example, if the allotted duration time elapses. 
7.3.10.4 Event specifications The syntax of an event specification is as follows: @ [[as ] if ] Alternatively, just an event condition can be provided:  An event specification is said to produce an event occurrence: If just the event condition is specified, the event occurs whenever the condition evaluates to true. 
If just the event-path is specified, then the event occurs whenever that event occurs. 
If both are specified, then whenever the event occurs, the event condition is evaluated: If it evaluates to true, the event occurs. 
An event condition can consist of one of the following expression types: bool expression: An expression that returns a value of type bool, which is the value of the condition. 
rise expression: Returns true when the bool expression specified inside the parentheses changes values from false to true, otherwise returns false. 
fall expression: Returns true when the bool expression specified inside the parentheses changes values from true to false, otherwise returns false. 
elapsed expression: Returns true from the first time instant when the time that passed from the start of the event context equals or exceeds the duration expression specified inside the parentheses, and all later time instants. 
Returns false otherwise. 
every expression: Returns true at each first time instant when the time that passed from the start of the event context equals or exceeds a multiple of the duration expression specified inside the parentheses. 
Returns false otherwise. 
If an optional offset named argument is included, then the first instance (and all further instances) will be offset into the future by the given duration. 
Otherwise, the first instance will be at the start of the event context. 
The start of the event context is defined as follows: If the event specification is used in a wait directive, the start of the event context is the start of the execution of the wait directive. 
If the event specification is used in an until directive, the start of the event context is the start of the execution of the annotated behavior invocation or composition. 
If the event specification is used in an on directive, the start of the event context is the start of the execution of the scenario or action that contains the on directive. 
If the event specification is used in a sample expression, the start of the event context is the start of the execution of the scenario or action that directly or indirectly contains the variable declaration that uses the sample expression. 
If an event specification is used in an event declaration, the event context of the event specification will be the event context of the place of use of the declared event. 
For elapsed and every expressions, as well as for the evaluation of pure event conditions, the minimum internal time resolution or time quantum of an implementation is implementation-defined. 
If the minimal time quantum is not sufficiently small to allow an implementation to hit the trigger points exactly, then the trigger points will be moved to the next possible time instant. 
Implementations should take the required trigger points into account when they are capable of determining suitable minimum time quanta. 
If an event-path is specified, then the referenced event occurrence can be bound to a field using the as  clause: This clause makes a field with the given name available in the current context, that holds the event object, to allow access to its parameters. 
Aside from the declaration of events, event specifications are used in the following language constructs: wait directive, delaying the execution of a scenario until the specified event occurs. 
on directive, executing actions immediately when the specified event occurs. 
until directive, terminating a nested scenario when the specified event occurs. 
Sampling of values using sample() when the specified event occurs. 
Some use cases require accessing information about an event after it has occurred, which is possible in ASAM OpenSCENARIO. 
The scope of the event specified in an event specification is as follows: on directive: The event field name defined in the event specification of the on directive can be used within the body of the on directive, for example, to access an event parameter and pass it to the call of an external method. 
sample statement: The event field name defined in the event specification used within a sample statement can be used within the expression part of the sample statement. 
In all other cases, such as wait or until, an event cannot be accessed beyond the event specification. 
That is, the event field name can only be used within the if clause of an event specification if one is present. 
7.3.10.5 Examples until (dist(v1, v2)  y) # When car1 had an accident and x is bigger than y wait rise(terrible_accident) # When terrible_accident changes from false to true wait elapsed(20sec) # When 20 seconds have passed car2.stop() In the above example car2 will stop if one of the following happens: car1 emitted the event accident and x is bigger than y terrible_accident changes from false to true 20 seconds have passed A more complex example: actor car inherits vehicle (vehicle_category == car) scenario main: dut: car do t: dut.test_drive() scenario car.test_drive: event go event brk(dx: length) car1: car def measure(d: length) is external myext("measure") do parallel: serial: emit go (1) d1: dut.drive() emit brk(dx: 10m) (2) serial: wait @go d2: car1.drive() wait @brk as dat if dat.dx  5m: (4) call measure(s.dx) 1 The go event is emitted. 
2 The brk event with a dx of 10 m is emitted. 
3 The scenario execution ends when dx is less than 20 m. 
4 If the distance dx is greater than 5 m on emission of the brk event, execute the on modifier. 
In the above example the go event is emitted, enabling car to perform drive() and then wait for the brk event. 
When brk is received with the proper distance, execution ends. 
The event brk may also cause the on modifier to execute, depending on the Boolean condition. 
7.3.11 Constraints A constraint restricts the range of possible values that parameter fields may have during scenario execution. 
In this chapter, the construct of constraints is introduced and its structure and functionality are explained. 
See Section 7.6, "Semantics" for the interaction of constraints and overall semantics. 
7.3.11.1 Declaration and mandatory body of constraints Constraints can be declared as members of a structured type, which may be a struct, a scenario, an action, an actor, or a modifier. 
They can also be declared using a with clause on specific fields and on behavior invocations. 
In a structured type declaration, constraints are declared using the keyword keep, followed by a Boolean expression. 
This Boolean expression is the mandatory part of the constraint body. 
It defines the relationship between any fields referenced in the expression. 
A constraint is considered satisfied if the expression evaluates to true. 
The fields that are referred to in the Boolean expression may reside in the same instance of a structured type. 
The fields may also refer to scopes of different instances. 
In the second case, those fields must be identified using path expressions to access the respective scope. 
Any Boolean expression can be used in constraints (see Section 7.4, "Expressions"). 
In a constraint, there should be at least one parameter that is affected by the constraint. 
See Section 7.2.2.4.3, "Constraints" for the syntax of constraint declarations. 
7.3.11.2 Time aspect of constraints Scenario execution is a multi-stage process. 
The set of constraints that are applicable at any point in time is determined according to the rules described in this section. 
This section uses the term "applying" constraints instead of "satisfying" constraints: A constraint is applicable and is therefore applied when it pertains to the current point in time of scenario execution. 
Whether an applicable constraint needs to be satisfied depends on the strength of the constraint itself and other applicable constraints, as described in Section 7.3.11.3, “Constraint strength”. 
Constraints are applied as long as their scope is active. 
Constraints apply for the lifetime of the instance of the structured type in which they are declared. 
If a constraint is placed inside the declaration of a scenario, then the constraint applies to the lifetime of that scenario. 
If a constraint is placed inside a behavior invocation (meaning a scenario invocation or an action invocation) inside a scenario, then the constraint applies only to the lifetime of that invocation. 
The following is an example of the case that a constraint is placed inside a behavior invocation: The invocation part inside the scenario is serially composed of two actions. 
Inside of one action, a constraint is declared. 
This constraint does not apply to the second action. 
Code 30. 
A constraint inside a behavior invocation actor car inherits vehicle (vehicle_category == car): scenario car.lose_constraint: do serial(): actor.assign_speed() with: keep(it.speed ). 
This operator has the effect of removing all prior (in textual order) default constraints that influence that parameter. 
After the use of this operator, new constraints on the parameter may be stated with new keep clauses. 
A short-hand notation for implicitly overriding a default constraint can be used: A default constraint can be overridden directly with a keep clause if the following two conditions are met: The overriding keep clause is either an equality or a range constraint. 
The overriding keep clause has the parameter as the only expression on the left side of the Boolean expression. 
Code 31. 
Default Constraints x: int # Declare field x keep (default x == 3) # Create a default constraint on field x x: int = 3 # Equivalent to the previous two lines Code 32. 
Overriding keep (default x==2) keep (x > 100) # Error: This does not override the default constraint, because it is not an equality or range constraint on the field. 
keep (x + 5 == 1) # Error: This does not override the default constraint, because the parameter is not the only expression on the left side of the Boolean expression. 
keep (true => x == 6) # Error: This does not override the default constraint, because it is not an equality or range constraint on the field. 
keep (7 == x) # Error: This does not override the default constraint, the overridden parameter must be on the left side of the equality or range constraint. 
keep (x == 5) # Implicit way of overriding: This must restrict y to the value of 5 instead of 2. 
keep (default y==2 and z==1) # this declares a default constraint that applies to the two parameters y and z remove_default(y) # Explicit way of overriding (step 1): Removes all default constraints that apply to y. 
keep (y > 100) # Explicit way of overriding (step 2): Must restrict y to greater than 100. 
7.3.11.3.3 Full constraint syntax This leads to the following full constraint syntax: Code 33. 
Full constraint syntax keep ([ hard|default ] ) 7.3.11.4 Constraints inside a scenario invocation The following example shows how a scenario can be further constrained within its invocation: Code 34. 
Constrained scenario example actor car inherits vehicle (vehicle_category == car) scenario car.follow: other: car distance: length keep(distance : ... 
modifier [.] [of ]: ... 
 The name of the actor type to which this modifier belongs. 
 A unique name, either in the actor scope (if an actor is specified) or the global scope (if an associated actor is not specified). 
of  This modifier can be applied only to an invocation of the specified scenario or as a member of that scenario. 
The scenario members can be accessed from within the modifier using the special expression it. 
7.3.12.3 Modifier association types Modifier declaration can be separated into the three types of association: Unassociated modifiers Modifiers that are not associated with any specific actor. 
Code 39. 
Unassociated modifier example modifier force_lane(): # define a global modifier that forces a vehicle to be in a specific lane vehicle: vehicle # when this modifier is applied, specify the vehicle lane: int # when this modifier is applied specify the lane the vehicle needs to be in ... 
Actor-associated modifiers Modifiers that need to be applied to a specific actor. 
Code 40. 
Actor-associated modifier example (keep_lane() is defined in the domain model (see Section 8.9.16, "Modifier keep_lane()") modifier vehicle.keep_lane(): # modifier keeps actor in the current lane ... 
Scenario-associated modifiers Modifiers that can be applied as a member of a specific scenario, or inside a with block of an invocation of that scenario. 
Code 41. 
Scenario-associated modifier modifier vehicle.follow_vehicle() of drive: #define a modifier that belongs to a vehicle that follows a specific vehicle only inside a drive target: vehicle # when this modifier is applied, specify the target the vehicle has to follow ... 
# here one can use 'it' to refer to the specific driver() 7.3.12.4 Modifier application 7.3.12.4.1 Modifier application syntax The syntax to apply a modifier is similar to that for scenario invocation: Code 42. 
Modifier application syntax [.]([[,...,][,[,...,]]])  An expression specifying the actor of that modifier (if it exists). 
 The name of the modifier. 
 An expression passed to a parameter field of the modifier in the order of the parameter fields. 
 Expressions can be passed in any order if the parameter field name is specified. 
An expression for a parameter is acting as a constraint on that parameter field: If a single value of the given declared type (or a subtype thereof) is passed in, an equality constraint between the parameter and this value is active during the invocation: do ego.drive() with: speed(speed: 10kph) is semantically equivalent to the following constraint being applied inside the modifier: keep(speed == 10kph) If a range expression is passed in for a parameter with a declared numeric type, an in-range constraint between the parameter and this range is active during the invocation: do ego.drive() with: speed(speed: [10kph..25kph]) is semantically equivalent to the following constraint being applied inside the modifier: keep(speed in [10kph..25kph]) Modifiers can be applied in two places: Modifier application as a member The modifier applies to the whole scenario execution (or to the struct/actor). 
Modifier application within a with block The modifier applies only for that with block. 
A modifier-associated actor can be omitted when it is the same as the scenario actor the modifier is applied in. 
7.3.12.4.2 Modifier application examples Applying an unassociated modifier Code 43. 
Applying an unassociated modifier scenario top.drive_in_lane: my_lane: int with: # the lane that the vehicle should drive in keep(default it == 0) v: vehicle force_lane(vehicle: v, lane: my_lane) # use an unassociated modifier to require the vehicle to be in lane my_lane do serial: v.drive(...) with: force_lane(vehicle: v, lane: my_lane) # use an unassociated modifier to require the vehicle to be in lane my_lane in this drive only Applying an actor-associated modifier Code 44. 
Applying an actor-associated modifier scenario top.drive_in_lane: my_lane: int # the lane that the vehicle should drive in v: vehicle v.keep_lane() # use a modifier to require the vehicle to stay in the current lane do serial: v.drive(...) with: keep_lane() # use a modifier to require the vehicle to stay in the current lane in this drive only Applying a scenario-associated modifier Code 45. 
Applying a scenario-associated modifier scenario top.drive_in_lane: v: vehicle the_other_vehicle: vehicle # the vehicle that v should follow do serial: v.drive(...) with: follow_vehicle(target: the_other_vehicle) # use a modifier to require the vehicle to follow the_other_vehicle in this drive only 7.3.13 Scenario composition A scenario may invoke other behaviors (scenarios or actions) and use scenario composition operators to define their temporal arrangement. 
For example, invoked scenarios may be composed in series or parallel (or otherwise overlapping). 
There is also a composition operator to define alternative behavior. 
Composition operators can be used within a do block of a scenario declaration. 
The behavior of composition operators is formally defined in Section 7.6.2.1, "Composition operators". 
This section only lists the operators and provides a structural description. 
All composition operators have an optional duration parameter that constrains the execution time of the operator. 
When applying composition operators, instead of passing a single value to the duration parameter, a range expression can also be used, which results in the duration parameter being constrained to that range rather than to a single value. 
7.3.13.1 Serial composition The members execute one at a time, in the defined order. 
A member is invoked immediately after its predecessor ends. 
Code 46. 
Syntax for serial composition serial: member_1 member_2 … 7.3.13.2 Parallel composition All of the members execute in parallel or overlap in certain ways. 
Code 47. 
Syntax for parallel composition parallel: member_1 member_2 … The behavior of parallel is controlled by the following optional parameters: Table 4. 
Relational operators over non-numeric expressions Parameter Type Description overlap Enum The following values are defined: equal All members start and end together. 
Constrains start-to-start (STS) to 0 and end-to-end (ETE) to 0. 
start All members start together. 
This is the default. 
STS == 0. 
end All members end together. 
ETE == 0. 
initial First member starts with or after all other members. 
STS ⇐ 0. 
final First member ends with or before all other members. 
ETE >=0. 
inside First member starts before or with all other members and ends after or with all other members. 
STS >=0 and ETE ⇐ 0. 
full First member starts with or after all other members and ends before or with all other members. 
STS ⇐ 0 and ETE >= 0. 
any No constraint on overlap. 
start-to-start Time Determines the offset between the first member’s start time and all other members' start times. 
The time value can be positive, zero, or negative. 
end-to-end Time Determines the offset between the first member’s end time and all other members' end times. 
The time value can be positive, zero, or negative. 
In addition to any other constraints, there must be at least one point in time in which all members of parallel overlap. 
The first member of parallel is called the primary, all other members are secondary. 
Depending on the parameters, parallel composition is usually not commutative: Parallel(a, b, c) is not the same as parallel(b, a, c). 
Parallel can be decomposed as follows: parallel(a, b, c, d) is the same as parallel(parallel(parallel(a, b), c), d). 
7.3.13.3 One-of composition Only one of the members is invoked. 
This composition operator can be used to specify alternative behavior. 
Code 48. 
Syntax for one-of composition one_of: member_1 member_2 … 7.3.14 Global parameters Global parameter declarations are declarations of typed parameters that are accessible globally. 
For example, a global parameter can be accessed within any scenario or actor declaration in the same file, imported files, or importing files. 
This is in contrast to parameter declarations contained within structured type declarations that are only accessible within these structured type declarations (see Section 7.3.6, “Fields”). 
Global parameters are therefore global in both scope and extent. 
Any local fields defined within structured type declarations with the same name as a global parameter will shadow the global declaration within that structured type declaration: In other words, within that structured type declaration any references to the field name will reference the local field, not the global parameter. 
The duration of the binding of the parameter to its value (the extent of the global) is from the beginning of processing of the overall scenario file (including any imports) until the end of processing of the overall scenario file. 
The syntax for global parameter declarations is given in Section 7.2.2.3, "Global parameter declarations". 
An example of defining global parameters for map and environment is given below: Code 49. 
Defining and using global parameters 'map' and 'environment' global map: map global environment: environment scenario foo: my_field: temperature = environment.weather.air.temperature do parallel: bar(newfield: 0.5) scenario bar: newfield: float environment: enviroment keep(newfield <= environment.weather.air.relative_humidity) In this example, the environment reference in scenario foo references the global parameter, whereas the environment reference in scenario bar references the local field of the same name. 
Since global parameter declarations are truly global in scope and extent, they should be used sparingly to avoid clashes when combining scenarios from multiple sources, for example. 
7.2 Language structure and syntax 7.4 Expressions

7.4 Expressions
7.4 Expressions Expressions are used in multiple places within type members, for example within the body of: Constraints Expression method implementations Event definitions Each expression produces a value. 
Because the language is strongly typed, each expression has a type that is known statically (at compile time). 
Expressions are composed of atoms. 
Atoms are identifiers or constant literals. 
Atoms are combined to compound expressions through operators and method application. 
7.4.1 Atomic expressions 7.4.1.1 Identifiers Identifiers that occur in expressions are evaluated to the values of the fields that they identify. 
The type of the reference is the type of the referenced field. 
7.4.1.2 Literals Any literal value of any type is a valid atomic expression if it fulfills the following two conditions: The type of the literal value is as specified in Section 7.3, "Types". 
The literal value uses the syntax that is specified in Section 7.2, "Language structure and syntax". 
If the literal value is a valid atomic expression, the following is true for the expression: The value of the expression is the literal value itself. 
The type of the expression is the type of the literal as defined in Section 7.3, "Types". 
7.4.1.3 Range expressions A range expression can be given for any numerical type using the range constructor syntax. 
The numerical types are comprised of: integer types (int and uint) real number type (float) physical types range-constructor ::= 'range' '(' expression ',' expression ')' | '[' expression '..' expression ']' Range expressions can only be used in the following places: As arguments to modifier applications As arguments to behavior (scenario or action) invocations As arguments to composition operators As the right-hand side operand to the in operator All other uses are currently undefined. 
Consequently, there is currently no defined type for the value of a range expression. 
Code 1. 
Examples for valid range expressions scenario bar: aspeed: speed afloat: float gear: uint keep(afloat in [10..20]) keep(gear in [-1..6]) scenario foo: car: vehicle do parallel(duration: [10s..20s]): car.drive() with: speed([80kph..120kph]) bar(aspeed: [20kph..40kph]) 7.4.1.4. 
it expression it is a reference to the instance of a type in whose scope it occurs. 
In a modifier, it refers to the invoking scenario and gives access to the members of the scenario (see Section 7.3.12.2, "Modifier declaration") or the parameters inside the composition operator of the do-block (see Section 7.3.12.1.2, "Compound modifiers"). 
struct car inherits vehicle(vehicle_category == car): color: color struct truck inherits vehicle(vehicle_category == truck) scenario truck_test: dut_truck: truck with: keep(it.axles.size() > 2) car_in_traffic: car with: keep(it.color == silver) 7.4.2 Compound expressions Compound expressions are formed from other expressions, called sub-expressions, by applying operators or methods to these sub-expressions to form a composition. 
All sub-expressions are evaluated from left to right in the order in which they appear in the compound expression unless specified otherwise. 
7.4.2.1 Method application Expressions may contain calls to methods. 
Methods are declared as type members with a binding that maps each method to its implementation. 
Method applications take the following form: Code 2. 
Method application .method_name(, : ) Method arguments can be passed in the following ways: As positional arguments Positional arguments must be passed before all named arguments. 
Positional arguments are matched against the defined arguments of the method by their position. 
As named arguments Named arguments are passed after all positional arguments, if any. 
Named arguments are matched against the defined arguments of the method by the argument name identifier. 
The argument name identifier is prefixed with a colon (':') before the argument value expression. 
As a combination of both All argument sub-expressions in a method application expression are evaluated before the method implementation is invoked. 
The resultant values are passed as arguments to the method. 
If no value is passed for an argument of the method, the default value of that argument declared in the method declaration will be used. 
It is an error if no value is passed for an argument without a declared default value. 
Method application in expressions can only invoke methods with a declared return type. 
The method application yields the return value of the method as the value of the method application expression. 
The type of the return value is the declared return type of the invoked method. 
Method application can produce side effects. 
Note that unlike invocation of behaviors, modifiers, and composition operators, method application does not support range expressions to be used interchangeably with providing single values. 
7.4.2.2 Logical operators ASAM OpenSCENARIO provides the following logical operators: Table 5. 
Boolean operators Operator Operator name Description Example not Negation True if its operand is false, otherwise false not b and Conjunction True if both operands are true, otherwise false x  0 or Disjunction True if either operand is true, otherwise false x > 5 or x  Implication True if either the first operand is false, or both operands are true, otherwise false b => c All operators are short-circuiting, meaning that sub-expressions are evaluated in left-to-right order until the result of the operator can be determined. 
Any remaining sub-expressions that, based on the rules of Boolean logic, cannot affect the result of the operator are not evaluated. 
The precedence of the operators is the order of the operators in the table of Boolean operators from highest to lowest. 
7.4.2.3 Arithmetic operators ASAM OpenSCENARIO provides the following arithmetic operators: Table 6. 
Arithmetic operators Operator Operator name Description Example - Unary minus Yields the negative of its single operand - x * Multiplication Multiplies the two operands x * y / Division Divides its left-hand operand by its right-hand operand x / y % Modulus Divides its left-hand operand by its right-hand operand and returns the remainder x % y + Addition Adds the two operands x + y - Subtraction Subtracts its right-hand operand from its left-hand operand x - y All binary arithmetic operators have the following requirement: After applying the rules of implicit numeric type conversion, the type of the two operands must be identical. 
Numeric type conversion rules Physical types are not converted. 
If at least one of the operands is of type float, then the other is converted implicitly to type float. 
If both operands are of type uint or both operands are of type int, then no conversion is performed. 
If one operand is int and the other uint then the other is converted to type int. 
The type of the result of the operator is the common type of its arguments. 
For the unary minus operator, the result type of the operator is the type of its operand, or int if the operand is of type uint. 
Calculations involving the type float follow the rules set forth in ANSI/IEEE Std 754-2019. 
Calculations involving the type int follow two’s complement signed arithmetic rules. 
Calculations involving the type uint follow unsigned arithmetic rules. 
Precedence The precedence of the arithmetic operators is as follows: Unary minus has the highest precedence of arithmetic operators. 
Multiplication, division, and modulus have the next highest precedence. 
Addition and subtraction have the lowest precedence of arithmetic operators. 
Operators with the same precedence associate left-to-right. 
7.4.2.4 Relational operators 7.4.2.4.1 Relational operators over numeric expressions The relational operators apply to numeric sub-expressions, including the following types: Integers (int and uint) Real numbers (float) Physical types Table 7. 
Relational operators over numeric expressions Operator Operator type Description Example == Equality Yields true if the two operands are numerically equal. 
x == y != Inequality Yields true if the two operands are not numerically equal. 
x != y  Greater than Yields true if the left-hand operand is strictly greater than the right-hand operand. 
x > y >= Greater or equal Yields true if the left-hand operand is strictly greater than or equal to the right-hand operand. 
x >= y in Membership Yields true if the left-hand operand lies in the range given by the right-hand operand or is a member of the list given by the right-hand operand. 
x in [2.5..5.5] y in [2, 5] All binary relational operators over numeric types have the following requirement: After applying the numeric type conversions, the type of the two sub-expressions must be identical. 
7.4.2.4.2 Relational operators over non-numeric expressions The operators in the following table apply to enumerated types, strings, and Boolean expressions. 
Table 8. 
Relational operators over non-numeric expressions Operator Operator type Description Example == Equality Yields true if the two operands have the same value. 
x == y != Inequality Yields true if the two operands do not have the same value. 
x != y in Membership Yields true if the left-hand operand is a member of the list given by the right-hand operand. 
x in ["Foo", "Bar"] For all binary relational operators over non-numeric types, the type of the two sub-expressions must be identical or one must inherit from the other. 
Two values are considered the same if they are identical. 
For strings, 'identical' means that the strings contain identical content. 
For structured types, 'identical' means that both operands refer to the same object, meaning the operators check for object identity. 
This means that two separate instances of a struct type will not be considered equal, even if every member of one operand is considered equal to the corresponding member of the other operand. 
A member-wise comparison of structured types is currently not part of ASAM OpenSCENARIO. 
If this is needed, it can, for example, be done with an expression method: Code 3. 
Implementing member-wise comparison struct my_date: year: uint month: uint day: uint def same_day_as(other: my_date) -> bool is expression year == other.year and month == other.month and day == other.day scenario my_scenario: x: my_date y: my_date keep(x.same_day_as(y)) 7.4.2.5 Type check operator Use the type check operator to check if an object is of a given type. 
The type check operator yields a Boolean value. 
Operator Operator type Description Example .is() Type check Returns true if the expression is of the specified type, otherwise false. 
"foo".is(string) Type checking does not perform type conversion. 
Conversion can be performed with the type conversion operator (see Section 7.4.2.6, “Type conversion operator”). 
In the following example the operator .is returns true if the object my_car is of type vehicle, otherwise false. 
Code 4. 
Object type checking my_car.is(vehicle) 7.4.2.6 Type conversion operator All type conversions in ASAM OpenSCENARIO are explicit, with the following exceptions: Conversion of int to uint. 
Conversion of int or uint to float. 
Compound types are implicitly upcast to their base classes in contexts where this is required. 
Lists follow the same implicit conversion rules as their element type. 
Downcasting may be needed in the following situations: Accessing one of the latent subtypes that may exist through the conditional inheritance mechanism. 
Iterating through a collection of types. 
Downcasting is possible using the conversion operator as: Operator Operator type Description Example .as() Type conversion Returns the expression, converted to the specified type. 
An error is raised if the conversion cannot be performed (meaning  is not of the specified type). 
vehicle.as(car) For example: Code 5. 
Object downcasting extend vehicle: emergency_vehicle: bool actor emergency_vehicle inherits vehicle(emergency_vehicle: true): sirens_active: bool scenario my_scenario: my_car: vehicle keep(my_car.emergency_vehicle == true) keep(my_car.as(emergency_vehicle).sirens_active == true) 7.4.2.7 List operators The following operators apply to lists. 
7.4.2.7.1 List relational operators Table 9. 
List relational operators Operator Operator type Description Example == List equality Yields true if the first list operand is considered equal to the second list operand, otherwise false. 
[40, 41] == [40, 41] != List inequality Yields true if the first list operand is not considered equal to the second list operand, otherwise false. 
[40, 41] != [40, 42] in Membership Returns true if the first operand is found in the second operand, otherwise false. 
If the first operand is itself a list, then returns true if each member of that list is found in the second operand, otherwise false. 
42 in [40, 41, 42] [42, 43] in [40, 41, 42] Equality for two lists is established if every member of the first list is equal - under the relevant equality operator == of the member type - to the member with the same index in the second list. 
7.4.2.7.2 Other list operators Table 10. 
Other list operators Operator Operator type Description Example .size() Size Returns the size of a list, meaning the number of members, as an unsigned integer. 
[4, 5].size() [  ] Index Returns the indexed list member. 
my_list[2] List members are indexed starting from 0. 
7.4.2.7.3 List member evaluation operators The following operators accept an expression as an argument. 
The variable it is defined in the expression scope, referring to the current list member. 
Table 11. 
Other list operators Operator Operator type Description Example .filter() Filter Returns an ordered sub-list containing the members of the list for which the  returns true. 
my_traffic.filter(it.is(vehicle)) .first_index() First index Returns the index of the first member of the list for which the  returns true. 
If no such item is found, -1 is returned. 
my_traffic.first_index(it.is(vehicle)) .count() Count Returns the number of members of the list for which the  returns true. 
my_traffic.count(it.is(vehicle)) .has() Has Returns true if there are any members of the list for which the  returns true. 
Otherwise returns false. 
my_traffic.has(it.is(vehicle)) .map() Map Returns the result of applying  to all members in . 
The returned list has the same size as . 
Its members are of the type returned by . 
my_traffic.map(it.speed) 7.4.2.7.4 List construction A list can be constructed by specifying list members as expressions, using the following syntax: [ , , ...] If any of the expressions returns a list, the members of that list are added to the result (meaning the returned list is flattened). 
When constructing a list, a common type is determined for the list elements based on the implicit conversion rules. 
All elements are implicitly converted to that type to form the list. 
The following rules are applied to determine the common list type: If all elements are of the same type, this is the common list type. 
If all elements are of type int or uint, the common list type is int. 
If all elements are of type float, int or uint, the common list type is float. 
If all elements are of structured types of the same kind (for example all are structs or all are actors), the inheritance hierarchy is searched for the first base type that all elements have in common. 
If such a type exists, this is the common list type. 
In any other case, an error is raised. 
Code 6. 
Example list construction actor truck inherits vehicle (vehicle_category == truck) actor van inherits vehicle (vehicle_category == car) struct foo: v1: truck v2: van all_traffic_participants: list of traffic_participant = [ v1, v2 ] In this example, v1 and v2 are both derived from the common type vehicle, so this constructs a list of vehicles as a default value for all_traffic_participants. 
This is then implicitly converted to a list of traffic_participant according to the implicit type conversion rules (see Section 7.4.2.6, “Type conversion operator”). 
7.4.2.8 Other operators ASAM OpenSCENARIO also offers the following operators: Table 12. 
Other operators Operator Operator name Description Example ? : Ternary Returns the value of its second operand if its first operand is true, else returns the value of its third operand. 
(x > y) ? (x - y) : (y - x) ( ) Parenthesized expression Returns the value of the expression inside the parentheses. 
(x - y) 7.3 Types 7.5 Coverage

7.5 Coverage
7.5 Coverage 7.5.1 Coverage and reporting overview ASAM OpenSCENARIO coverage and recording features allow users to set goals for a verification and validation undertaking: Which scenarios need to be exercised? For example, cut-in-and-slow scenario. 
How should they be exercised? For example, cut-in-and-slow should be exercised from both left and right sides, and should be performed with all vehicle kinds. 
How many times do values need to be observed to be declared complete? For example, each expressed combination should be tried at least 50 times on-street driving. 
Coverage allows storing the values that are expected to be observed throughout the development and V&V process. 
Reporting uses similar syntax with the goal to store data for later analysis or KPI analysis. 
Coverage and reporting definitions can be reused over multiple ODDs and projects as they can be overridden non-intrusively. 
7.5.2 Cover The cover directive defines a coverage data collection point. 
It can be placed as a member into structs, actors, or scenarios. 
Code 1. 
Syntax of cover directive cover([name: ]  [, expression: ] [, * ]) The mandatory name argument provides the user-supplied identifier for the cover directive. 
This identifier also serves as the expression to monitor, if the optional expression argument is not provided. 
The expression argument provides the expression to monitor. 
The expression must be of a scalar type and must be valid to evaluate in the local context of the cover directive. 
The value of the cover item is the value of the expression when the cover group event occurs. 
If the expression argument is not provided, the expression is derived from the name. 
Additional common arguments can be provided, as described in Section 7.5.5, “Common cover and record arguments”. 
Coverage is a mechanism for sampling key parameters related to scenario execution. 
Analyzing aggregate coverage helps determine how safely the AV behaved and what level of confidence you can assign to the results. 
For example, to determine the conditions under which a cut_in_and_slow_down scenario failed or succeeded, you might need to measure: The speed of the device under test car The relative speed of the passing car The distance between the two cars You can specify when to sample these items. 
For example, the key events for this scenario are the start and end events of the change_lane phase. 
Cover items that have the same sampling event are aggregated into a single metric group, along with record data sampled by the same event. 
The default event for collection coverage is end. 
If the range of data that you want to collect is large, you might want to slice that range into sub-ranges or buckets. 
For example, if you expect the device under test car to travel at a speed between 10 kph and 130 kph, specifying a bucket size of 10 gives you 12 buckets, with 10 kph – 19 kph as the first bucket. 
You can also specify an explanatory line of text to display about the cover item during coverage analysis. 
This example defines: A name A unit of measurement A line of display text A range for the field speed A range slice for the field speed Code 2. 
Using cover() cover(speed1, unit: kph, text: "Absolute speed of ego at change_lane start (in km/h)", range: [10..130], every: 10) You can declare a field and define coverage for it at the same time. 
The following examples are equivalent. 
Code 3. 
Two possibilities to define a field and coverage with the same result # Example 1 current_speed: speed with: cover(current_speed, unit: kph) # Example 2 current_speed: speed cover(current_speed, unit: kph) The following example extends the dut.cut_in_and_slow scenario to add a do-not-generate field called rel_d_slow_end. 
This variable is assigned the value that is returned by the ego.space_gap() method at the end event of the slow-phase of the scenario. 
A coverage for that field, including a unit, display text, and so on is also defined. 
extend cut_in_and_slow: var rel_d_slow_end: distance = sample(ego.space_gap(car1), @slow.end) cover(rel_d_slow_end, text: "car1 position relative to ego at slow end (in centimeter)", unit: cm, range: [0..6000], every: 50, ignore: (rel_d_slow_end  6000cm)) 7.5.3 Record The record directive defines a performance metric or other data collection point. 
It can be placed as a member into structs, actors, or scenarios. 
Code 4. 
Syntax of record directive record([name: ]  [, expression: ] [, * ]) The mandatory name argument provides the user-supplied identifier for the record directive. 
This identifier will also serve as the expression to monitor if the optional expression argument is not provided. 
The expression argument provides the expression to monitor. 
The expression must be of a scalar type and must be valid to evaluate in the local context of the record directive. 
The value of the record item is the value of the expression when the record group event occurs. 
If the expression argument is not provided, the expression is derived from the name. 
Additional common arguments can be provided, as described in Section 7.5.5, “Common cover and record arguments”. 
The record directive is used to capture performance indicators and other data items that are not part of the coverage model, such as the name and version strings identifying the device under test. 
The purpose of performance evaluation is to see how well the device under test performed in specific conditions as they occur within a scenario. 
Performance can be evaluated along multiple dimensions, like safety, ride comfort, and so on. 
Performance metrics can also be used to provide pass or fail indication: Sampled values that cross a specified threshold indicate, that the device-under-test-performance was outside the acceptable range. 
Often, raw performance values need to be interpreted in the context of a specific scenario: For example, it may be acceptable to cross the max-deceleration threshold if emergency braking is required. 
For this purpose, raw performance values can be converted to performance grades. 
A performance grade (also called a normalized KPI) is a context-dependent number between 0 ("really bad") and 1 ("excellent"). 
This grade is attributed to some aspect of the device-under-test-behavior. 
This grade can be computed using a user-defined grading formula, converting one or more raw values into a grade in a context-dependent way. 
The following example shows how record() is used to capture time-to-collision into the metric group associated with the end of a change-lane maneuver. 
Code 5. 
Using record() for capturing extend cut_in_and_slow: # Sample the time-to-collision KPI at the end of change_lane var ttc_at_end_of_change_lane: duration = sample(ego.time_to_collision(car1), @change_lane.end) # Record the KPIs into the cut_in_and_slow.end metric group record(ttc_at_end_of_change_lane, unit: s, text: "Time to collision of ego car to cut-in car at end of the change_lane phase") 7.5.4 Cross coverage or record The coverage or record metrics of two or more previously defined items can be combined. 
This is done by specifying the items as a list in a new cover or record directive. 
This creates a Cartesian product of the specified metrics, showing every combination of values of the items. 
Only items that belong to the same metrics group (same sample event) can be combined in this way. 
The following example creates a cross-record: A Cartesian product of the time-to-collision record item and the DUT velocity cover item, both sampled at the start of the change_lane phase. 
This is considered a cross-record because it includes at least one record item. 
record(ttc_dut_vel, items: [ttc_at_end_of_change_lane, dut_v_cls], event: start, text: "Cross record of TTC and absolute DUT velocity") The next example creates a Cartesian product of three cover vectors at the start of the change_lane phase of a scenario: The relative distance between two cars The absolute velocity of the DUT vehicle The relative speed of the other vehicle cover(cross_dist_vel, items: [rel_d_cls, dut_v_cls,rel_v_cls], event: change_lane_start, text: "Cross coverage of relative distance and absolute velocity") 7.5.5 Common cover and record arguments The cover and record directives accept the following common arguments, which are optional and can be used as named arguments: unit:  Specifies a unit for a physical quantity, such as time, distance, or speed. 
The value of the field is converted into the specified unit. 
That value is used as the coverage value. 
A unit must be specified for items that have a physical type. 
range:  Specifies a range of values for the physical quantity in the unit specified with unit. 
It is an error if this argument is used in combination with the buckets argument. 
every:  Specifies when to slice the range into sub-ranges. 
If a given value range is large, for example [0..200], this argument can be used to slice that range into sub-ranges every 10 or 20 units. 
It is an error if this argument is used in combination with the buckets argument. 
event:  Specifies the event when the field is sampled. 
The default is the end event of the enclosing scenario. 
Items that have the same sampling event are aggregated into a metric group. 
Note that both coverage and performance items can be collected in the same metric group. 
You can sample a field value on one event and cover it on another. 
This way you can, for example, capture the speed of a car when changing lanes, but associate the cover item with the scenario end metric group. 
The cover event must be local (an event defined in the enclosing struct, actor, or scenario). 
No dotted path expressions are allowed. 
If necessary, you can define a local event to be derived from some path expression and use that for coverage. 
For example, event change_lane_start is @change_lane.start. 
text:  Provides an explanatory string describing this metric point. 
items:  Declares a list of identifiers, whose metrics are combined and displayed as a single cross item. 
The identifiers must be separated by commas and enclosed in square brackets. 
The list can include a mix of cover and record identifiers. 
If a record identifier is included, the resulting item is a cross-record item. 
ignore:  Defines values that are to be completely ignored. 
The expression is a Boolean expression that can contain only the item name and constants. 
If the ignore expression is true when the data is sampled, the sampled value is ignored (meaning not added to the bucket count). 
disable:  Must be either the literal true or false. 
The value true completely disables a metric item. 
This argument is used with override (see Section 7.5.6, “Override”), to disable an existing metric item. 
(Default value: false). 
buckets:  Provides a way to declare different-sized buckets, by specifying bucket boundaries. 
A list of N values defines N-1 buckets. 
Each value must be greater or equal to the previous one. 
For example, cover(speed, unit: kph, buckets: [1, 2, 6.5, 10]) creates the following buckets: 1..2, 2..6.5, 6.5..10. 
It is an error if this argument is used in combination with either range or every arguments. 
target: uint Describes how many times a bucket needs to be sampled to be declared as accomplished. 
For example, you may express that you need 5 cut-ins from the left and 5 cut-ins from the right. 
This requires the target to be set to 5. 
Target is only valid for cover directives and has no meaning for record directives. 
illegal:  Identifies conditions in which the provided values indicate a malfunction in the ego or the behavior of the ego. 
The expression is a Boolean expression that can contain only the item name and constants. 
Note that error values are automatically ignored. 
7.5.6 Override The override option is used to override a parameter in an already defined cover() or record() member. 
Coverage extensions and refinements are key aspects for content and library reuse. 
The developers of libraries are most familiar with the reusable scenario implementation and overall goals. 
They can associate coverage goals with reusable code. 
Later on, project-specific users may accept the provided definition or refine the code to reflect their ODD goals. 
To maintain reuse, the user refinements should not be intrusive and should not involve modifying the pre-provided reusable code. 
Code 6. 
Syntax of cover and record overrides cover | record(override:  [, * ]) The override feature works as follows:  must be the name of an existing cover or record item in the event metric group. 
Any other specified parameter in the  list overrides the corresponding original parameter. 
Parameters not provided in the override retain their original values. 
Parameters originally not contained are added. 
Multiple overrides are allowed. 
The last value provided for each parameter prevails. 
This automatically percolates to any cross-metric using this item. 
Code 7. 
Overriding an original definition # Original definition cover(speed_diff, units: kph, range: [1..20], every: 5) # New definition overrides the every: 5 and adds ignore cover(override: speed_diff, every: 4, ignore: speed_diff in [10kph..13kph]) The following restrictions apply to the use of the override mechanism: The name of the item cannot be changed. 
The expression, event, and unit as originally defined cannot be overridden. 
Override can only be used in the same type where the cover or record modifier was originally defined. 
It cannot be used to override a cover or record modifier in a subtype. 
7.5.7 Coverage grading Coverage provides a clear grade of how much functionality was exercised and observed from the user-defined goal. 
Each type has its own default number of coverage buckets: Boolean Two buckets. 
Enumerate The number of possible values constitutes a bucket. 
Numeric up to a byte A bucket per possible value. 
For example, a byte has 256 buckets. 
Numeric large size type A default grade of min, max, and three middle buckets, middle buckets of low, medium, and high. 
Users can override the default buckets using range or ignore. 
The calculated grade represents the number of buckets that had their values observed in the scenario divided by the total number of buckets for the type. 
An example with enumerated types: If 5 values exist, and only 3 of these were observed, then the coverage score would be 60 % done. 
Note that coverage grade calculation is not part of the current specification. 
7.4 Expressions 7.6 Semantics

7.6 Semantics
7.6 Semantics This chapter describes the behavioral semantics of scenarios, scenario modifiers, and actions of ASAM OpenSCENARIO. 
ASAM OpenSCENARIO is a declarative and constraint-based language where a scenario model may not only define one concrete behavior, but a whole family of behaviors, with different possible values for parameters such as vehicle speeds, scenario durations, or environmental conditions. 
Therefore, the semantics definition of ASAM OpenSCENARIO is also of a declarative nature and based on the notion of trace acceptance as explained in Section 7.6.1, “Semantic foundations”. 
This standard does not provide any operational semantics, which means that it does not define how to choose the next step in the execution of an ASAM OpenSCENARIO model based on a given trace prefix. 
Any operational semantics is valid as long as, given an ASAM OpenSCENARIO model, it produces traces that are accepted by that model according to the declarative semantics. 
One reason for this standard not to provide any operational semantics is that different use cases may require different operational semantics. 
In some cases, it may be sufficient to produce only one particular trace of the possible traces described by a given ASAM OpenSCENARIO model. 
In other cases, it may be desired to produce a representative variety of the possible traces or to choose traces in a way that quickly reaches some coverage goal. 
This section is structured as follows: The semantic foundations contain some preliminary definitions (see Section 7.6.1, “Semantic foundations”). 
The following sections cover the semantics aspects of language concepts related to scenarios and actions (see Section 7.6.2, “Scenarios” and Section 7.6.3, “Actions”). 
7.6.1 Semantic foundations A trace is a timed behavior occurring in a traffic system, or a model thereof, such as a simulation. 
An ASAM OpenSCENARIO 2.0 model (or scenario model in short) consists of a tree of composed scenarios and actions that specify a set of traces that it accepts. 
All other traces are rejected. 
Figure 4. 
An illustration of a set of traces accepted by an ASAM OpenSCENARIO model Figure 4 shows a set of traces accepted by an ASAM OpenSCENARIO model as a tube. 
The traces are single threads. 
The traces are accepted if they are enclosed in the tube. 
Traces not enclosed in the tube are rejected. 
Trace acceptance is not related to passing or failing tests. 
If an ASAM OpenSCENARIO model does not accept a trace, it means that the behavior is outside the scope of the ASAM OpenSCENARIO model. 
Test criteria can only be evaluated for accepted traces, meaning, if the behaviors are within the scope of the ASAM OpenSCENARIO model. 
An ASAM OpenSCENARIO model is inconsistent if the set of traces that it accepts is empty. 
This can happen because of contradictions in constraints. 
For example, requiring a car to drive faster than 50 km/h and slower than 50 km/h at the same time. 
In a test setting, it can also happen that a vehicle under test causes a trace to be rejected. 
That is, because the vehicle under test is uncontrollable from the perspective of the test system, it may force the traffic system into a state that violates constraints of the ASAM OpenSCENARIO model. 
Moreover, the satisfiability of an ASAM OpenSCENARIO model also depends on particular driver models and physics models that are combined with the ASAM OpenSCENARIO model and influence how the traffic system objects behave. 
The following chapters contain more precise definitions of some key concepts. 
7.6.1.1 Actor system An ASAM OpenSCENARIO model defines a possible system of actor objects, which can be vehicles, other moving objects, or also static or virtual objects. 
This set of actor objects is called the actor system or traffic system. 
Each actor object has a set of fields as defined by its type definition. 
A field has a type that specifies a domain of possible values. 
Domains can be discrete (such as int or enum values) or continuous (real-valued, such as speed or acceleration). 
Domains can also be compound types (see Section 7.3.5, "Compound types"), such as structs or actor types. 
7.6.1.2 State The state of an actor system is an actor system with a valuation of the actor objects' fields. 
A valuation is a mapping for each field to a value from the domain defined by the field’s type. 
is the valuation of the field of the actor object at time . 
7.6.1.3 Trace A trace is a continuous-time sequence of actor system states. 
identifies the actor system state at time , where is a real number, meaning that is a function where is the set of states. 
Traces can have arbitrary lengths but are always finite. 
All states in a trace share the same actor system and only the valuations of their fields change over time. 
Notation: is the subtrace of a trace from the closed interval starting at time and ending at time , that is, including the states at and . 
7.6.1.4 Behavior invocation tree An ASAM OpenSCENARIO model has one main scenario that can invoke one or more other behaviors (a behavior being either a scenario or an action). 
Each invoked scenario has a scenario type that defines how, again, that scenario invokes other behaviors. 
Actions are atomic behaviors, meaning that they are not composed of other behaviors (from the perspective of an ASAM OpenSCENARIO model). 
The scenario invocation relationships give rise to a behavior invocation tree that is defined by the ASAM OpenSCENARIO model, where the root is the main scenario, the leaves are action invocations, and intermediate nodes are scenario invocations. 
7.6.1.5 Behaviors versus behavior invocations The concepts scenario and scenario invocation relate as follows: A scenario (also scenario type or scenario declaration) describes a set of possible behaviors (traces) involving some set of actor objects in some actor systems. 
A scenario invocation happens when a scenario refers to another scenario as part of its behavior definition. 
When invoking a scenario, the invoking (parent) scenario may specify additional constraints, especially for which actor objects the invoked (child) scenario must apply, by constraining how fields of the invoked scenario may bind to actor objects in an actor system. 
Moreover, the invoking scenario may specify at what time and for which duration the invoked scenario shall apply. 
For example, a scenario defining a certain choreography of vehicle movements may invoke an overtaking scenario and specify which vehicle shall overtake which other vehicle, possibly also constraining the time and duration of this maneuver, the speeds of the vehicles, and so on. 
Therefore, semantically, a scenario invocation describes a subset of the possible behaviors described by its scenario type; especially a scenario invocation refines when these behaviors shall occur. 
Figure 5. 
An illustration of how the set of traces accepted by a scenario is a subset of the composition of the traces accepted by the scenario invocations, which themselves are subsets of the traces accepted by their type scenario. 
Figure 5 shows how the set of traces accepted by a scenario is a subset of the composition of the traces accepted by the scenario invocations and . 
The traces accepted by the scenario invocations and are themselves subsets of the traces accepted by their type scenarios and , reduced by constraints specified in the invoking scenario . 
The terminology of scenario and scenario invocation also maps to actions: actions and action invocations are distinguished in the same way as scenarios and scenario invocations, except that actions cannot invoke any other scenarios or actions, because actions are atomic. 
As scenarios and actions are behaviors, we also call scenario invocations and action invocations more generally behavior invocations. 
7.6.1.6 Accepting a trace An ASAM OpenSCENARIO model only accepts a trace if its main scenario also accepts the trace. 
A trace is an element of the possible behaviors described by its main scenario. 
This depends on, for example, whether the time and value constraints formulated by the scenario are satisfied by the trace and whether, recursively, all behavior invocations accept subtraces of the given trace. 
The next sections contain a more detailed definition of the different conditions for when a scenario accepts a given trace. 
7.6.2 Scenarios A scenario describes the behavior of one or several actors in a traffic system. 
This chapter is divided into the following parts: Composition operators Scenario fields and bindings Scenario constraints Time constraints Events Each section adds necessary conditions for trace acceptance. 
For more information about scenarios in the context of ASAM OpenSCENARIO, refer to the Scenario definition. 
7.6.2.1 Composition operators A scenario invokes one or more behaviors (scenarios or actions) or directives using three composition operators. 
serial: The serial (sequential) composition of scenarios parallel: The parallel composition of scenarios one_of: The one-of composition of scenarios (at least one of a set of scenarios must hold) In addition, a scenario can invoke a single scenario, action, or directive directly in the do section. 
In the following subsections, the semantics of these three composition operators are defined. 
The subsections also contain the semantics of the direct invocation. 
The semantics is expressed in terms of conditions for trace acceptance. 
For compositionality reasons, a definition of when a scenario accepts the following elements is required: A given trace A trace over a right-open time interval between the following times: A start time An end time For formal definitions, the left-pointing triangle symbol is introduced. 
This triangle symbol indicates that a scenario invokes another scenario or a composition of other scenarios. 
For example, means that scenario specifies a direct invocation of the behavior (type) ; means that scenario specifies a serial composition of the behavior invocations and . 
In the following subsections, trace acceptance is defined for behaviors that are non-zero time. 
That means that zero-time behaviors, for example, emit directives (that emit events), are excluded from the trace acceptance conditions defined in the following subsections. 
However, the zero-time directives influence trace acceptance in other ways, and this is defined in their particular subsection in this chapter, see for example Section 7.6.2.5.2, “Emit (event)”. 
7.6.2.1.1 Direct invocation A scenario can invoke a single scenario or action directly in the do section. 
The invocation can express specific required values or ranges of values for any of the scenario parameters. 
Details are shown in Code 1: Code 1. 
Simple behavior invocation scenario vehicle.accelerate: target_speed: speed do drive(duration: [2s..4s]) with: speed(speed: target_speed, at: end) Here, the action drive() of the parent actor of this scenario is invoked with a speed modifier. 
The parameter duration of the drive scenario is required to be between 2 and 4 seconds. 
The speed modifier specifies a target speed to be reached at the end of the execution of the drive action invocation (which also is the end of this scenario). 
A scenario ( specifies a direct scenario invocation ) accepts a trace only if accepts . 
7.6.2.1.2 Serial composition A scenario can invoke a series of two or more behaviors. 
Code 2 shows a scenario that specifies two driving phases of a vehicle: The first phase (phase1) starts with the vehicle at a standstill (speed = 0 kph) and ends with the vehicle’s speed at 10 kph. 
The second phase (phase2) starts, where the vehicle is driving with a speed between 10 and 15 kph. 
The duration of this series of behavior invocations must be between 10 and 30 seconds. 
Code 2. 
Use of the serial operator scenario vehicle.two_phases: do serial (duration: [10s..30s]): phase1: drive() with: speed(speed: 0kph, at: start) speed(speed: 10kph, at: end) phase2: drive() with: speed(speed: [10kph..15kph]) Code 2 contains no constraints on the duration of the two invoked behaviors. 
This means, that this scenario accepts any trace as long as the trace fulfills the following conditions: The trace must be between 10 and 30 seconds long. 
The trace must describe the behavior of a vehicle. 
The vehicle starts at a standstill (phase1). 
At some point the vehicle reaches 10 kph. 
Then the vehicle continues driving at a speed between 10 and 15 kph (phase2). 
Note that during the first phase, the acceleration does not need to be monotonic. 
The acceleration may even include values higher than 10 kph and lower than 0 kph, as long as a speed of 10 kph is reached at least once, so that phase1 and phase2 can happen within 10 to 30 seconds. 
More formally, a scenario that specifies a serial composition of behavior invocations accepts a trace only if it is possible to partition the trace into segments such that the th scenario invocation accepts the th segment. 
If a serial composition also specifies an optional minimum and maximum time duration, the trace duration must be within the specified range. 
For a more concise formal definition, an alternative notation of the minimum and maximum duration parameters is introduced: : Minimum duration (default is ) : Maximum duration (default is ) A scenario accepts a trace only if and there exist times with such that behavior invocation accepts for all . 
For Code 2 this means that a trace is accepted by this example scenario only if can be divided into two subtraces (one for each of the invocations phase1 and phase2) such that phase1 accepts : at time the speed of the actor is 0 kph and at the time the speed is 10 kph (in between it may have any speed, even grater than 10 kph or less than 0 kph). 
phase2 accepts : the speed of the actor does not exceed the boundaries of 10 and 15 kph during . 
The difference between and is greater or equal to 10 seconds or less than or equal to 30 seconds. 
7.6.2.1.3 One-of composition The one-of composition operator models the alternative occurrence of one scenario from a set of two or more scenarios. 
In the following example it is specified for a vehicle to either stay on lane 0 and decrease speed from 100 kph to 0 kph or to change lane from 0 to 1 and keep the speed within 60 to 100 kph. 
This way a vehicle either brakes on lane 0, for example, because of an obstacle, or changes the lane to avoid the obstacle and keeps on driving. 
The duration constraint expresses that either scenario must happen within 10 to 30 seconds. 
Code 3. 
Use of the one-of operator scenario vehicle.one_of: do one_of(duration : [10s..30s]): phase_a: drive() with: speed(speed: 100kph, at: start) speed(speed: 0kph, at: end) lane(0) phase_b: drive() with: speed(speed: [60kph..100kph]) lane(0, at: start) lane(1, at: end) More formally, a scenario accepts a trace only if and at least one behavior invocation , accepts . 
7.6.2.1.4 Parallel composition The parallel composition operator models the parallel or otherwise overlapping occurrence of two or more scenarios. 
The operator takes a list of two or more behavior invocations. 
The first one is called the primary behavior invocation and the others are called secondary behavior invocations. 
The operator furthermore accepts four parameters: overlap: Specifies an overlap kind, which can be equal, start, end, initial, final, inside, full, and any. 
Default is start. 
start-to-start: Specifies the allowed offset between the start of the primary behavior invocation and the starts of the secondary behavior invocations. 
This parameter is optional. 
end-to-end: Specifies the allowed offset between the end of the primary behavior invocation and the ends of the secondary behavior invocations. 
This parameter is optional. 
duration: Specifies the overall duration of the parallel behavior invocations, from the first start of an invoked behavior until the last end of an invoked behavior. 
This parameter is optional. 
The following listing shows an example of the parallel operator. 
Code 4. 
Use of the parallel operator scenario parallel_phases: v1, v2: vehicle do parallel(): phaseA: v1.drive() with: speed(speed: 0kph, at: start) speed(speed: 10kph, at: end) phaseB: v2.drive() with: speed(speed: [10kph..15kph]) position(distance: [5m..100m], behind: v1, at: start) Here, phaseA specifies that actor v1 accelerates from 0 kph to 10 kph. 
In parallel, phaseB specifies that another actor v2 is driving with a speed between 10 and 15 kph. 
At the start of the scenario, v2 should be 5 to 100 meters behind v1. 
parallel() is used here without any parameters. 
This means that the overlap kind defaults to start and both phases must start at the same time but may end at different times. 
More details on the available parameters can be found in the next subsection. 
Overlap parameter semantics If a scenario invokes a number of behaviors using the parallel operator with parallel(equal), it means that all invoked behaviors start and end at the same time, meaning a true parallel occurrence of the invoked behaviors. 
The other overlap kinds are less strict. 
The overlap kind start, which is the default if no other overlap kind is specified, requires that all invoked behaviors start at the same time, but can end at different times. 
The converse holds for the overlap kind end: The end times must be equal, but start times can be different. 
The overlap kinds initial and final require that the secondary behavior invocations cover the start, or the end, of the primary behavior invocation. 
Figure 6. 
Different behavior invocation overlappings allowed by overlap kinds equal, start, end, initial, and final Figure 6 illustrates which parallel or overlapping occurrences of the primary behavior invocation and the secondary behavior invocations are allowed with the overlap kinds equal, start, end, initial, and final. 
The overlap kind inside requires that the secondary behavior invocations are fully overlapped by the primary behavior invocation. 
full, by contrast, requires that all secondary behavior invocations are fully overlapped by the primary behavior invocation. 
The overlap kind any places no requirement on the overlapping of the invoked scenarios except that there must exist at least one point in time where all scenarios overlap. 
Figure 7. 
Different behavior invocation overlappings allowed by overlap kinds inside, full, and any Figure 7 illustrates the overlappings allowed by inside, full, and any. 
Values for offset and duration parameters The start-to-start and end-to-end parameters specify what time offsets are allowed from the start time of the primary behavior invocation to the start time of each secondary behavior invocation. 
The values for these parameters can be a range of times (like start-to-start: [-5s..3s]) or a single positive or negative time value (like start-to-start: -5s). 
A positive offset means that the secondary behavior invocations start after the primary behavior invocations and negative offsets mean that the secondary behavior invocations start before the primary behavior invocation. 
Figure 8. 
An illustration of minimum and maximum start-to-start offsets Figure 8 illustrates different cases of start-to-start values. 
The end-to-end constraint works in the same way for end times. 
More formally, the semantics of the parallel operator is as follows. 
For a more concise formal definition, an alternative notation of the parameters is introduced: : Minimum duration (default is ) : Maximum duration (default is ) : Minimum difference between the start of the primary behavior invocation and the start of each secondary behavior invocation (default is ) : Maximum time difference between the start of the primary behavior invocation and the start of each secondary behavior invocation (default is ) : Minimum time difference between the end of the primary behavior invocation and the end of each secondary behavior invocation (default is ) : Maximum time difference between the end of the primary behavior invocation and the end of each secondary behavior invocation (default is ) : Overlap kind A scenario accepts a trace only if for all there exist times and such that , meaning the duration of is between and . 
, meaning the time stamps and mark time intervals between and . 
accepts , meaning each parallel behavior invocation accepts a subtrace of where and mark the beginnings, respectively, the ends of the subtrace. 
it holds that all start and end times of the secondary behavior invocations respect the start-to-start and end-to-end offsets relative to the primary scenario: There exists a time such that and , meaning there exists a point in time where all parallel behavior invocations overlap. 
There exists a with , meaning one of the parallel behavior invocations accepts a subtrace of starting at time . 
Or, in other words, there is no time at the beginning of the trace that is not covered by any of the parallel behavior invocations. 
There exists a with , meaning one of the parallel scenarios accepts a subtrace of ending at time . 
Or, in other words, there is no time at the end of the trace that is not covered by any of the parallel behavior invocations. 
If then it holds that and . 
This is equivalent to saying that is accepted by ( ), meaning the trace satisfies all parallel behavior invocations. 
If then . 
That is, all behavior invocations accept some subtrace of starting at . 
If then . 
That is, all behavior invocations accept some subtrace of ending at . 
If then it holds that and . 
If then it holds that and . 
If then it holds that . 
If then it holds that . 
7.6.2.2 Scenario fields and bindings To decide whether a scenario accepts a trace, the following relation is needed: The scenario and its fields have to be related to objects in the states of the given trace. 
For a scenario to accept a trace, there must exist bindings of object-typed fields of the scenario to objects in the states of the trace. 
This section defines the concept and necessary conditions for scenario field bindings in more detail. 
A system state of a trace at time consists of a set of actor objects. 
An ASAM OpenSCENARIO model defines actor types for these objects that appear in the system states. 
In addition, an ASAM OpenSCENARIO model defines types like scenarios or scenario modifiers that do not represent actor objects, but are concepts within the ASAM OpenSCENARIO model to describe the behavior of actor objects. 
These types are called scenario model types. 
Scenarios have fields that can be typed by actor object types and scenario model types. 
Moreover, scenario fields can be parameters or variables. 
In order for a scenario to accept a trace, there must exist bindings from scenario parameters typed by actor object types to corresponding system objects that remain unchanged during the lifetime of a scenario. 
More formally, a scenario with actor object type parameters accepts a trace only if there exists a binding of actor object type parameters , which is a function that is total, non-injective, non-surjective, from the actor type scenario parameters to actor objects that are shared by all system states where . 
That is, the binding does not change over time and also actor objects do not disappear over time . 
In a composite scenario (see Section 7.6.2.1, “Composition operators”), the invoking scenario can specify constraints, specific values, or ranges of specific values for the parameters of the invoked scenarios. 
In addition to the conditions given in composition operators, an invoked scenario accepts a (sub-)trace only if there exists an instance of the invoked scenario that respects the constraints imposed by the invoking (parent) scenario for that trace. 
Figure 9. 
An illustration of an ASAM OpenSCENARIO scenario execution state showing scenario instances and field bindings. 
Figure 9 shows the concept of scenario instances and parameter bindings. 
The parameter bindings of a scenario to actor objects and values of a trace that it accepts is called a scenario instance of that scenario. 
The behavior invocation relationships (compare Section 7.6.1.4, “Behavior invocation tree”) at a certain time of a given trace can imply a tree of scenario instances. 
These scenario instances comprise a scenario state (middle of the figure) that corresponds to a system state (bottom of the figure). 
The top of the figure shows parts of an ASAM OpenSCENARIO model that describes an overtaking scenario involving two cars. 
Indeed, two cars exist in the system state shown at the bottom. 
The extension of the main scenario specifies two parameters of the actor type Car and invokes the scenario Car.overtake with these cars: Car c1 is specified as the overtaking car and the main actor of the Car.overtake scenario and car c2 is specified as the overtaken car. 
This leads to a configuration of scenario instances with bindings from actor type parameters to actor objects: First, there is an instance of the main scenario top.main, where the parameters c1 and c2 bind to carA and carB. 
The main scenario constrains the invocation Car.overtake in a way that the implicit main parameter it must be equal to the value bound to top.main.c1, namely carA, and the parameter overtaken_car must be equal to the value bound to top.main.c2, namely carB. 
The invocation of Car.overtake by the extension of top.main does not constrain the value of the overtaken_lane parameter. 
Thus, an arbitrary binding for this parameter to a lane instance can be chosen. 
The scenario car.overtake probably has an additional constraint to ensure a meaningful binding for the parameter. 
But this constraint is not shown in the figure. 
The invocation of Car.overtake by the extension of top.main causes the parameter overtake1 to be bound to the instance of the scenario Car.overtake here labeled ot1:Car.overtake. 
7.6.2.3 Scenario constraints The structure and functionality of constraints are already described in Section 7.3.11, "Constraints". 
In those sections also time aspects and strengths of constraints are specified. 
This chapter defines how constraints influence trace acceptance within the declarative semantic of ASAM OpenSCENARIO. 
The core part of constraints are Boolean expressions which state limitations for the values of parameter fields inside instances of structured types (struct, scenario, actor, or modifier). 
By default, those limitations are applied as long as the instance in which they are declared exists. 
(A scenario can exist for a certain time, see also scenario instance in Section 7.6.2.2, “Scenario fields and bindings”). 
During the lifetime of an instance of a structured type, all constrained parameter fields must be bound to values satisfying the constraints at each point in time. 
Furthermore, there are special constraints that can be specified to hold at certain points in time, using the keyword at. 
If a (parent) scenario (type) defines a scenario invocation (of type ), there are three different kinds of constraints to consider: The constraints specified by the type of the invoked scenario , denoted as The constraints specified by the parent scenario in the scenario invocation using modifiers, denoted as Other constraints specified by the parent scenario , denoted as If a (parent) scenario invokes another scenario , all three sets of constraints , , and must hold for the lifetime of , which is the time that the invocation is active. 
Figure 5 compares the three sets of constraints. 
A scenario invocation accepts a trace only if it satisfies the constraints and , this means that there exists a binding for scenario fields to values and actor objects in the actor system, such that these constraints are satisfied. 
In addition, the trace is only accepted if all constraints of all objects in the traffic system are satisfied in all states of the trace. 
A trace can be rejected in the following cases: Contradictions between constraints: There can be contradicting constraints for example if keep(speed>10kph) and keep(speed<10kph) are defined within the same vehicle actor. 
Such constraints can also conflict if they are placed on the same actor instance from within different scenarios that can be active in parallel. 
Such cases may be less obvious. 
Moreover, there can be a complex interplay between constraints. 
For example, imagine a vehicle is constrained to a certain minimum distance to a preceding vehicle, while the preceding vehicle has some constraints forcing it to accelerate. 
Then the following vehicle may be forced to violate constraints on the maximum speed. 
Impossible constraints because of other behavior restrictions: For example, there can be constraint conflicts between scenario constraints and constraints implied by atomic actions that are invoked directly or indirectly from that scenario. 
Trace acceptance conditions defined for atomic actions may contradict constraints in scenarios invoking these actions. 
Refer to the definition of the semantics of action, for example, Section 8.8, "Movement actions".) There can also be conflicts with specific behavior models, such as driver models. 
7.6.2.4 Time constraints Time constraints may occur in the context of the following language constructs: Composition Operators When composing different behaviors by using composition operators like serial or parallel the duration of the composed behaviors can be restricted by using the "duration" parameter. 
For semantic details, refer to Section 7.6.2.1, “Composition operators”. 
Action Invocations When invoking actions from the domain model specification (like drive or changeLane) the duration of that action may be restricted by using the parameter "duration". 
Wait directives The wait directive may be used to introduce phases with a certain time duration into a scenario where it is not further constrained what happens during that duration. 
Note that this directive may also be invoked using the specification of an event to wait for. 
The semantics of that directive is described in Section 7.6.2.5, “Events”. 
7.6.2.4.1 Action invocation using duration parameter The duration parameter may be constrained when invoking an action. 
It adds a restriction to the set of accepted traces regarding the time duration of the respective action. 
Formally, is accepted by the action )] if , and This is an example where the action drive is constrained via the duration parameter to take between 30 and 60 seconds. 
+ ... 
do: car1.drive(duration: [30s..60s]) 7.6.2.4.2 Wait directive The wait directive when used with an elapsed() expression adds a phase of the given duration to the scenario and it is not further specified what is allowed or intended to happen during this time. 
Hence, formally in this 'intended specification gap' anything is allowed to happen. 
It only needs to be assured that the (sub-)trace corresponds to the specified waiting time, meaning that the (sub-)trace has the correct length. 
Formally, is accepted by the wait directive )] if , and Code 5. 
Wait directive scenario wait_time: my_vehicle: vehicle do serial: phase1: my_vehicle.drive() with: speed(speed: 0kph, at: start) speed(speed: 10kph, at: end) phase2: wait elapsed([10s..20s]) phase3: my_vehicle.drive() with: speed(speed: [10kph..15kph]) This example is very similar to the one from the composition section for serial. 
But here, another phase in between (phase2) was added, which invokes a wait directive with a duration of 10 to 20 seconds. 
This means that during a time interval of 10 to 20 seconds anything is allowed to happen. 
Afterward, the action of phase3 is invoked. 
7.6.2.5 Events This chapter defines how events and directives involving events, such as emit, wait, or until influence whether a trace accepts a given behavior trace. 
To do so, this subsection defines: How traces are extended with events formally. 
What it means for a scenario to accept a trace extended with events. 
How the individual directives, like emit and wait, work using events. 
There are four sources of events in ASAM OpenSCENARIO: A scenario fires start and end events when it starts and ends. 
A scenario can fire events explicitly using the emit directive. 
A structured type (such as a scenario or an actor) can have event declarations with an event specification that defines when this event occurs. 
The event specification can consist of a condition, such as a rise, fall, or elapse condition or another Boolean expression. 
An event with such an event specification occurs every time the specified condition evaluates to true. 
The event specification can also consist of a reference to another event plus an optional condition. 
In this case, the event occurs every time the referenced event occurs and the condition evaluates to true. 
External functions can fire events. 
For example, an external function that connects to an external simulation application can cause an event to occur under certain conditions in that external simulation application. 
Events are abstract objects: An event is an instance of an event definition identified by the name of the event given in the definition and parameter values for the parameters defined in the event definition (if any). 
An event carries no information about its source. 
Events are purely abstract objects, which means that they are used only as a control mechanism within the language to specify: Constraints on values at certain points in time Constraints on the relative timing of scenarios Points in time in which external functions are invoked Events do not necessarily have a direct resemblance in the modeled traffic system, nor are certain conditions that occur within the modeled traffic system necessarily events in terms of a given ASAM OpenSCENARIO model. 
For example, the starts and ends of scenarios do typically correspond to certain conditions. 
It can be the case that a scenario ends when a vehicle reaches a certain speed. 
However, there could also be sequences of scenarios where there is no uniquely identifiable point in time at which one scenario ends and the other begins, for example, when there are overlapping ranges of possible speeds of a vehicle required by two subsequent scenarios. 
As another example, the honk of a horn can be considered. 
A given traffic system behavior where a vehicle’s horn sounds could be accepted by an ASAM OpenSCENARIO model that does not require or model the honk event at all. 
Likewise, defining and emitting an event called "honk" does not necessarily mean that a vehicle’s horn sounds in the modeled traffic system. 
Such an event must first translate to a change in a field value of a vehicle object in the traffic system. 
More technically and less semantically speaking, a honk event could also be a trigger for an external function call that then leads to a honk happening in an external simulation tool. 
Events occur at certain points in time. 
This is formally represented by an event occurrence function. 
This function defines for every point in time the set of events occurring at that time. 
Formally, an event occurrence function has the type , where is a set of events identified by a name and parameter values. 
( denotes the powerset of , that is, the set of all sets of events.) Based on the event occurrence function, we define an event trace as a tuple that combines an event occurrence function with a trace . 
Both share a time axis, so defines when events occur within the trace . 
Note that the above definition implies that for every point in time there cannot be two occurrences of identical events. 
If, for example, the same event (referring to the same event definition by their name and with identical parameter values) is emitted by two scenarios at the same time, this will lead to the occurrence of only one instance of this event. 
If it is important to separate two occurrences of events, then they must be equipped with parameters that make this separation possible. 
For example, honk events could be equipped with a parameter that specifies the vehicle which is the source of the honk signal. 
Also, note that there is no order among the events occurring at the same time. 
7.6.2.5.1 Trace acceptance and event trace consistency A scenario accepts a trace only if there exists an event trace where the event occurrence defined by satisfy the following conditions: must be event trace consistent with scenario , which means that places events on the trace timeline in such a way that this corresponds to the time stamps of the start and end of scenarios that are invoked directly and indirectly by the scenario : At these points in time, the predefined start and end events for the scenario invocations must occur. 
the time stamps of emit directives directly or indirectly invoked by . 
the time stamps of value changes that trigger qualified events. 
wait directive invocations are terminated if and not before a waited for event occurs while the wait directive invocation is active. 
Invocations of behaviors with an until directive are terminated exactly when a specified event occurs. 
All other trace acceptance conditions defined above remain unaffected and must hold in addition to the conditions given here. 
In the following, the semantics of the emit, wait, until, and on directives are defined in more detail. 
7.6.2.5.2 Emit (event) The emit directive is a zero-time directive that emits an event (which may be waited for in another scenario). 
Within an emit directive invocation, values must be specified for all parameters defined in the event declaration. 
At the time of invocation, any expressions specifying the event parameters are immediately evaluated, so that a concrete event instance is emitted. 
An emit directive typically appears within a serial composition, either directly or indirectly, because its invoking scenario is in turn invoked within a serial composition higher up in the behavior invocation tree. 
In this case, the emit directive emits an event at the same point in time as the previous behavior invocation terminates with respect to the next level of serial composition in the behavior invocation tree. 
That means that the end event of the previous behavior invocation and the event emitted by the emit directive occur at the same time. 
If an emit invocation is not preceded by another behavior in a serial composition, and therefore happens at the beginning of the direct or indirect parent scenario, this means that the emitted event must occur at the beginning of the trace that shall be accepted by that scenario. 
An emit directive is zero-time, which means that the start and end of an emit invocation happen at the same point in time. 
Because an emit directive is zero-time, there is no notion of trace acceptance defined for emit directives: emit directives, as well as all other zero-time directives, are excluded from the trace acceptance semantics definition of the scenario composition operators (see Section 7.6.2.1, “Composition operators”). 
emit directives only influence trace acceptance of the parent scenarios indirectly by influencing the event trace consistency condition defined above (see Section 7.6.2.5.1, “Trace acceptance and event trace consistency”): It is required that the event trace contains the emitted events at the time stamps where the emit directive invocation occurs. 
Code 6. 
emit event event vehicle_reached_speed(vehicle : vehicle, vehicle_speed : speed) # event definition ... 
scenario vehicle.two_phases: do serial: phase1: drive() with: speed(speed: 0kph, at: start) speed(speed: [25kph..35kph], at: end) emit vehicle_reached_speed(actor, actor.speed) phase2: drive() with: speed(speed: [30kph..50kph]) This is an example of how an event can be emitted within a serial composition. 
The event definition is also shown on top: The event requires as parameter values a reference to a vehicle (vehicle) and a speed value (vehicle_speed). 
The scenario describes two driving phases. 
The first phase requires the vehicle to reach a speed between 25 and 35 kph. 
The event is emitted after the first phase, more specifically at the same point in time in which the first scenario terminates. 
The event emitted carries as parameter values a reference to the vehicle object which is subject to the scenario (which can be accessed via the actor field inherent to all scenarios that are invoked on actors), as well as the speed value of that vehicle at the point in time in which the event is emitted. 
Such an event can be caught by another scenario using the wait directive. 
7.6.2.5.3 Wait (event) The wait directive for events serves as a synchronization point, delaying subsequent behavior invocations until the waited for event has occurred. 
Except for delaying the next behavior, the wait statement imposes no constraints. 
If certain constraints shall hold while waiting, such constraints can be specified in a surrounding parallel composition. 
Regarding trace acceptance, it is required that a trace satisfies any constraints imposed by modifiers. 
Other than that, wait directives only influence trace acceptance of the parent scenarios indirectly by influencing the event trace consistency condition defined above (see Section 7.6.2.5.1, “Trace acceptance and event trace consistency”): It is required that the event trace contains waited for events only at the time stamps where the wait directive invocation terminates or is inactive. 
Note that this semantics definition entails that traces can be accepted that never lead to progressing a wait directive invocation, and hence, never lead to the occurrence of any subsequent behavior. 
In use cases where this is not acceptable, for example, upper time bounds can be specified for the invoking scenario. 
Code 7. 
wait event scenario vehicle.sync_with_other_vehicle: other_vehicle: vehicle do parallel: other_vehicle.two_phases serial: wait @vehicle_reached_speed as vrs_event \ if vrs_event.vehicle == other_vehicle \ and vrs_event.vehicle_speed in [30kph..32kph] drive() with: speed(speed: other_vehicle.speed + 20 kph, at: start) In this example, we have a scenario sync_with_other_vehicle that can be invoked on vehicles. 
It holds a field to another vehicle (other_vehicle) and defines a parallel composition of an invocation of the two_phases scenario from Section 7.6.2.5.2, “Emit (event)” on the vehicle other_vehicle and a serial composition of a wait action followed by an invocation of drive(). 
The drive() action is invoked on whichever vehicle sync_with_other_vehicle will be invoked. 
The wait directive waits for the event vehicle_reached_speed that is emitted in the two_phases scenario (see Section 7.6.2.5.2, “Emit (event)”). 
Moreover, the wait directive specifies two conditions: The first condition is that the vehicle parameter of the event must be equal to other_vehicle They must both bind to the same vehicle actor object. 
The second condition is that the parameter vehicle_speed must be within the range of 30 to 32 kph. 
If a vehicle_reached_speed event occurs that satisfies these two conditions, the wait invocation terminates and the subsequent drive() action starts, specifying that the vehicle on which sync_with_other_vehicle is invoked must drive with a speed 20 kph higher than the speed of `other_vehicle´ immediately after the occurrence of the event. 
7.6.2.5.4 Until (event) The until directive specifies that a behavior invocation shall terminate exactly on the occurrence of a specific event, and not before or after. 
The until directive influences trace acceptance indirectly by influencing the event trace consistency condition (see Section 7.6.2.5.1, “Trace acceptance and event trace consistency”): For event trace consistency, events must occur in such a way that invocations of behaviors with an until directive are terminated exactly when a specified event occurs. 
When multiple until directives apply to a behavior invocation, they are treated as if a single until directive was given that matches any of the specified events: The invocation terminates exactly when the first of these specified events occurs. 
Code 8. 
Use of the until directive scenario vehicle.accelerate_to_speed_with_other_vehicle: target_speed : speed other_vehicle : vehicle do drive() with: speed(speed: target_speed, at: end) until @vehicle_reached_speed as vrs_event \ if vrs_event.vehicle == other_vehicle \ and vrs_event.vehicle_speed == target_speed This example shows a scenario for vehicles that invokes a drive action and specifies a target speed that shall be reached at the end of the scenario. 
In addition, the scenario defines a field called other_vehicle and it specifies that the scenario must end exactly at the occurrence of the event vehicle_reached_speed under the condition that the event carries as the vehicle parameter value a reference to the same vehicle as bound to other_vehicle, and a vehicle_speed parameter value the same value as set for target_speed. 
7.6.2.5.5 On (event) Scenarios can have on directives, which define that on the occurrence of an event, another zero-time behavior shall take place, such as a method call or emitting another event. 
on directives only influence trace acceptance if they trigger other events via emit directives (see Section 7.6.2.5.2, “Emit (event)”). 
7.6.3 Actions Actions are atomic behaviors that can be performed by actors, and they can be invoked from scenarios. 
The domain model of ASAM OpenSCENARIO specifies a set of domain actions, such as the drive() action, including their semantics (see Section 8.8, "Movement actions"). 
In this release of the standard, the action semantics are not specified formally, and the precise semantics are left to the implementation of the respective actions. 
7.5 Coverage 7.7 Library mechanisms

7.7 Library mechanisms
7.7 Library mechanisms 7.7.1 Introduction This chapter describes all language features that are relevant to the structuring of collections of scenarios and supporting infrastructure. 
This includes scenario libraries, domain model extensions, and helper libraries. 
This chapter is targeted at library mechanisms for the language and does not consider scenario databases. 
7.7.2 Scenario entry point The scenario entry point is the initial scenario that is selected for scenario execution. 
It is instantiated first and starts the overall execution. 
For ASAM OpenSCENARIO it is defined by implementation how the scenario entry point is selected from the available scenarios in a file. 
This allows implementations to experiment with the best ways to select this entry point while still allowing full flexibility in a scenario and scenario file reuse. 
A future version of ASAM OpenSCENARIO is likely to provide more standardized and advanced facilities for entry point selection. 
7.7.3 Import mechanism To structure source code, it is good practice to split the code into manageable parts and put these parts into separate files. 
The files can then be recombined using an import mechanism. 
The import mechanism built into ASAM OpenSCENARIO allows the content of one file (the referenced file) to be reused in another file (the referencing file). 
This mechanism also works recursively, so that a referenced file can refer to further referenced files. 
7.7.3.1 The import statement The import statement allows importing a file. 
The import statement makes all definitions found in the referenced file effective as if they had been included in the referencing file: Any prelude statements found in the referenced file are treated as having occurred at the textual location of the import statement. 
Any other statements are treated as having appeared before all non-prelude statements in the referencing file, taking the order of imports into account, meaning non-prelude statements from earlier import statements precede those from later import statements. 
The file to be imported can be specified inside the import statement as a string literal or using identifiers. 
In all cases, a file that is referenced multiple times (either directly or transitively) is only imported once. 
The import occurs at the place in the transitive reference chain that is first according to depth-first traversal: All later references to the same file result in no further import occurring. 
The implementation shall detect multiple references as described using the mechanisms the implementation considers necessary. 
In case no other mechanism is found more suitable, an implementation may consider two files to be the same if they have identical content. 
7.7.3.1.1 Import using string literals If the file is specified using a string literal, then the file specification is considered to be a Uniform Resource Identifier (URI). 
Relative URIs are resolved relative to the location of the referencing file. 
Implementations shall support the file URI scheme. 
Implementations may support more URI schemes. 
It is recommended to use a file extension of .osc to identify files of this version of ASAM OpenSCENARIO. 
This differentiates such files from the XML-based ASAM OpenSCENARIO 1.2.0 files using the .xosc file extension. 
7.7.3.1.2 Import using identifiers If the file is specified using one or more identifiers separated by a period (.), the file specification is considered to be a module reference and is resolved to a file specification by the implementation in an implementation-specific manner. 
This mechanism can include user- and system-defined library search paths. 
Any structured identifier that starts with the osc identifier is reserved for use by this version and future versions of ASAM OpenSCENARIO (see also Section 7.7.3.2, “Importing the standard library”). 
Note that the reserved identifier osc is different from the file extension .osc that is by default used for files of ASAM OpenSCENARIO, even though both use the same three-letter abbreviation. 
The current specification of how module references are resolved is intentionally left non-specific for this release in order to allow implementations to evolve with actual usage practice. 
Future versions of the standard are likely to encode best practices when actual practice is clearer and the other components of a module system are in place. 
For maximum portability across implementations the URI-based string specifications can be used. 
Code 1. 
Examples of file import statements # URI-based import statements import "foo/bar.osc" import "file:///c:/Users/someone/src/foo/bar.osc" import "file:/c:/Users/someone/src/foo/bar.osc" import "/c:/Users/someone/src/foo/bar.osc" import "file:///home/someone/src/foo/bar.osc" import "file:/home/someone/src/foo/bar.osc" import "/home/someone/src/foo/bar.osc" # Identifier-based import statements import osc.standard # Imports the standard library, see next section. 
import foo.bar # Imports a module foo.bar in some implementation defined way 7.7.3.2 Importing the standard library The ASAM OpenSCENARIO standard library is described in Section 8.14, "Standard library". 
Any scenario file that is to use standard library facilities must import the standard library with the following import statement: Code 2. 
Import statement for use of standard library import osc.standard This will ensure that the definitions of the standard library are accessible. 
Whether an implementation implements this by importing some variant of the standard.osc file provided as part of this standard, or through any other means (e.g. 
by providing access to built-in definitions) is left to the implementation. 
7.6 Semantics 8 Domain model reference

8 Domain model reference
8 Domain model reference The domain model defines the entities needed to build scenarios. 
It defines different actions and properties of these entities. 
For an introduction into the domain model, see Section 8.1, "Domain model introduction". 
The domain model can also be extended. 
This is described in Section 9.3, "Extending the domain model". 
This chapter contains the following parts: Section 8.1, "Domain model introduction" Section 8.2, "Domain model core layout" Section 8.3, "Coordinate systems" Section 8.4, "Actions and modifiers" Section 8.5, "Abstract road network" Section 8.6, "Behavioral model" Section 8.7, "Physical object actors" Section 8.8, "Movement actions" Section 8.9, "Movement modifiers" Section 8.10, "Environment actors" Section 8.11, "Environment actions" Section 8.12, "Road abstraction classes" Section 8.13, "Physical types and structs" Section 8.14, "Standard library" 7.7 Library mechanisms 8.1 Domain model introduction

8.1 Domain model introduction
8.1 Domain model introduction This section gives an introduction to the domain model. 
8.1.1 Introduction This introduction presents definitions of the term domain model, introduces the ASAM OpenSCENARIO domain model, and lists relations to other standards. 
8.1.2 About domain models Fowler [11] defines domain models as an object model of the domain that incorporates both behavior and data. 
— Martin Fowler P of EAA: Domain Model Brown [12] describes domain models in more detail as […​] your organized and structured knowledge of the problem. 
The Domain Model should represent the vocabulary and key concepts of the problem domain and it should identify the relationships among all of the entities within the scope of the domain. 
— Philip Brown Culttt: What is the Domain Model in Domain Driven Design? Domain models can also be referred to as "Conceptual Models" or "Concept Systems", for example, as described in ISO704 [22]. 
8.1.3 ASAM OpenSCENARIO domain model The domain model of ASAM OpenSCENARIO provides a set of standard solutions for entities and their actions (see Section 8.8, "Movement actions"). 
More specifically, the top-level entities or actors are: Physical objects with dedicated actions, mostly to define their motion Environment with actions, for example, to define the weather conditions Maps to describe the road network in an abstract form Furthermore: Physical types and structs include a normative set of scalar and compound types with units. 
Using these pre-defined entities has the following advantages: Ensure interoperability of scenario definitions between tools Save development time Lead users to a correct methodology However, no committee can predict all possible actors, actions, and fields for all current and future industry purposes. 
Therefore, an extension mechanism for the domain model is presented in a separate document to enable customization of the domain model. 
Due to the rapidly evolving nature of the domain addressed by ASAM OpenSCENARIO, ASAM OpenSCENARIO 2.0.0 is built to allow easy, non-normative extension of the domain model. 
Later releases of the standard will be extended to meet industry demand with additional entities and actions. 
8.1.4 Harmonization Harmonization of the domain model across different ASAM standards and other standards is desirable and has the following advantages: Harmonization supports the seamless use of these standards with ASAM OpenSCENARIO. 
Harmonization avoids user confusion caused by conflicting terms and definitions. 
Therefore, the following standards have been taken into account: ASAM OpenSCENARIO 1.2.0 Features related to the domain model of ASAM OpenSCENARIO 1.2.0 are covered to ensure this version of ASAM OpenSCENARIO is a super-set of ASAM OpenSCENARIO 1.2.0. 
ASAM OSI Align with ASAM OSI where possible, to enable coherent reuse of attributes from scenario definition in sensor models. 
ASAM OpenDRIVE Align with ASAM OpenDRIVE where possible, to avoid conflicting terms and definitions without restricting the usage to maps defined in ASAM OpenDRIVE format. 
ASAM OpenXOntology Collaboration with ASAM OpenXOntology to aim at improved harmonization of ASAM standards. 
UN ECE/TRANS/WP.29/78/Rev.6 Used as a basis for the categorization of vehicles. 
8 Domain model reference 8.2 Domain model core layout

8.2 Domain model core layout
8.2 Domain model core layout The following sections contain the core layout of the domain model. 
Before continuing, make sure to be familiar with Section 3, "Terms and definitions". 
For a more detailed description of key terminology, refer to Section 6.2, "Key terminology". 
The entities of the domain model and their sub-classes are described with their definitions, states, properties, and relations to other classes. 
The following entities are available: Physical object Environment Action Physical type Road abstraction Behavioral model Figure 10. 
Entity overview 8.1 Domain model introduction 8.3 Coordinate systems

8.3 Coordinate systems
8.3 Coordinate systems In ASAM OpenSCENARIO, the following coordinate system types are defined: A coordinate system that consists of three orthogonal directions associated with X, Y, and Z axes and a coordinate origin where axes meet, defines the right-handed Cartesian coordinate system. 
It is compliant with the ISO 8855:2011 [8] definition. 
Orientation of road objects is expressed extrinsically by the yaw, pitch, and roll angles derived from the sequence of rotations in the order: Z-axis, then Y-axis, then X-axis. 
The positive rotation is assumed to be counter-clockwise ("right-hand rule", see Figure 11): Figure 11. 
Yaw, pitch, and roll angle in an ISO 8855:2011 compliant coordinate system A route-based coordinate system that consists of two coordinate axes associated with the reference line of the corresponding route (s-axis) and the direction orthogonal to it (t-axis) and pointing leftwards. 
The definition of the s- and t-axes depends on the reference part of the route in use (see Figure 12). 
Common route elements that use this coordinate system in ASAM OpenSCENARIO include lanes, lane sections, roads, crossings, and paths. 
Figure 12. 
Route-based s/t-coordinate system with origin at the beginning of the route 8.3.1. 
World coordinate system (Xw, Yw, Zw) Coordinate system of type (X, Y, Z) fixed in the inertial reference frame of the simulation environment, with Xw and Yw axes parallel to the ground plane and Zw axis pointing upward. 
Neither origin nor orientation of the world coordinate system is defined by ASAM OpenSCENARIO. 
If a road network is referenced from a scenario, the world coordinate system is aligned with the inertial coordinate system present in this description. 
In particular, the Zw-coordinate is assumed to consider a road elevation, an entire road super-elevation, or a lateral road shape profile. 
8.3.2. 
Vehicle coordinate system (Xv, Yv, Zv) The vehicle axis system of type (X, Y, Z), as defined in ISO 8855:2011 [8], is fixed in the reference frame of the vehicle sprung mass. 
The Xv axis is horizontal and forwards with the vehicle at rest. 
The Xv axis is parallel to the vehicle’s longitudinal plane of symmetry. 
The Yv axis is perpendicular to the vehicle’s longitudinal plane of symmetry and points left. 
The Zv axis points upward. 
In ASAM OpenSCENARIO, the origin of this coordinate system is derived by projecting the center of the vehicle’s rear axis to the ground plane at neutral load conditions. 
The origin remains fixed to the vehicle sprung mass, as illustrated in Figure 13. 
For vehicles with a single axle, this axle is used to determine the reference point. 
In the case of multiple rear axles, the first rear axle with permanent regular contact with the road surface is used. 
Figure 13. 
Vehicle coordinate system 8.3.3. 
Physical object coordinate system (Xp , Yp , Zp) Except for the special case of the vehicle coordinate system, the axis system for all physical objects is fixed in the reference frame of the object’s bounding box. 
Both, the X-axis and Y-axis are horizontal. 
If an obvious object’s front plane can be identified, for example, for pedestrians, the X-axis is normal to the object’s front plane pointing forward. 
The Y-axis is horizontal, perpendicular to X, and points to the left. 
The Z-axis points upward. 
The origin of this coordinate system is derived from the geometrical center of the object’s bounding box under neutral load conditions (if applicable) projected onto the ground plane. 
8.3.4 Lane coordinate System (s/t) To every lane specified in a lane section of a road, there is a s/t-type coordinate system assigned. 
It is assumed the lane geometry is specified in the world coordinate system in the detailed road network definition (external to ASAM OpenSCENARIO). 
The lane centerline is defined as the s-axis on the (X,Y)-plane of the world coordinate system going in the middle between the lane’s left and right boundaries throughout the whole lane section. 
The shape of the s-axis line is determined by the geometry of the lane projected on the (X,Y)-plane. 
The s-coordinate is calculated along the s-axis without considering an elevation of the lane in the s-direction. 
At each s-coordinate along the s-axis a new t-axis is defined. 
Being located on the (X,Y)-plane, each t-axis points to the left orthogonally to the s-axis direction. 
The t-coordinate is calculated without considering the lateral profile of the road. 
The vertical position orthogonally to the local (s,t)-plane depends on the road elevation and lateral profile, and therefore it is derived from the respective detailed road network description (external to ASAM OpenSCENARIO). 
Both s- and t-coordinate are relevant within the respective road boundaries. 
The origin of the s-coordinate is fixed to the beginning of the lane centerline. 
The origin of the t-coordinate resides on the lane s-axis at the respective s-coordinate. 
8.3.5 Lane section coordinate system (s/t) To every lane section specified within a road, there is a s/t-type coordinate system assigned. 
It is assumed the lane section geometry is specified in the world coordinate system in the detailed road network definition (external to ASAM OpenSCENARIO). 
The s-axis of the lane section coincides with the s-axis of one of the lanes that is contained within the lane section. 
ASAM OpenSCENARIO allows users to indicate which lane should be chosen to define the s-axis of the lane section. 
The t-axes of the lane section also coincide with the t-axes of the chosen lane at the respective s-coordinates. 
The vertical position orthogonally to the local (s,t)-plane depends on the road elevation and lateral profile, and therefore it is derived from the respective detailed road network description (external to ASAM OpenSCENARIO). 
In the case of multiple lane sections, each lane section defines its own set of lanes with their own s-axes. 
8.3.6 Road coordinate system (s/t) To every road specified in the ASAM OpenSCENARIO abstract road network definition, there is an s/t-type coordinate system assigned. 
It is assumed the road geometry is specified in the world coordinate system in the detailed road network definition (external to ASAM OpenSCENARIO). 
The road reference line is defined as the sequence of s-axes from the lane sections that compose the road. 
The road t-axes coincide with the t-axes of the corresponding lane section at the respective s-coordinates. 
The vertical position orthogonally to the local (s,t)-plane depends on the road elevation and lateral profile, and therefore it is derived from the respective detailed road network description (external to ASAM OpenSCENARIO). 
8.3.7 Crossing coordinate system (s/t) To every crossing specified within a road network, there is a s/t-type coordinate system assigned. 
It is assumed the crossing geometry is specified in the world coordinate system in the detailed road network definition (external to ASAM OpenSCENARIO). 
The crossing’s centerline is defined as the s-axis on the (X,Y)-plane of the world coordinate system going in the middle between the crossing’s left and right boundaries throughout the whole crossing. 
The shape of the s-axis line is determined by the geometry of the crossing projected on the (X,Y)-plane. 
The s-coordinate is calculated along the s-axis without considering an elevation of the crossing in the s-direction. 
At each s-coordinate along the s-axis a new t-axis is defined. 
Being located on the (X,Y)-plane, each t-axis points to the left orthogonally to the s-axis direction. 
The t-coordinate is calculated without considering the lateral profile of the crossing. 
The vertical position orthogonally to the local (s,t)-plane depends on the road elevation and lateral profile, and therefore it is derived from the respective detailed road network description (external to ASAM OpenSCENARIO). 
Both s- and t-coordinate are relevant within the respective road boundaries. 
The origin of the s-coordinate is fixed to the beginning of the crossing centerline. 
The origin of the t-coordinate resides on the crossing s-axis at the respective s-coordinate. 
8.3.8 Path coordinate system (s/t) To every path specified within the scenario, there is a s/t-type coordinate system assigned. 
The path is deemed as an imaginary spatial directed line ("path line") that expresses a movement path. 
The s-axis line is defined as a projection of the path line on the (X,Y)-plane of the world coordinate system. 
The s-coordinate is calculated along the path s-axis without taking into account an elevation of the path in the s-direction. 
At each s-coordinate along the s-axis a new t-axis is defined. 
Being located on the (X,Y)-plane, each t-axis points to the left orthogonally to the s-axis direction. 
The vertical position orthogonally to the local (s,t)-plane depends on the road elevation and lateral profile, and therefore it is derived from the respective detailed road network description (external to ASAM OpenSCENARIO). 
The origin of the s-coordinate is fixed to the beginning of the projected path line. 
The origin of the t-coordinate resides on the path s-axis at the respective s-coordinate. 
8.2 Domain model core layout 8.4 Actions and modifiers

8.4 Actions and modifiers
8.4 Actions and modifiers Multiple considerations are taken into account for the creation of the ASAM OpenSCENARIO domain model actions and modifiers. 
Key requirements for actions and modifiers are: Provide ease of use and software engineering fundamentals Allow the tuning of actions within the context of a scenario Support concrete goals and achieve unknowns Provide a similar API and use-model for both actions and scenarios Provide actions that are platform- and implementation-agnostic Support generic and specialized action styles These key requirements are explained in more detail in the following sections. 
8.4.1 Ease of use Actions combine ease of use and simplicity with reusability and generality. 
This allows creating reusable assets and libraries. 
The ASAM OpenSCENARIO domain model is designed for the creation of modular and composable scenarios leveraged by software engineering fundamentals. 
As a result of balancing ease of use and re-usability, the ASAM OpenSCENARIO language allows users to further specialize the ASAM OpenSCENARIO domain model. 
8.4.2 Tuning actions Actions are encapsulated pieces of behaviors that can be activated in multiple scenarios and contexts. 
Users can create an abstract action and further direct or tune this action for a specific scenario need. 
This can be achieved on the type level and on the instance level. 
Therefore users can: Tune actions by locking one of the parameter values. 
Example: Ego’s speed is 5 kph throughout the drive. 
Narrow the allowed range. 
Example: Ego’s speed is between 5 kph and 10 kph. 
Apply a constraint. 
Example: Ego’s speed is less than 60 kph. 
Introduce a dependency between attributes. 
Example: Ego’s speed is slower than that of a target vehicle. 
8.4.3 Goals and unknowns As part of a project, users may want to explore the unknown or the unexpected as per SOTIF. 
This can be done with two approaches: Explicitly specify a scenario execution. 
Provide the generic direction in a stochastic approach. 
Users often want to use a combination of the two approaches: Some of the parameters are specified and some are automatically inferred in a consistent way to the provided values. 
This is possible with ASAM OpenSCENARIO, which allows the combination of both concrete and abstract statements while also reusing the same assets. 
ASAM OpenSCENARIO allows users to control the level of freedom. 
For example, consider a lane change towards the curbside of a road. 
It is likely not reasonable for an ASAM OpenSCENARIO solver to be able to change lanes onto a curb leaving the drivable surface area via a lane change maneuver. 
8.4.4 API and use-model While actions represent atomic pieces of behavior, scenarios represent composite behaviors that are built from other actions or scenarios. 
Because users may need to replace an atomic behavior with a composite behavior for different platform needs, ASAM OpenSCENARIO provides consistency in both triggering and observing actions and scenarios. 
For example, invoking scenarios and actions is done the same way. 
Much of the motivation in these chapters is valid for both actions and scenarios. 
8.4.5 Agnosticism ASAM OpenSCENARIO enables a cross-industry language that can be used for all platforms including physical and virtual testing. 
This means that: The same ASAM OpenSCENARIO engine can be connected to multiple platforms. 
Exactly how individual vendors connect the high-level language to a simulator, HiL or test truck is beyond the scope of the standard and this documentation. 
The same scenario code can serve both physical platforms and platforms with platform-related additions. 
8.4.6 Action styles and modifiers Two possible styles are provided for scenario specification: Generic actions Generic actions only have the arguments that are inherited from the parent action class. 
Generic actions activate a rich set of controls on how to perform the action with the use of modifiers for actions. 
This makes generic actions multi-purpose. 
Example: "Drive with fast speed at the beginning and slow speed at the end." Specialized actions Specialized actions have additional arguments to create single-purpose actions. 
Each specialized action reflects a commonly used behavior in scenario description. 
This improves readability. 
Example: "Reach high speed and later reach a lower speed." These two styles are facets of the same language and methodology can be mixed in the same scenario. 
As the behavior of specialized actions is defined in the domain model they are less flexible and less extendable than generic actions. 
However, this also means that specialized actions offer significantly easier readability and more clearly communicate an author’s intent. 
The benefits of the generic style are: A wider set of concrete instances can result from the same action invocation. 
More options for tuning the behavior are available. 
Non-intrusive extension is allowed. 
It is possible to extend an already existing scenario and non-intrusively tune it. 
Example: Users have specified a drive action at a certain speed. 
Later on, they wish to tune the scenario to drive fast at the beginning and slow later on. 
In the fragmented style, such enhancement is impossible. 
In the descriptive style, this translates into an extension with a modifier asking for the needed speeds at the beginning or at the end. 
Actions are structs with unique semantics. 
As such, any legal struct member can be an action or a scenario member. 
8.4.6.1 Generic actions The following snippet describes the parallel behavior of two vehicles. 
The drive action for the two vehicles is called with the speed and position modifiers: Code 1. 
Generic actions scenario my_scenario: do parallel: d1: vehicle1.drive() with: speed([50kph..120kph]) d2: vehicle2.drive() with: position(distance: [5m..100m], behind: vehicle1, at: start) position(distance: [5m..15m], ahead_of: vehicle1, at: end) This code calls the drive action for the two vehicles and uses domain-model modifiers to express how to drive. 
Available modifiers to describe the desired drive are: speed position distance lane The values can be in absolute or relative terms, for example, position in absolute term or relative to another actor. 
The values can be applied at the beginning, at the end, or throughout the phase, for example, start the drive action at the speed of 10 to 20 kph and finish at the speed of 40 to 60 kph. 
This style uses a natural language to simplify scenario description by using a limited set of domain model modifiers. 
User-defined modifiers for different purposes can be added on top of these for both generic and specialized actions. 
8.4.6.2 Specialized actions A specialized action is a wrapper for an underlying generic action and various constraints. 
These constraints serve to restrict the generic action to the behavior expected of the specialized action. 
Each scenario invocation of a specialized action thus activates the underlying generic action. 
Code 2. 
Specialized actions scenario my_scenario: do parallel: d1: vehicle1.reach_speed(5kph) d2: vehicle2.reach_speed(10kph) The example shows specialized actions that abstract away the full API of the standard, lowering the barrier of entry to scenario authoring. 
8.4.6.3 Action implementation The generic actions and the specialized actions can be mixed because of the domain model implementation point of view: The specialized actions are wrappers of the generic actions. 
These wrappers expose a subset of the APIs. 
The implementation wrapper is published to allow users to layer constraints and even use modifiers on top of the wrapped generic actions. 
The following is an implementation example of the reach_speed specialized action: Code 3. 
Action implementation scenario vehicle.reach_speed: speed: speed do drive() with: speed(speed, at: end) Note that the specialized actions are carefully selected to optimize the number of standard actions. 
If users wish to create their own scenario actions, they can use the ASAM OpenSCENARIO language to achieve this. 
To express that a vehicle should reach a speed and change lanes at the same time, users need to parallelize the request on the same actor. 
Code 4. 
Parallel action implementation scenario my_scenario: v1: vehicle do parallel: v1.reach_speed(5kph) v1.target_lane(2) Note that in such situations two drive actions are invoked. 
This is similar to the defined behavior of the generic actions. 
An ASAM OpenSCENARIO tool should identify that the drive directives are on the same instance, and create the desired effect of both reaching the speed and changing the lane. 
Using the generic actions is similar to the previous one: Code 5. 
Generic action implementation scenario my_scenario: v1: vehicle do v1.drive() with: speed(5kph, at: end) lane(2, at: end) 8.3 Coordinate systems 8.5 Abstract road network

8.5 Abstract road network
8.5 Abstract road network The ASAM OpenSCENARIO language allows users to describe key aspects of the map in which the scenario shall take place. 
This ASAM OpenSCENARIO description is not a replacement for a fully detailed geometric map. 
Such descriptions can be found in a map file. 
Rather, it is an abstract description of the features of the road network that influence the behavior of the actors during the scenario. 
This section explains the main concepts of the ASAM OpenSCENARIO road abstraction and how road abstraction can be used for scenario description. 
8.5.1 Roads, maps, and scenarios This part of the ASAM OpenSCENARIO domain model is placed under the map actor. 
The classes and modifiers under the map actor can be used to describe an abstract road network (ARN). 
This abstract road network can then be used as a location proxy for the specification of actor behavior. 
Consistent rules to define road-based coordinate systems within the abstract road network also enable the following tasks: Locating actors in the scenario Triggering the behavior of actors according to their location Constraining the behavior of actors according to their location Furthermore, an abstract road network can be used to: Search for an existing road network that matches the abstract road network’s constraints. 
This can be done, for example, within a specific map file, or in a map database. 
Create a synthetic map that satisfies the abstract road network constraints. 
In this sense, users can think of this abstract road network as a "search space", rather than a geographic map or fixed geometry for the scenario. 
This part of the domain model enables ASAM OpenSCENARIO users to describe routes within a map. 
Such a map abstractly represents a desired environment to enable a behavior of a scenario. 
The abstract road network was designed with the expressed intent to enable paths of behavior and routes that can be used to express both legal paths of behavior and illegal paths of behavior. 
The main purposes of an abstract road network as part of the domain model are: Specifying constraints with respect to map, road, junction, and lane elements. 
Creating a map search space to either find a matching road network in a map or generate a synthetic one. 
Matching mapped entities for actor behavior. 
Creating paths of behavior called routes, so they can be used within behavior descriptions. 
Using s-t-coordinate systems when moving along a route. 
Enabling extension of the road’s domain model, either by users or by future releases of the standard. 
8.5.2 Purposes of constraints The main purposes of constraints of an abstract road network are: Limit the map search space. 
Describe a minimum environment that is necessary to allow paths of behavior through routes. 
Use modifiers to create routes or establish relationships between entities. 
Use the created routes to define where to drive along() within an action description. 
Here, along() specifies the route that is traveled. 
8.5.3 Key points Key points when creating an abstract road network are: Describe only a minimum abstract road network that is necessary to support behavior. 
Do not re-create a map file. 
Let modifiers do the hard work. 
An abstract road network does not replace ASAM OpenDRIVE or any other map supply. 
The goal of the abstract road network is to allow a user to outline just the details required for their use case so that suitable maps meeting these requirements can be selected. 
An abstract road network acts as a set of constraints needed to find and resolve options for behavior and the driving domain. 
In the driving domain, this is narrowed down to a specific set of maps, route points, or routes and sometimes even further using route anchors. 
8.5.4 Maps For the purposes of ASAM OpenSCENARIO, the map class is a domain model representation of an abstract road network. 
The map holds entities necessary for both the creation and restriction of a map search space. 
A map_file is a parameter representing a map file or concrete road network representation of road entities and road geometry. 
In ASAM OpenSCENARIO, this is represented as a string, which can include both the file path and the file name of the map file. 
A map_file is included in the map class so that the search space defined in an instance of map can be limited to one specific map file. 
The map file for a scenario can be set using the map.set_map_file() modifier. 
In future versions of ASAM OpenSCENARIO the map_file parameter may be deprecated in favor of a more complete mechanism to bind external maps to the abstract road network description. 
The map is composed of instances of route and junction, which allow an abstract description of the road network to be matched to specific entities in a map file. 
Constraints are the primary way that a map’s entities are used to restrict the map search space. 
For the construction of routes constraints are used to both create and restrict the map search space. 
Map methods such as map.create_route() gives users the flexibility to create routes either from a single map_file or from an external implementation. 
This also applies for the creation of compound routes, see Section 8.5.7, “Creating compound routes”. 
Every scenario, no matter if abstract, logical, or concrete, must have a set of constraints that relate to the map. 
Otherwise, actions cannot be rational to space and time. 
An ASAM OpenSCENARIO map is composed of: Instances of route A map can have zero routes, one route, or many routes. 
route is the parent class of map elements like road and lane, among others. 
Instances of junction A map may have zero junctions, one, or many junctions. 
Junctions connect roads in the abstract road network. 
A setting for the driving_rule A map may be for left-handed traffic or right-handed traffic. 
A map_file parameter This allows users to bind the abstract road network to an external map file. 
This parameter can remain unspecified. 
In the ASAM OpenSCENARIO domain model, the elements allowing users to describe an abstract road network for the scenario are under the parent-class map. 
Figure 14. 
Entity overview 8.5.4.1 Map as an actor For a map to act in a creation space, the map must be an actor that acts or has actions and modifiers like a typical actor does, meaning vehicle, person, animal, and so on. 
A map represents the abstract road network and contains definitions of road abstraction related methods and modifiers. 
A map is a subclass of an actor as only actors can contain modifiers. 
A map has to be an actor because only actors contain modifiers. 
A map replaces the abstract_road_network name because it is shorter: map.routes_overlap() rather than road_network.routes_overlap() 8.5.4.2 Binding the map search space In future versions of ASAM OpenSCENARIO the map_file parameter may be deprecated in favor of a more complete mechanism to bind external maps to the abstract road network description. 
A map_file can be used with a constraint to restrict the map search space to a single map or within a list of map files. 
map_file entities are specific to map_file implementation and specific implementors and are not specific to ASAM OpenSCENARIO. 
The map_file constraints can optionally be used to bind the abstract road network search space (map) to a concrete map_file or a set of map files to support both concrete scenarios and abstract scenarios. 
For example, the benefit of assigning or creating a constraint to one map_file is like constraining a parameter to one value. 
Given this constraint, scenario developers can ensure that the behaviors of the scenario attempt to secure a location somewhere within this map_file geometry. 
Code 1. 
Setting a single map_file map.set_map_file('my_map.xodr') Alternatively, you can use a keep constraint. 
Code 2. 
Constraining a single map_file my_map: map keep(my_map.map_file == 'my_map.xodr') For logical scenarios, the benefit of creating a constraint with more than one map ensures that behaviors of the scenario attempt to secure a location somewhere within this list of map files. 
Code 3. 
Assigning multiple map files for a logical scenario my_map: map keep(my_map.map_file in ['my_map1.xodr', 'my_map2.xodr', 'my_map3.xodr']) If a map_file is not defined or constrained and is instead left to abstraction, any ASAM OpenSCENARIO implementation could use the map constraints to define a map_file that satisfies the constraints for the given application. 
8.5.5 Routes The class route is the common parent class for all children of route_element and compound_route. 
It lets the user specify locations on the abstract road network (single or composed elements) where traffic participants can move. 
The along() modifier enables usage of those routes inside scenarios and actions. 
8.5.5.1 Route data structure As shown in the following part of the domain model diagram, the class route inherits to several children. 
Figure 15. 
Entity overview This chapter contains a short description of each class that inherits from route (see Struct route). 
route The parent class of route_element and compound_route. 
An instance of route can refer to a single route_element, like a road or a lane, or to a sequence of elements (in the case of a compound_route). 
Having a single parent for these classes facilitates the use of the along() modifier, and simplifies multiple other route- and map-related functionalities. 
route_element A basic, individual element used to build a route. 
Compound routes are composed of a list of individual route elements. 
lane A pathway limited by two boundaries. 
Other elements of the road network are built out of lanes. 
lane_section A group of adjacent lanes arranged side-by-side. 
Within a lane_section, the number, type, use, and directionality of lanes remain constant. 
road A sequence of adjacent lane sections arranged end-to-end. 
A road can only connect to another road at a junction. 
crossing A pathway similar to a lane, but overlaid on top of other lanes. 
Typically used for crosswalks, railroad crossings, or other situations with overlaying uses and directionalities. 
path An ordered list of points in global world coordinates. 
route_point A waypoint for a route expressed in s-t-coordinates. 
xyz_point A waypoint for a route expressed in Cartesian coordinates. 
odr_point A waypoint for a route expressed in ASAM OpenDRIVE coordinates. 
compound_route An ordered list of adjacent route_element instances which are used to describe a potential course of movement. 
The members of the compound_route must be traversed in sequential order. 
compound_lane An ordered list of adjacent lanes arranged end-to-end. 
ASAM OpenSCENARIO also includes: relative_path trajectory relative_trajectory However, these classes are not children of route. 
The relative_path and all trajectories have dependencies on time and are therefore not routable types. 
The relative_path, trajectory, and relative_trajectory types can be used with their corresponding actions. 
Figure 16. 
Entity overview Figure 17. 
Entity overview 8.5.5.2 Route anchors Map file constraints narrow the map search space. 
But it is also possible to narrow the search space of route locations to specific location entities within a map file. 
Route anchors are used to narrow this search. 
Route anchors are string identifiers that allow one or more route entities of a map search space to be tied or bound to any map file entity. 
A typical use case for implementors is using an application that creates unique identifiers within the map file to pair with route elements, like road, lane_section, lane, and so on. 
ASAM OpenDRIVE examples:  Used as an attribute of road. 
 Used as an attribute of a lane section. 
 Used as an attribute of lane. 
 Used as an attribute of road that provides an anchor to the lane level. 
When used as a search space, each route can be restricted to a single location entity (or a set of location entities) within a map file. 
These location entities, which are found in a map file, are representative of the type of route entity that is being anchored. 
Example 1: The route anchors of a lane are matched with a lane that has an anchor in the map file. 
Example 2: A lane section is matched with a lane section that has an anchor in the map file. 
Example 3: A road is matched with a road that has an anchor in the map file. 
Example 4: A route point is matched with a point in the map file. 
A single anchor or a set of anchors can be found in the map file. 
This is up to the implementor. 
Example: map.map_info.map_file has a relationship with map.route.anchors. 
A map anchor of a route is an entity that provides a pointer to a map file entity. 
This clarifies or restricts a map-route entity to a map file entity. 
The types depend on the implementation. 
Given an instance of route: Binding of route.anchors Route anchors are of the route class and can be used optionally to bind or allow for a narrowed set of matched location entities within a map file with the potential to satisfy a route within the map search space of a map. 
The matched entities depend on the map file implementation and are up to the implementor. 
Each route contains an optional ability to bind a given route to a set of anchors. 
These anchors could be used within a defined map.map_info.map_file to allow an implementation to determine the location of a given route. 
For a map file or a set of map files, the route anchors are defined as a list of strings to enable multiple choices found within. 
struct lane: lane_type: lane_type lane_subtype: lane_subtype anchors: list of string 8.5.5.2.1 Creating routes using anchors Example 1. 
Assign anchors for a single map my_map: map.map_info.map_file = ['my_map1.xodr'] anchored_lane_section: lane_section with: keep('11111111-1234-5678-1234-567812345678' in it.anchors) # shows an example of a uuid used as an anchor anchored_lane1: lane with: keep('-1' in it.anchors) Example 2. 
Assign anchors for longer route my_map: map.map_info.map_file = ['my_map1.xodr'] anchored_lane_section1: lane_section with: keep('first_anchor_uuid1' in it.anchors) anchored_lane1: lane with: keep('-1' in it.anchors) anchored_lane_section2: lane_section with: keep('second_anchor_uuid2' in it.anchors) Example 3. 
Assign anchors for multiple maps my_map: map.map_info.map_file = ['my_map1.xodr', 'my_map2.xodr'] # each entry in the list is used sequentially but has unique ids. 
ego_lane: lane with: keep('net.asam.opendrive: roadId:165, laneId:-1' in it.anchors or 'net.asam.opendrive: roadId:257, laneId:-3' in it.anchors) # Allows For Logical Scenario where the egoVehicle can start in a different lane given each map. 
Specific implementation is up to the implementor. 
This is just an example. 
Example 4. 
Assign anchors to route_point my_map: map.map_info.map_file = ['my_map1.xodr'] my_route_point: route_point with: keep('net.asam.opendrive: roadId165, laneId:-2, s:121, t:2.3' in it.anchors) Specific implementation is up to the implementor. 
This is just an example. 
Example 5. 
Anchoring two locations for two vehicles starting from different places on the same map my_map: map.map_info.map_file = ['my_map1.xodr'] anchored_starting_location1: lane_section with: keep('location1_uuid' in it.anchors) anchored_location1_lane: lane with: keep('-1' in it.anchors) anchored_starting_location2: lane_section with: keep('location2_uuid' in it.anchors) anchored_location2_lane: lane with: keep('-3' in it.anchors) 8.5.6 Junctions 8.5.6.1 Junction definition This definition of a junction is valid for this version of ASAM OpenSCENARIO and in the context of an abstract road network. 
A junction is a connected search space. 
That search space is represented by a list of one or more roads that connect up to an area of intersection. 
A junction is also an area where junction routes bind incoming routes (like roads and lanes) to outgoing routes, like spokes on a wheel. 
Roads that connect to a junction, can be used as routes. 
A junction is not a route, but rather a separate object corresponding to a place where multiple routes meet. 
These routes are bound with connections to allow the flow of behavior. 
Each junction has a list of roads that define possible options to create junction routes or pathways through the junction. 
Roads are used in several relations, like roads_follow_in_junction(). 
See Section 8.5.7.1, “roads_follow_in_junction() modifier”. 
The referenced roads follow in and out of the junction. 
Key point The junction class has a list of one or more instances of road. 
Figure 18. 
Basic junction 8.5.6.1.1 Junction routes within a junction A junction route is a route within a junction. 
Junction routes are formed through modifiers, like roads_follow_in_junction(). 
A junction route completes connections between incoming roads and outgoing roads or incoming lanes and outgoing lanes. 
Note that junction route is not a class. 
Junction route is a term used to refer to instances of route that are inside of junctions. 
A junction route can be any type of route, like a single route_element or a compound_route. 
Key points A junction is a hub for road connections. 
Therefore, the junction class contains a list of road elements that connect through the junction. 
A junction is neither a route nor a route_element, and cannot be included in a compound_route. 
However, there can be routes inside of a junction. 
Instances of route that are inside of a junction are called junction routes. 
A junction route is used to complete connections between route elements, for example, road, lane, and so on. 
To make pathways from an incoming road to an outgoing road, a junction uses junction routes to close or complete a connection. 
An in_road to an out_road is typically passed to modifiers like road_follow_in_junction to create junction routes. 
These junction routes provide connection pathways that allow for route transitions. 
The transitions can be: From one route to another route Used in an all-encompassing route These junction routes can also act as virtual lanes inside the junction. 
Junction routes allow for both legal pathways and illegal pathways, whereas ASAM OpenDRIVE or a real road network typically only specifies legal pathways. 
roads_follow_in_junction() only creates legal junction routes. 
However, users can use junction routes to create routes (or compound routes) where actors could move against the legal traffic flow. 
One junction can connect to many routes with junction routes, like spokes on a wheel. 
Each one of the outer roads can be connected through junction routes to another road (meaning another spoke of the same wheel). 
Combining the in_road and the out_road with junction routes enables behavioral pathways. 
A junction route is not always used as a virtual lane. 
Sometimes a junction route is used as a virtual road connecting all the lanes of one road or route with all lanes of another road or route. 
Figure 19. 
Junction routes The following examples show how to create junction routes inside of a junction. 
Example 6. 
Four-way junction with road junction routes my_junction: junction road_1, road_2, road_3, road_4: road jr_12, jr_34: road r1: map.roads_follow_in_junction(junction: my_junction, in_road: road_1, out_road: road_2, junction_route: jr_12) r3: map.roads_follow_in_junction(junction: my_junction, in_road: road_3, out_road: road_4, junction_route: jr_34) # Note: my_junction.roads is the list [road_1, road_2, road_3, road_4] # Note: r1.resulting_route is a compound route composed of [road_1, jr_12, road_2] # Note: r3.resulting_route is a compound route composed of [road_3, jr_34, road_4] Example 7. 
Junction with lane junction routes my_lane_junction: junction lane_1, lane_2, jr_lane: lane j1: map.roads_follow_in_junction(junction: my_lane_junction, in_lane: lane_1, out_lane: lane_2, junction_route: jr_lane) # Note: lane_1 belongs to the in_road, accessed by j1.in_road # Note: lane_2 belongs to the out_road, accessed by j1.out_road # Note: j1.resulting_route is a compound route composed of [lane_1, jr_lane, lane_2] 8.5.6.1.2 Road within a junction It is possible, geometrically speaking, to have a road and a junction occupy the same space. 
When this occurs, the junction type is a junction_road. 
8.5.6.1.3 Crossings over the top of a junction A crossing may be overlaid anywhere where a lane is present. 
The placement of a crossing allows the placement over the top of a junction where lanes of a road meet up to the junction. 
8.5.6.1.4 Geometric constraints of a junction The geometric constraints of a junction may be included in future versions of ASAM OpenSCENARIO. 
Currently, this is not implemented. 
Junctions may have an impact on s- and t-coordinates. 
This is not included in this version of ASAM OpenSCENARIO. 
8.5.7 Creating compound routes The class compound_route inherits from the class route. 
It has a field route_elements holding an ordered list of route elements. 
This list represents a spatially connected route on the abstract road network. 
Instances of the class compound_route can be created with the following method, which needs to be externally implemented: Code 4. 
Method declaration for creating routes def map.create_route(routes: list of route, connect_points_by: connect_route_points, legal_route: bool) -> compound_route When called the external method is expected to return a compound_route object with a field route_elements by resolving the ordered argument list in the following way: If compound routes are part of the argument list, the method first splits those into their constituting route elements while retaining the order. 
This results in a list that only contains route elements. 
If the resulting list from the last step describes map patterns that are not spatially connected on the abstract road network, the gap(s) of the under-defined route must be filled in an implementation-specific way with any route elements resulting in a spatially connected route. 
If the list of route elements describes patterns that spatially overlap, implementations are free to define further properties as extensions of compound_route. 
The field route_elements of the returned compound_route object gets the value of the (final) list of connecting route elements. 
The other two optional parameters describe how route elements must be connected and if illegal routes may be used (this is false by default). 
The following code snippets create routes. 
Code 5. 
A route with a single type of route element my_road_1, my_road_2, my_road_3: road # Modifiers are used to connect the roads into a road network... 
my_route: route = map.create_route([my_road_1, my_road_2, my_road_3]) In this example, the roads may have some relations specified by constraints or modifiers. 
They may also be anchored on a real map. 
If the route elements listed in the argument are not directly connected, the method implementation is expected to fill the gaps and return a continuous compound route. 
Code 6. 
A route with different types of route elements my_road_1, my_road_2: road my_path: path my_point: xyz_point # Modifiers or methods are used to connect the roads and specify the path and point... 
my_route : map.create_route([my_point, my_road_1, my_path, my_road_2], connect_points_by: lane) In this example, the route elements are of different types, but they all are children of the route_element class. 
The connect_points_by argument specifies how to connect the routable point types to the rest of the route. 
In this case, the second element of the route must be interpreted as the lane that contains my_point. 
If the user does not specify this argument, the method uses the default value. 
For the instantiation of routable points and paths there are dedicated method signatures: create_route_point() create_xyz_point() create_odr_point() create_path() create_path_odr_points() create_path_route_points() For coordinate conversion between different routable point types there are also dedicated method signatures: route_point_to_xyz() xyz_to_route_point() odr_to_route_point() 8.5.7.1. 
roads_follow_in_junction() modifier The modifier map.roads_follow_in_junction() is a modifier that specifies or constrains the connection between route_elements into and out of a junction and optionally some further properties of the corresponding junction. 
Code 7. 
Declaration of the roads_follow_in_junction() modifier map.roads_follow_in_junction(junction: junction, in_road: road, out_road: road, direction: junction_direction, clockwise_count: uint, number_of_roads: uint, in_lane: lane, out_lane: lane, junction_route: route, resulting_route: route) The following code creates a four-way junction with a right-turn route through it. 
Code 8. 
A four-way junction with a right-turn route map: map r1, r2: road my_mod: map.roads_follow_in_junction(in_road: r1, out_road: r2, direction: right, number_of_roads: 4) The resulting route of type compound_route can be accessed with my_mod.resulting_route, which has a list of the following route_elements as a property: [in_road, junction_route, out_road]. 
The junction_route (instantiated by the modifier) represents the spatial connection inside the junction between the inbound and outbound route_element. 
It is accessible via my_mod.junction_route. 
Note that the modifier can automatically instantiate road objects that connect to the junction. 
Those objects are accessible by their symbolic names, using my_mod.in_road and my_mod.out_road. 
The example illustrated this automatic instantiation. 
It is also possible to have roads or lanes as parameters of the modifier, which may be constrained: The following code creates a four-way junction with two-lane roads and a right-turn route through it. 
Code 9. 
A four-way junction with two-lane roads and a right-turn route map: map r3, r4: road with: keep(number_of_lanes == 2) my_mod2: map.roads_follow_in_junction(in_road: r3, out_road: r4, clockwise_count: 3, number_of_roads: 4) This example specifies the same thing and additionally constrains the inbound and outbound roads to two lanes. 
By default the resulting route must be legal. 
If the inbound or the outbound route_element binds to a route_element where the respective movement is illegal, an error message must be raised. 
8.5.7.1.1. 
Using the modifier roads_follow_in_junction() The resulting_route parameter can be used as an input to the create_route() method or directly inside the along() modifier for movable objects to move along. 
Code 10. 
Using resulting route with the modifier along() scenario my_junction_scenario: map: map r1, r2: road my_mod: map.roads_follow_in_junction(in_road: r1, out_road: r2, direction: right, number_of_roads: 4) car_a: vehicle do parallel: car_a.drive() with: along(my_mod.resulting_route) 8.5.7.2 Customized abstract road networks More complex custom modifiers defining compound topologies and potentially usable route_elements inside of it can be built out of smaller modifiers to encapsulate a broader constraint set of the abstract road network. 
An example follows, which is verbally described first: A vehicle v1 moves on roads with at least two lanes each. 
Take the first exit to the right of the first junction, which is a four-way-junction. 
Cross an adjacent arbitrary second junction in an arbitrary way. 
A second vehicle v2 initially moves along a second route that is included in the route of v1. 
Code 11. 
Code for a customized abstract road network and its usage inside a scenario # Define that abstract road network: # Roads, junctions, routes covering several roads modifier map.two_junction_network: r1, r2, r3: road with: keep(min_lanes >= 2) j1, j2: junction f1: roads_follow_in_junction(junction: j1, number_of_in_roads: 4, in_road: r1, out_road: r2, direction: right) f2: roads_follow_in_junction(junction: j2, in_road: r2, out_road: r3) route_a: route = create_route([r1, f1.junction_route, r2, f2.junction_road, r3]) route_b: route = create_route([r1, f2.junction_route, r2]) # Use that modifier scenario traffic.drive_along_two_junctions: map: map net: map.two_junction_network() v1, v2: vehicle do parallel: v1.drive() with: along(net.route_a) serial: v2.drive() with: # Initially drive behind v1 along(net.route_b) position([10m..50m], behind: v1, at: start) ... 
# Then do something else Encapsulating the routing constraints into the map actor via the method application is recommended to enable reusability (see Method application). 
Note that other instances of modifiers like road_follows_in_junction() are nested inside. 
8.5.7.3. 
routes_overlap() modifier The modifier map.routes_overlap() makes it possible to specify two overlapping routes. 
Where the route patterns must overlap, can be specified with the specific parameter overlap_kind. 
This parameter can have one of the following values: equal start end inside Code 12. 
Declaration of the routes_overlap() modifier map.routes_overlap(route1: route, route2: route, overlap_kind: route_overlap_kind) The following code creates a route that is longer than 1000 m, and has a tunnel inside of it. 
Code 13. 
A road with a tunnel r1: route with: keep(length > 1000m) t: route_in_tunnel # assuming a user-defined type route_in_tunnel exists. 
map.routes_overlap(route1: r1, route2: t, overlap_kind: inside) Note that the second route is in the first route. 
A tunnel at the start of the (resulting) route can be specified by changing the overlap_kind from inside to start. 
8.5.7.4. 
routes_are_opposite() modifier The modifier map.routes_are_opposite() makes it possible to specify two routes that are opposite to each other. 
Code 14. 
Declaration of the routes_are_opposite() modifier map.routes_are_opposite(route1: route, route2: route, containing_road: road, lateral_overlap: lateral_overlap_kind) The following code creates a two-way road r1 with opposing lanes that are located adjacent to each other, for example, a typical rural road. 
Code 15. 
A two-way road with opposing lanes map: map r1: road ls1: lane_section with: keep(it.max_lanes == 1) ls2: lane_section with: keep(it.max_lanes == 1) map.routes_are_opposite(route1: ls1, route2: ls2, containing_road: r1, lateral_overlap: never) Only the following route_elements can be arguments to the modifier: lane_section lane compound_lane If a road is input to the modifier, an error must be raised. 
For a bi-directional one-lane road use lateral_overlap: always. 
8.5.8 Crossings A crossing is an overlay or virtual path that acts as a route and has a direct relationship to lanes. 
Figure 20. 
A typical crossing A crossing can be used to represent: A crosswalk within junctions crossing from one sidewalk to another sidewalk. 
An independent crossing in the middle of the road. 
A parking lot, overlaid on top of free space to give a directed path. 
A railroad crossing. 
A crossing has nearly the same characteristics as a lane but is not part of a lane_section or a road. 
A crossing is simply layered on top of route entities if it is "anchored to" a crossing. 
A crossing is very similar to a lane, but is independent of road entities and relies on lane geometry. 
A crossing has a start_lane and end_lane. 
The start_lane anchors the crossing at the centerline of the start_lane. 
The start_lane completes the crossing at the centerline of the end_lane where it completes the connection. 
The origin of a crossing for s-coordinates is determined from a lane centerline and s-position along that line. 
The start_lane assigns the lane that starts the crossing. 
The end_lane assigns the lane that completes the crossing. 
A crossing has a start angle of 90 degrees unless otherwise specified. 
A crossing is always a straight line. 
In the case of straight-line geometry, the crossing ends at the natural connection with end_lane centerline. 
A crossing does not need an angle for where it connects to the end_lane. 
If a single angle and one starting s-dimension are known, then the angle can be calculated, because of the rule of two relative points. 
A crossing does not need an s-dimension for where it connects at the end_lane. 
With the straight-line geometric requirements, the s-dimension can be calculated. 
Figure 21. 
A crossing When a crossing is a route, it can be used in the following way with other lanes or routes: map: map sidewalk1: lane sidewalk2: lane crossing1: crossing with: keep(it.width == 3.5m) map.crossing_connects(crossing1, start_lane: sidewalk1, end_lane: sidewalk2, start_s_coord: 5m, start_angle: 90deg) # may be used without 'start_angle' parameter The origin of a crossing completely overlaps up to the centerline of the s-point of start_lane and is connected or anchored to this lane. 
The centerline of a crossing is always perpendicular to the centerline of the start lane unless an angle is otherwise specified. 
The end point of the crossing centerline must intersect at an s-point found on the centerline of the end lane. 
This is satisfied, no matter what connected angle is possible. 
This connection must ensure that the crossing is created using a straight line. 
A crossing also has a width, which can be used with constraints to specify how big the crossing is. 
The width allows for larger groups of pedestrians or animals to move in either direction. 
8.5.9 s-t-coordinate system for routes In the ASAM OpenSCENARIO abstract road network, lanes constitute the fundamental building block for other map elements. 
The composition diagram below shows how lanes are central to the composition of routes. 
Therefore, the lane is used to define a consistent set of rules to create s-t-coordinates on all the children of route. 
Other details of s-t coordinate systems are found in the coordinate systems section. 
Figure 22. 
Entity overview Each lane has an s-t-coordinate system. 
The s-axis runs along the centerline of the lane. 
The t-axis runs perpendicular to the s-axis. 
The s-t-coordinate system follows the right-hand rule. 
By default, uni-directional lanes shall have legal traffic moving in the positive s-direction. 
Lanes are arranged side-by-side to make a lane_section. 
The lane section also has an s-t-coordinate system. 
The s-t-axes for the lane section coincide with s-t-axes of the lane chosen in the lane_section.s_axis field. 
Lane sections are arranged end-to-end to make a road. 
The road also has an s-t-coordinate system. 
The s-axis of the road is formed by the succession of the s-axes of the lane sections that compose the road. 
The t-axis for the road runs perpendicular to the s-axis, following the right-hand rule. 
A crossing has an s-t-coordinate system, defined similarly to the s-t-coordinate system for the lane. 
Each compound_route has an s-t-coordinate system. 
This coordinate system is built following the same rules as for a lane. 
Routes that are inside of junctions (like the junction_route parameter in the roads_follow_in_junction() modifier) are instances of the route types mentioned above, and therefore follow the corresponding rules to establish their s-t coordinate system. 
8.4 Actions and modifiers 8.6 Behavioral model

8.6 Behavioral model
8.6 Behavioral model 8.6.1 Overview This chapter explains the main qualities of behavioral models. 
The key functionality of behavioral models is to connect the scenario description with external assets that are dynamically involved during the execution of the scenario. 
Once a scenario has been described in ASAM OpenSCENARIO, an implementation should be able to execute the scenario. 
For such execution, the behavioral characteristics of each actor must be realized. 
This can be achieved by using models in simulation, with real hardware, or as a combination of both. 
A scenario could be executed in various ways, including but not limited to: In a simulation, using simple kinematic models In a simulation, using complex dynamic models With a human driver in a driving simulator On a closed proving ground with real vehicles In any of these cases, there are behavioral aspects of the scenario actors that are implementation-specific and therefore fall beyond the scope of ASAM OpenSCENARIO. 
But sometimes it may be practical, or even essential, to include some of these characteristics in the scenario description. 
ASAM OpenSCENARIO behavioral models allow users to connect their scenario description to implementation-specific details that influence actor behavior. 
Some possible use cases of behavioral models include but are not limited to: Select a dynamic model to realize the behavioral characteristics of an actor. 
Adjust the parameters of a dynamic model used in scenario simulation. 
Assign external modules to control the motion of an actor. 
Expose internal signals of an actor implementation to use them in the scenario description. 
8.6.1.1 Key characteristics All physical actors have behavioral models. 
Note that such a behavioral model can either refer to the dynamic model that implements the behavior of an actor, to a controller that guides an actor to execute the scenario instructions, or a combination of both. 
Therefore, a fully-controlled behavioral model is also considered a behavioral model. 
All behavioral models are implementation-specific. 
Each actor has an initial_bm field. 
The initial_bm field can be set using constraints, or it may be left unspecified by the user. 
The default value is implementation-specific. 
It supports most of the behavior modifiers as specified. 
The initial_bm field can be changed on the fly using the action set_bm(). 
Individual fields inside the initial_bm can also be changed using user-defined actions. 
The behavioral model for a vehicle could have parameters influencing the behavior of the vehicle. 
For example: Driver aggressiveness, or other user-defined driver attributes Tire properties, or other attributes affecting the dynamic response of the vehicle Sub-objects (see Section 8.6.2, “Data structures”) The following information is not contained in the behavioral model: The motion states (position, speed, acceleration) of the actor. 
These are part of the standard ASAM OpenSCENARIO domain model. 
8.6.2 Data structures 8.6.2.1 Defining a specific behavioral model An ASAM OpenSCENARIO behavioral model is a struct that can be expanded by the user. 
Code 1. 
Behavioral models struct struct behavioral_model: bm_engine: bm_engine # Reference to the "behavioral model engine" Based on this base behavioral_model class, users are free to define their own classes by inheriting from it. 
Code 2. 
User-defined behavioral model classes struct vehicle_bm inherits behavioral_model: # More fields defined by the users... 
struct fully_controlled_vehicle_bm inherits vehicle_bm: # More fields defined by the users... 
How to define a specific new behavioral model: Code 3. 
Specifying a new behavioral model struct sumo_idm_bm inherits behavioral_model: tau: time # More fields defined by the users... 
8.6.2.2 Behavioral model engine Behavioral models have a reference to their behavioral model engine. 
The behavioral model engine provides the actual implementation of the behavioral model. 
The bm_engine field is a reference to the ASAM OpenSCENARIO object representing the bm_engine, whose content is implementation-specific. 
An example is keep(my_bm.bm_engine == bm_engines.sumo_bm_engine_object). 
8.6.2.3 Splitting into sub-structs You can split the vehicle_bm into multiple sub-structs. 
Please note that the following code is just an example. 
The ASAM OpenSCENARIO domain model does not define an obligatory structure of vehicle_bm. 
Code 4. 
Splitting into sub-structs da_model, lld_model, sb_model, lc_model: behavioral_model struct vehicle_bm inherits behavioral_model extend vehicle_bm: driver_like_attributes: da_model low_level_dynamics: lld_model signaling_behavior: sb_model lateral_controller: lc_model These sub-structs could refer to aspects of the behavioral model. 
Users and implementers are free to define the structure and functionality that suits their particular needs. 
Even if the behavioral model is split into sub-structs, they are still encapsulated within a single behavioral model object. 
Because of that, the user can set the behavioral model using a single constraint or action (see Section 8.6.3, “Examples”). 
8.6.3 Examples 8.6.3.1. 
Using initial_bm and set_bm() This example changes the whole behavioral model of v2 at once. 
Code 5. 
Changing the behavioral model for a vehicle scenario top.foo: my_sumo_bm: sumo_idm_bm with: keep(tau == 2.2s) my_sumo_bm_2: sumo_idm_bm with: keep(tau == 3.0s) car: vehicle with: keep(initial_bm == my_sumo_bm) # This is the initial BM for v2 do serial: car.drive() # Using the initial BM my_sumo_bm car.set_bm(my_sumo_bm_2) # Change the BM for my_sumo_bm_2 car.drive() # Using the new BM 8.6.3.2. 
Using specific set_bm methods Sometimes you may want to change just a single field of the behavioral model, like the signaling_behavior sub-struct or even just the signaling_behavior.avoid_signaling fields. 
This is possible because of specific set_bm_*() methods for the different fields. 
Now you can change the previous example: Code 6. 
Without set_bm method v2.set_bm(my_sumo_bm_2) # Change the BM for v2 Code 7. 
With set_bm method v2.set_bm_avoid_signaling(true) # Set that specific field to true You can also use v2.set_bm_signaling_behavior() to set the whole struct. 
This replaces either the previous value of the struct or the null value that was there before. 
8.6.3.3 Vehicles in a vehicle group This is how the behavioral model for vehicles in a vehicle group can be set. 
Code 8. 
Vehicles in a vehicle group g: vehicle_group for c in g.cars: keep(c.initial_bm == my_bm) 8.6.3.4 Motion controller This is how a user can set a behavioral model to establish the status of longitudinal and lateral motion control for an actor. 
Code 9. 
Motion controller motion_control inherits behavioral_model: longitudinal: bool lateral: bool my_controller: motion_control with: keep(longitudinal == True) keep(lateral == True) my_controlled_car: vehicle with: keep(initial_bm == my_controller) 8.6.3.5 Assistive device This is how the behavioral model for vehicles in a vehicle group can be set. 
Code 10. 
Vehicles in a vehicle group adas_device inherits behavioral_model: driver_setting: enum[off, on] current_status: enum[off, standby, engaged] my_adas: adas_device adas_car: vehicle with: keep(initial_bm == my_adas) do serial: adas_car.set_bm_driver_setting(off) adas_car.drive() adas_car.set_bm_driver_setting(on) adas_car.drive() 8.5 Abstract road network 8.7 Physical object actors

8.7 Physical object actors
8.7 Physical object actors 8.7.1 Physical objects 8.7.2 Actor physical_object All tangible objects close to earth, excluding celestial objects such as sun or moon. 
Basic information Table 13. 
Basic information of actor physical_object Instantiable no Parents osc_actor Children movable_object, stationary_object Parameters Table 14. 
Actor physical_object Parameter Type Mandatory Description bounding_box bounding_box yes See bounding_box color color no See color geometry_reference string no Opaque reference of an associated 3D geometry model of the physical object. 
It is implementation-specific how model references are resolved to 3D models. 
center_of_gravity position_3d yes Center of gravity of the object. 
If unknown, the center of the bounding box may be used instead. 
State variables Table 15. 
State variables of actor physical_object Variable Type Mandatory Description pose pose_3d yes Position and orientation measured in world coordinates with world system as reference. 
8.7.2.1 Methods 8.7.2.1.1 Method object_distance() Returns the relative distance between the physical_object that calls the method and a reference entity. 
The distance is computed as the position of the reference entity, measured in the coordinate system of the physical_object that calls the method. 
This calculation is performed either in the longitudinal direction (x-axis) or the lateral direction (y-axis). 
By default, the distance is measured between the reference points of the respective entities. 
Optionally, the distance between the bounding boxes can be computed instead. 
Prototype extend physical_object: def object_distance(reference: physical_object, direction: distance_direction, mode: distance_mode) -> length Return value The relative distance between the physical_object that calls the method and the reference entity. 
Parameters Table 16. 
Parameters for method object_distance() Parameter Type Description reference physical_object The reference entity. 
direction distance_direction Use longitudinal to measure the distance in the x-coordinate. 
Use lateral to measure the distance in the y-coordinate. 
mode distance_mode Use reference_points to measure the distance between the reference points. 
(Default) Use bounding_boxes to measure the distance between the bounding boxes. 
8.7.2.1.2 Method get_s_coord() Returns the s-coordinate of the physical_object. 
By default, the method uses the s-axis of the road where the physical_object is located, but the user can select other route element types. 
If the physical_object is not on a route the method returns an error. 
Prototype extend physical_object: def get_s_coord(route_type: on_route_type) -> length Return value Returns a length with the s-coordinate. 
Parameters Table 17. 
Parameters for method get_s_coord() Parameter Type Description route_type on_route_type Select the type of route that will be used to compute the s-coordinate: on_road (default) Use the s-axis of the road where the actor is located. 
If the actor is not on a road the method returns an error. 
on_lane_section Use the s-axis of the lane_section where the actor is located. 
If the actor is not on a lane section the method returns an error. 
on_lane Use the s-axis of the lane where the actor is located. 
If the actor is not on a lane the method returns an error. 
on_crossing Use the s-axis of the crossing where the actor is located. 
If the actor is not on a crossing the method returns an error. 
8.7.2.1.3 Method get_t_coord() Returns the t-coordinate of the physical_object. 
By default, the method uses the t-axis of the road where the physical_object is located, but the user can select other route element types. 
If the physical_object is not on a route the method returns an error. 
Prototype extend physical_object: def get_t_coord(route_type: on_route_type) -> length Return value Returns a length with the t-coordinate. 
Parameters Table 18. 
Parameters for method get_t_coord() Parameter Type Description route_type on_route_type Select the type of route that will be used to compute the t-coordinate: on_road (default) Use the t-axis of the road where the actor is located. 
If the actor is not on a road the method returns an error. 
on_lane_section Use the t-axis of the lane_section where the actor is located. 
If the actor is not on a lane section the method returns an error. 
on_lane Use the t-axis of the lane where the actor is located. 
If the actor is not on a lane the method returns an error. 
on_crossing Use the t-axis of the crossing where the actor is located. 
If the actor is not on a crossing the method returns an error. 
8.7.2.1.4 Method get_route_point() Returns the route_point where the physical_object is located. 
By default, the method uses the road where the physical_object is located, but the user can select other route element types. 
If the physical_object is not on a route the method returns an error. 
Prototype extend physical_object: def get_route_point(route_type: on_route_type) -> route_point Return value Returns a route_point. 
Parameters Table 19. 
Parameters for method get_route_point() Parameter Type Description route_type on_route_type Select the type of route that will be used to compute the route_point: on_road (default) Use the t-axis of the road where the actor is located. 
If the actor is not on a road the method returns an error. 
on_lane_section Use the t-axis of the lane_section where the actor is located. 
If the actor is not on a lane section the method returns an error. 
on_lane Use the t-axis of the lane where the actor is located. 
If the actor is not on a lane the method returns an error. 
on_crossing Use the t-axis of the crossing where the actor is located. 
If the actor is not on a crossing the method returns an error. 
8.7.2.2 Examples Code 1. 
Syntax examples for physical_object # Constrain vehicle to be a wide car my_wide_car: vehicle keep(my_wide_car.vehicle_category == car) keep(my_wide_car.bounding_box.width >= 1.95m) keep(my_wide_car.color == maroon) keep(my_wide_car.axles.size() == 2) keep(my_wide_car.axles[0].number_of_wheels == 2) keep(my_wide_car.axles[1].number_of_wheels == 2) keep(my_wide_car.intended_infrastructure[0] == driving) # Constrain vehicle to be a motorcycle my_motorcycle: vehicle keep(my_motorcycle.vehicle_category == vru_vehicle) keep(my_motorcycle.axles.size() == 2) keep(my_motorcycle.axles[0].number_of_wheels == 1) keep(my_motorcycle.axles[1].number_of_wheels == 1) keep(my_motorcycle.intended_infrastructure[0] == driving) # Constrain vehicle to be a bicycle my_bicycle: vehicle keep(my_bicycle.vehicle_category == vru_vehicle) keep(my_bicycle.axles.size() == 2) keep(my_bicycle.axles[0].number_of_wheels == 1) keep(my_bicycle.axles[1].number_of_wheels == 1) keep(my_bicycle.intended_infrastructure[0] == biking) 8.7.3 Actor stationary_object A stationary_object is a physical_object that is anchored and whose bounding box cannot change its position or speed like a tree or a building. 
Basic information Table 20. 
Basic information of actor stationary_object Instantiable yes Parents physical_object Inherited parameters and variables Table 21. 
Inherited parameters and variables of actor stationary_object Parent Inherited parameters and variables physical_object pose, bounding_box, color, geometry_reference, center_of_gravity 8.7.3.1 Modifiers 8.7.3.1.1 Modifier location() Specifies the location of a stationary_object. 
Shall be invoked before the do section, as the location cannot be time-dependent. 
Parameters Table 22. 
Parameters for modifier stationary_object.location() Parameter Type Description pose pose_3d Location of the stationary object for the whole scenario. 
Syntax Code 2. 
Syntax examples for stationary_object.location() my_pose: pose_3d # Add constraints for fields of my_pose my_building: stationary_object my_building.location(my_pose) do: ... 
8.7.4 Actor movable_object A movable_object is a physical_object that is not anchored and can, therefore, be moved and change its position and speed like a rock or a ball. 
Basic information Table 23. 
Basic information of actor movable_object Instantiable yes Parents physical_object Children traffic_participant State variables Table 24. 
State variables of actor movable_object Variable Type Mandatory Description velocity velocity_6d yes Translational and rotational velocity measured in object coordinates with world system as reference. 
acceleration acceleration_6d yes Translational and rotational acceleration measured in object coordinates with world system as reference. 
speed speed yes Speed in center_of_gravity defined as sqrt(velocity.translational.x² + velocity.translational.y²) * sign(velocity.translational.x) Inherited parameters and variables Table 25. 
Inherited parameters and variables of actor movable_object Parent Inherited parameters and variables physical_object pose, bounding_box, color, geometry_reference, center_of_gravity 8.7.4.1 Methods 8.7.4.1.1 Method distance_along_route() Returns the distance between an actor and the start or end of a route, measured along the s-axis of the route. 
User can pass either a route_element or a compound_route. 
Prototype extend traffic_participant: def distance_along_route(route: route, from: route_distance_enum) -> length Return value Returns a length measured along the s-axis of the route. 
Parameters Table 26. 
Parameters for method distance_along_route() Parameter Type Description route route The route along which the distance should be measured. 
If the actor calling the method is not on the given route the method returns an error. 
from route_distance_enum Reference point from which the distance is measured. 
from_start (default) Method returns the relative s-coordinate from route.start_point() to the actor. 
Positive means that the traffic participant is ahead of the start point. 
from_end Method returns the relative s-coordinate from the actor to the route.end_point(). 
Positive means that the traffic participant is behind of the end point. 
8.7.5 Actor traffic_participant A traffic_participant is a physical_object that is relevant within traffic and may perform traffic-related actions (see traffic_participant actions) such as following a route. 
A traffic_participant includes both, objects that do participate in traffic actively like a driven vehicle and objects that do not move throughout the scenario like a parked vehicle. 
Basic information Table 27. 
Basic information of actor traffic_participant Instantiable no Parents movable_object Children animal, person, vehicle Parameters Table 28. 
Actor traffic_participant Parameter Type Mandatory Description intended_infrastructure list of intended_infrastructure yes See intended_infrastructure for definition. 
Intended usage is for further specification of an entity. 
For example, together with vehicle_category or to provide hints for implemenations where to spawn and / or auto-route entities. 
Note that multiple types of infrastructure can be assigned because of the list character of this type. 
Inherited parameters and variables Table 29. 
Inherited parameters and variables of actor traffic_participant Parent Inherited parameters and variables movable_object velocity, acceleration, speed physical_object pose, bounding_box, color, geometry_reference, center_of_gravity 8.7.5.1 Methods 8.7.5.1.1 Method time_to_collision() Returns the time that is left until a possible collision between a traffic_participant and a reference physical_object takes place. 
Prototype extend traffic_participant: def time_to_collision(reference: physical_object) -> time Return value Returns the time until the bounding_box of traffic_participant would collide with the bounding box of the reference physical_object, assuming both keep moving with their current velocity. 
Parameters Table 30. 
Parameter for method time_to_collision() Parameter Type Description reference physical_object The reference physical_object. 
Syntax Code 3. 
Syntax example for method time_to_collision() scenario prevent_collision: ego: vehicle other_car: vehicle var collision_time: time = sample(ego.time_to_collision(reference: other_car), every(2s)) do parallel: other_car.drive() with: speed(50kph) ego.drive() with: position(behind: other_car) until rise(collision_time  time Return value Returns the time distance between traffic participant and reference physical_object, measured from reference point to reference point along s-coordinate, assuming the reference physical_object keeps moving with its current speed. 
Parameters Table 31. 
Parameter for method time_headway() Parameter Type Description reference physical_object The reference physical_object. 
8.7.5.1.3 Method space_gap() Returns the space distance between a traffic participant and a reference physical_object. 
Prototype extend traffic_participant: def space_gap(reference: physical_object, direction: distance_direction) -> length Return value Returns the space distance between the bounding_box of the traffic_participant that calls the method and the reference physical_object. 
Parameters Table 32. 
Parameters for method space_gap() Parameter Type Description reference physical_object The reference entity. 
direction distance_direction longitudinal The relative s-coordinate. 
Positive means that the traffic participant is ahead of the reference. 
lateral The relative t-coordinate. 
Positive means that the traffic participant is left of the reference. 
8.7.6 Actor vehicle A device intended for transport of people or cargo. 
Here restricted to land vehicles, meaning vehicles that move on a land surface such as a road or sidewalk. 
Basic information Table 33. 
Basic information of actor vehicle Instantiable yes Parents traffic_participant Parameters Table 34. 
Actor vehicle Parameter Type Mandatory Description vehicle_category vehicle_category yes See vehicle_category axles list of axle yes See axle rear_overhang length yes Rear overhang of the vehicle or more explicitly the horizontal distance between the end of the bounding_box and the center of the rear axle. 
Inherited parameters and variables Table 35. 
Inherited parameters and variables of actor vehicle Parent Inherited parameters and variables movable_object velocity, acceleration, speed physical_object pose, bounding_box, color, geometry_reference, center_of_gravity traffic_participant intended_infrastructure 8.7.7 Actor person A person represents a human being. 
A person may act in different and changing modalitites throughout a scenario. 
For example, walking or being in a car. 
Basic information Table 36. 
Basic information of actor person Instantiable yes Parents traffic_participant Inherited parameters and variables Table 37. 
Inherited parameters and variables of actor person Parent Inherited parameters and variables movable_object velocity, acceleration, speed physical_object pose, bounding_box, color, geometry_reference, center_of_gravity traffic_participant intended_infrastructure 8.7.8 Actor animal An animal represents a living being which is not a human. 
An animal may act in different and changing modalitites throughout a scenario. 
For example, running or being in a car. 
Basic information Table 38. 
Basic information of actor animal Instantiable yes Parents traffic_participant Inherited parameters and variables Table 39. 
Inherited parameters and variables of actor animal Parent Inherited parameters and variables movable_object velocity, acceleration, speed physical_object pose, bounding_box, color, geometry_reference, center_of_gravity traffic_participant intended_infrastructure 8.7.9 Struct bounding_box Simplified three dimensional shape enclosing the physical_object. 
The bounding box does NOT include side mirrors for vehicles. 
The height includes the ground_clearance, therefore it always goes from the top to the ground. 
Basic information Table 40. 
Basic information of struct bounding_box Instantiable no Parameters Table 41. 
Struct bounding_box Parameter Type Mandatory Description center position_3d yes Represents the geometrical center of the bounding box expressed in coordinates that refer to the coordinate system of the physical_object length length yes Dimension in x-direction of the coordinate system of the physical_object width length yes Dimension in y-direction of the coordinate system of the physical_object height length yes Dimension in z-direction of the coordinate system of the physical_object 8.7.10 Struct axle Taken from ASAM OpenSCENARIO 1.x plus number of wheels to avoid ambiguities (for example, twin tires). 
Check definitions there for now. 
Basic information Table 42. 
Basic information of struct axle Instantiable no Used by vehicle Parameters Table 43. 
Struct axle Parameter Type Mandatory Description max_steering angle yes Maximum steering angle for the wheels on the axle wheel_diameter length yes Diameter for the wheels on this axle track_width length yes Distance between the centerline of the outer wheels on opposing sides of the axle position_x length yes Longitudinal position of the axle in the vehicle ' s x-axis. 
For a 2-axle vehicle, the rear axle must have position_x = 0m position_z length yes Longitudinal position of the axle in the vehicle ' s z-axis number_of_wheels uint yes Number of wheels on the axle 8.7.11 Enum color Description of the color of a physical_object. 
Specifies the color of a physical object. 
Not intended to replace more detailed material properties, but rather for debugging purposes. 
For a vehicle this should affect the vehicle body, for pedestrians it may affect the main piece of clothing. 
Based on the set defined by W3C for HTML_ "basic colors". 
Basic information Table 44. 
Basic information of enum color Instantiable no Values Table 45. 
Enum color Value Comment white RGB(255,255,255) silver RGB(192,192,192) gray RGB(128,128,128) black RGB(0,0,0) red RGB(255,0,0) maroon RGB(128,0,0) yellow RGB(255,255,0) olive RGB(128,128,0) lime RGB(0,255,0) green RGB(0,128,0) aqua RGB(0,255,255) teal RGB(0,128,128) blue RGB(0,0,255) navy RGB(0,0,128) fuchsia RGB(255,255,0) purple RGB(255,0,255) 8.7.12 Enum vehicle_category Vehicle category based on UN ECE/TRANS/WP.29/78/Rev.6 extended by non-self-propelled vehicles. 
Basic information Table 46. 
Basic information of enum vehicle_category Instantiable no Used by vehicle Values Table 47. 
Enum vehicle_category Value Comment car Power-driven vehicle with maximum mass not exceeding 3.5 t having at least four wheels comprising not more than eight seats in addition to the driver seat. 
Designed for the carriage of passengers or small goods. 
(UN category L7,M1,N1) bus Power-driven vehicle having at least four wheels comprising more than eight seats in addition to the driver seat.(UN category M2,M3) truck Power-driven vehicle with maximum mass exceeding 3.5t having at least four wheels. 
Designed for the carriage of goods. 
(UN category N2,N3) trailer Vehicle designed to be towed by another vehicle. 
Non-permanently connected to towing vehicle, meaning it can be separated by an operation without involving facilities normally only found in workshop. 
vru_vehicle Vehicle without a crash-resistant passenger cell intended for one to few passengers or small goods transport. 
With its occupant it results in a vulnerable road user. 
(UN category L1-L6 plus bicycles, pedelecs, e-bicycles, personal mobility devices, wheelchairs, mobility scooters and so on.) other Unspecified but known type of vehicle (for example, stroller, shopping cart, …​) 8.7.13 Enum intended_infrastructure Infrastructure that is typically used by a traffic participant. 
Can be used to further specify an entity. 
For example, together with vehicle_category or to provide hints for simulators where to spawn entities. 
Each entity can be assigned multiple values. 
Note that this needs to be aligned with road abstraction feature. 
Basic information Table 48. 
Basic information of enum intended_infrastructure Instantiable no Used by traffic_participant Values Table 49. 
Enum intended_infrastructure Value Comment driving taken from ASAM OpenDRIVE sidewalk A lane meant for people to walk on. 
Taken from ASAM OpenDRIVE biking taken from ASAM OpenDRIVE rail taken from ASAM OpenDRIVE tram taken from ASAM OpenDRIVE bus taken from ASAM OpenDRIVE taxi taken from ASAM OpenDRIVE hov taken from ASAM OpenDRIVE 8.7.14 Enum distance_direction Basic information Table 50. 
Basic information of enum distance_direction Used by keep_space_gap Values Table 51. 
Enum distance_direction Value Comment longitudinal Measure distance in the x-coordinate. 
Positive means that the reference is in front of the physical_object that calls the method. 
lateral Measure distance in the y-coordinate. 
Positive means that the reference is to the left of the physical_object that calls the method. 
8.7.15 Enum distance_mode Values Table 52. 
Enum distance_mode Value Comment reference_points Measure the distance between the reference points. 
bounding_boxes Measure the distance between the bounding boxes. 
8.7.16 Enum on_route_type Select which s/t coordinate system is used to obtain the coordinates Values Table 53. 
Enum on_route_type Value Comment on_road Use the road s/t coordinates on_lane_section Use the lane_section s/t coordinates on_lane Use the lane s/t coordinates on_crossing Use the crossing s/t coordinates 8.7.17 Enum route_distance_enum Reference point from which the distance is measured. 
Values Table 54. 
Enum route_distance_enum Value Comment from_start Measure distance from the start of the route. 
from_end Measure distance from the end of the route. 
8.7.18 Groups of traffic participants Please note that the following section and its sub-sections are non-normative. 
Many implementations for the creation and the handling of groups of traffic participants exist. 
Some traffic flow simulators use stochastic traffic flow models and others use deterministic modeling approaches. 
The following content is an example on how to build groups using only generic ASAM OpenSCENARIO language features. 
A standard group model may be included in future versions of the standard. 
Groups represent multiple actor instances with multiple definitions and states. 
It is assumed that scenario authors will likely define groups at the top level and not under lower levels in the domain model hierarchy such as physical_actor. 
8.7.18.1 Actor vehicle_group A traffic_participant_group serves as a collection of traffic_participant actors. 
A group represents multiple actor instances with multiple definitions and states. 
There are two main use cases for vehicle groups: Adding entities to a scenario to have more participants in the scenario. 
By generating multiple vehicles in the surrounding environment of the scenario these vehicles act as 'noise' in the scenario. 
Creating multiple vehicles with predefined initial conditions. 
For example, creating a single-lane or convoy formation of vehicles, or both. 
Initial conditions of actors and the actual behavior of actors throughout the scenarios differ: The group defines the initial conditions of actors in the scenario, meaning their creation and destruction. 
The behavioral model assigned to each vehicle defines the actual behavior of the vehicle within the group. 
Basic information Table 55. 
Basic information of actor vehicle_group Instantiable no Parents traffic_participant_group Children common_route_vehicle_group, random_traffic_vehicle_group Parameters Table 56. 
Actor vehicle_group Parameter Type Mandatory Description vehicles list of vehicle yes List of vehicles being part of this group. 
8.7.18.1.1 Examples Code 4. 
Example for vehicle_group scenario dut.driving_alongside_group: # Defining a group with a common route and # a single-lane formation g: single_lane_vehicle_group # Using 'for' constraint to control vehicles # parameters for v in g.vehicles: keep(v.category in [bus, truck]) r: route do parallel: g.drive() with: along(r) lane(side_of: dut.vehicle, at: start) dut.vehicle.drive() with: along(r) 8.6 Behavioral model 8.8 Movement actions

8.8 Movement actions
8.8 Movement actions 8.8.1 Action parent class All actions have the properties stipulated in the language section on actions. 
These include pre-defined events like start, end, and fail events, as well as the optional duration parameter. 
Actions can also be associated with an actor. 
The parent action osc_action is the base class for all actions in the ASAM OpenSCENARIO domain model and it is associated with the parent actor osc_actor. 
This allows users to make user-defined extensions of osc_action that can propagate common properties to all standard actions. 
In addition, users can create their own actions and are free to choose whether those user-defined actions inherit from osc_action or not. 
The action action_for_movable_object is the base class for all movement-related actions and modifiers. 
Actions for actors that are children of movable_object, like vehicle or person, inherit from action_for_movable_object. 
This allows users to extend these abstract classes, adding common action parameters at different levels within the standard action hierarchy. 
Furthermore, it allows users to place their user-defined actions at an appropriate location within the standard action hierarchy, depending on which types of actors are intended to execute each action. 
Generic movement actions have the following inheritance structure: The definition of each data class can be found in the next sections. 
8.8.1.1 Action osc_action Basic information Table 57. 
Basic information of action osc_action Children action_for_environment, action_for_movable_object Used by OpenSCENARIO Parameters Table 58. 
Action osc_action Parameter Type Mandatory Description duration time no This parameter is part of all action types. 
Constrains the total time for the execution of this action 8.8.2 Actions for movable object The movable_object class is a parent for any physical object that could change position during a scenario. 
This section defines the actions that can be executed by actors of the movable_object type or any of its children like vehicle, person, and animal. 
movable_object encompasses a wide subset of children. 
It has a variety of actions available to specify their motion. 
The actions that can be executed by movable_object types and their children can be split in two groups: Section 8.8.2.1, “Exact behavior” Actions where the priority is to achieve the exact values that are specified in the action parameters, regardless of the physical movement constraints of the actor. 
Section 8.8.2.2, “Target behavior” Actions where the priority is to respect the physical movement constraints of the actor, while getting as close as possible to the target values that are specified in the action parameters. 
This distinction can be explicitly stated using the physical_movement() modifier. 
See section Modifier 'physical_movement()' for details. 
8.8.2.1 Exact behavior Figure 23. 
Actions that prioritize exact reproduction Figure 23 shows the actions that prioritize exact reproduction. 
These actions use the semantics of the modifier physical_movement(prefer_non_physical). 
For the execution of these actions an ASAM OpenSCENARIO implementation may choose to violate the physical movement constraints of the actor. 
8.8.2.2 Target behavior Figure 24. 
Actions that prioritize respecting physical movement constraints Figure 24 shows actions that prioritize respecting the physical movement constraints of the actor. 
These actions use the semantics of the modifier physical_movement(must_be_physical). 
The physical movement constraints of the actor shall not be violated while executing these actions. 
The actor should get as close as possible to the target values specified in the action parameters. 
When a scenario is executed, there may be a difference between the observed motion values and the target values. 
These discrepancies might also depend on the type of execution platform. 
For example, a simple dynamic simulation compared to a complex dynamic simulation or real vehicle on a test track. 
8.8.2.3 Action move Generic action to initiate the motion of movable objects. 
Usually invoked in combination with modifiers. 
Note that different movable objects have different move actions like drive and walk. 
The nature of the movement is modified according to the moving actor. 
For example, a vehicle.drive will drive as a vehicle according to road network Basic information Table 59. 
Basic information of action move Parents action_for_movable_object Controlled states None directly. 
Depends on the modifiers Action ending The action ends when the phase in which the action is invoked is terminated. 
Inherited parameters and variables Table 60. 
Inherited parameters and variables of action move Parent Inherited parameters and variables osc_action duration 8.8.2.3.1 Examples Code 1. 
Usage of move movable_object.move([, ]) Code 2. 
Examples for move # Move at 10 kph, with starting position relative to my_car my_box.move() with: position(10m, ahead_of: my_car, at: start) lateral(2m, side: left, side_of: my_car, at: start) speed(10kph) # Move to position in front of my_car and stop, with duration 3 seconds my_box.move(duration: 3s) with: speed(0kph, at: end) position(3m, ahead_of: my_car, at: end) lateral(0.2m, side_of: my_car, at: end) 8.8.2.4 Action assign_position Move actor to the specified position as soon as possible. 
The dynamic limits of the actor may be violated to execute this action. 
Use only one of the three possible arguments. 
Basic information Table 61. 
Basic information of action assign_position Parents action_for_movable_object Controlled states Only the position states that are specified in the invocation Action ending The action ends when the actor reaches the specified position coordinates Parameters Table 62. 
Action assign_position Parameter Type Mandatory Description position position_3d no Desired 3-dimentional position assigned by the user route_point route_point no Desired route_point assigned by the user odr_point odr_point no Desired odr_point assigned by the user Inherited parameters and variables Table 63. 
Inherited parameters and variables of action assign_position Parent Inherited parameters and variables osc_action duration 8.8.2.4.1 Examples Code 3. 
Usage of assign_position movable_object.assign_position(position: position_3d [, ]) movable_object.assign_position(route_point: route_point [, ]) movable_object.assign_position(odr_point: odr_point [, ]) Code 4. 
Semantic clarification action movable_object.assign_position: position: position_3d route_point: route_point odr_point: odr_point # The position() and lateral() modifiers use route coordinates # Convert position or odr_point arguments to route_point if odr_point: route_point: route_point = map.odr_to_route_point(odr_point.road_id, odr_point.lane_id, odr_point.s, odr_point.t) else if position: route_point: route_point = map.xyz_to_route_point(position.x, position.y, position.z) do move() with: along(route_point.route) position(route_point.s, at: end) lateral(route_point.t, at: end) physical_movement(prefer_non_physical) Code 5. 
Examples for assign position # Using global x-y-z coordinates my_pos: position_3d # Add constraints for fields of my_pos do: my_car.assign_position(my_pos) # Same as: my_car.assign_position(position: my_pos) # Using route s-t coordinates my_st: route_point # Add constraints for fields of my_st do: my_car.assign_position(route_point: my_st) # Using odr coordinates my_car: vehicle my_odr: odr_point # Add constraints for fields of my_odr do: my_car.assign_position(odr_point: my_odr) 8.8.2.5 Action assign_orientation Move actor to the specified orientation as soon as possible. 
The dynamic limits of the actor may be violated to execute this action. 
Basic information Table 64. 
Basic information of action assign_orientation Parents action_for_movable_object Controlled states Only the orientation states that are specified in the invocation Action ending The action ends when the actor reaches the specified orientation coordinates Parameters Table 65. 
Action assign_orientation Parameter Type Mandatory Description orientation orientation_3d yes Desired 3-dimentional orientation assigned by the user Inherited parameters and variables Table 66. 
Inherited parameters and variables of action assign_orientation Parent Inherited parameters and variables osc_action duration 8.8.2.5.1 Examples Code 6. 
Usage of assign_orientation movable_object.assign_orientation(orientation: orientation_3d [, ]) Code 7. 
Semantic clarification action movable_object.assign_orientation: orientation: orientation_3d do move() with: orientation(yaw: orientation.yaw, pitch: orientation.pitch, roll: orientation.roll, at: end) physical_movement(prefer_non_physical) Code 8. 
Examples for assign orientation my_orientation: orientation_3d # Add constraints for fields of my_orientation do: my_car.assign_orientation(my_orientation) # Same as: my_car.assign_orientation(orientation: my_orientation) 8.8.2.6 Action assign_speed Move actor to achieve the specified scalar speed as soon as possible. 
The dynamic limits of the actor may be violated to execute this action. 
Basic information Table 67. 
Basic information of action assign_speed Parents action_for_movable_object Controlled states Scalar longitudinal speed of actor Action ending The action ends when the actor reaches the specified velocity value Parameters Table 68. 
Action assign_speed Parameter Type Mandatory Description speed speed yes Desired (scalar) speed assigned by the user Inherited parameters and variables Table 69. 
Inherited parameters and variables of action assign_speed Parent Inherited parameters and variables osc_action duration 8.8.2.6.1 Examples Code 9. 
Usage of assign_speed movable_object.assign_speed(speed: speed [, ]) Code 10. 
Semantic clarification action movable_object.assign_speed: speed: speed do move() with: speed(speed, at: end) physical_movement(prefer_non_physical) Code 11. 
Examples for assign speed my_car.assign_speed(35kph) my_car.assign_speed(speed: 35kph) 8.8.2.7 Action assign_acceleration Move actor to achieve the specified acceleration as soon as possible. 
The dynamic limits of the actor may be violated to execute this action. 
Basic information Table 70. 
Basic information of action assign_acceleration Parents action_for_movable_object Controlled states Scalar longitudinal acceleration of actor Action ending The action ends when the actor reaches the specified acceleration value Parameters Table 71. 
Action assign_acceleration Parameter Type Mandatory Description acceleration acceleration yes Desired (scalar) acceleration assigned by the user Inherited parameters and variables Table 72. 
Inherited parameters and variables of action assign_acceleration Parent Inherited parameters and variables osc_action duration 8.8.2.7.1 Examples Code 12. 
Usage of assign_acceleration movable_object.assign_acceleration(acceleration: acceleration[, ]) Code 13. 
Semantic clarification action movable_object.assign_acceleration: acceleration: acceleration do move() with: acceleration(target, at: end) physical_movement(prefer_non_physical) Code 14. 
Examples for assign acceleration my_car.assign_acceleration(1.0mpsps) my_car.assign_acceleration(acceleration: 1.0mpsps) 8.8.2.8 Action replay_path The actor moves along the path coordinates exactly, with no deviations. 
If necessary, the motion model or dynamic limits of the actor may be violated to reproduce the path accurately. 
Basic information Table 73. 
Basic information of action replay_path Parents action_for_movable_object Controlled states The position and orientation of the actor are controlled so that they match those prescribed by the path at all times. 
The speed and acceleration of the actor along the path are uncontrolled. 
These can be controlled by other actions. 
Action ending The action ends when the actor passes the last point of the path Parameters Table 74. 
Action replay_path Parameter Type Mandatory Description absolute path yes Absolute path. 
Includes a list of points relative relative_path yes Relative path. 
Includes a list of points reference physical_object no Use with relative paths. 
Specify the reference entity that defines the origin for the point coordinates. 
Default: the actor itself transform relative_transform no Use with relative paths. 
Coordinates of the points are relative to the reference entity. 
Default = object_relative start_offset length no Offset at which to begin following the path, measured from the path ' s start. 
Default = 0m end_offset length no Offset at which to end following the path, measured from the path ' s end. 
Default = 0m Inherited parameters and variables Table 75. 
Inherited parameters and variables of action replay_path Parent Inherited parameters and variables osc_action duration 8.8.2.8.1 Examples Code 15. 
Usage of replay_path movable_object.replay_path(absolute: path [, start_offset: length] [, end_offset: length] [, ]) movable_object.replay_path(relative: relative_path, reference: physical_object, transform: relative_transform, [, start_offset: length] [, end_offset: length] [, ]) Code 16. 
Semantic clarification action movable_object.replay_path: absolute: path relative: relative_path reference: physical_object with: keep(default it == replay_path.actor) transform: relative_transform with: keep(default it == object_relative) start_offset: length with: keep(default it == 0m) end_offset: length with: keep(default it == 0m) if (relative): exact_absolute: path = map.resolve_relative_path(relative, reference, transform) else if (absolute): exact_absolute: path = absolute do move() with: along(exact_absolute, start_offset: start_offset, end_offset: end_offset) physical_movement(prefer_non_physical) Code 17. 
Examples for replay_path # Using an absolute path my_abs_path: path # Add constraints for fields of my_abs_path # Absolute path -- simple invocation do: my_car.replay_path(absolute: my_abs_path) # Absolute path -- with offset parameters do: my_car.replay_path(absolute: my_abs_path, start_offset: 2.0m, end_offset: 0.5m) # Using a relative path my_rel_path: relative_path_pose_3d # Add constraints for fields of my_rel_path # Can also use types relative_path_st, relative_path_odr # Relative path -- simple invocation do: my_car.replay_path(relative: my_rel_path) # Uses default values for parameters 'reference' and 'transform' # Relative path -- identical semantics to simple invocation do: my_car.replay_path(relative: my_rel_path, reference: my_car, transform: object_relative) # Relative path -- override default parameters do: my_car.replay_path(relative: my_rel_path, reference: other_car, transform: world_relative) # Relative path -- with offset options do: my_car.replay_path(relative: my_rel_path, start_offset: 2.0m, end_offset: 0.5m) # Uses default values for parameters 'reference' and 'transform' 8.8.2.9 Action replay_trajectory The actor moves by executing the trajectory exactly. 
If necessary, the motion model or dynamic limits of the actor may be violated to accurately follow the trajectory. 
Basic information Table 76. 
Basic information of action replay_trajectory Parents action_for_movable_object Controlled states All motion states (position, velocity, and acceleration, lateral and longitudinal) of the actor Action ending The action ends when the actor passes the last point of the trajectory Parameters Table 77. 
Action replay_trajectory Parameter Type Mandatory Description absolute trajectory yes Absolute trajectory. 
Includes a list of points and a list of corresponding time stamps relative relative_trajectory yes Relative trajectory. 
Includes a list of points and a list of corresponding time stamps reference physical_object no Use with relative trajectories. 
Specify the reference entity that defines the origin for the point coordinates. 
Default: the actor itself transform relative_transform no Use with relative trajectories. 
Coordinates of the points are relative to the reference entity. 
Default = object_relative start_offset length no Offset at which to begin following the trajectory, measured from the trajectory ' s start. 
Default = 0m end_offset length no Offset at which to end following the trajectory, measured from the trajectory ' s end. 
Default = 0m Inherited parameters and variables Table 78. 
Inherited parameters and variables of action replay_trajectory Parent Inherited parameters and variables osc_action duration 8.8.2.9.1 Examples Code 18. 
Usage of replay_trajectory movable_object.replay_trajectory(absolute: trajectory [, start_offset: length] [, end_offset: length] [, ]) movable_object.replay_trajectory(relative: relative_trajectory, reference: physical_object, transform: relative_transform, [, start_offset: length] [, end_offset: length] [, ]) Code 19. 
Semantic clarification action movable_object.replay_trajectory: absolute: trajectory relative: relative_trajectory reference: physical_object with: keep(default it == replay_trajectory.actor) transform: relative_transform with: keep(default it == object_relative) start_offset: length with: keep(default it == 0m) end_offset: length with: keep(default it == 0m) if (relative): exact_absolute: trajectory = map.resolve_relative_trajectory(relative, reference, transform) else if (absolute): exact_absolute: trajectory = absolute do move() with: along_trajectory(exact_absolute, start_offset: start_offset, end_offset: end_offset) physical_movement(prefer_non_physical) Code 20. 
Examples for replay_trajectory # Using an absolute trajectory my_abs_traj: trajectory # Add constraints for fields of my_abs_traj # Absolute trajectory -- simple invocation do: my_car.replay_trajectory(absolute: my_abs_traj) # Absolute trajectory -- with offset parameters do: my_car.replay_trajectory(absolute: my_abs_traj, start_offset: 2.0m, end_offset: 0.5m) # Using a relative trajectory my_rel_traj: relative_trajectory_pose_3d # Add constraints for fields of my_rel_traj # Can also use types relative_trajectory_st, relative_trajectory_odr # Relative trajectory -- simple invocation do: my_car.replay_trajectory(relative: my_rel_traj) # Uses default values for parameters 'reference' and 'transform' # Relative trajectory -- identical semantics to simple invocation do: my_car.replay_trajectory(relative: my_rel_traj, reference: my_car, transform: object_relative) # Relative trajectory -- override default parameters do: my_car.replay_trajectory(relative: my_rel_traj, reference: other_car, transform: world_relative) # Relative trajectory -- with offset options do: my_car.replay_trajectory(relative: my_rel_traj, start_offset: 2.0m, end_offset: 0.5m) # Uses default values for parameters 'reference' and 'transform' 8.8.2.10 Action remain_stationary The actor must remain stationary at its current position. 
The actor must hold a translational speed of zero in all directions throughout the whole action. 
This action may be used to differentiate stationary behavior from dynamic behavior. 
In order to explicitly set a target position, the action must be invoked together with at least one or any combination of the position(), lateral() or along() modifiers. 
Basic information Table 79. 
Basic information of action remain_stationary Parents action_for_movable_object Controlled states All translational states. 
Translational speed must be zero in all directions. 
Action ending The action ends when the phase in which the action is invoked is terminated. 
Inherited parameters and variables Table 80. 
Inherited parameters and variables of action remain_stationary Parent Inherited parameters and variables osc_action duration 8.8.2.10.1 Examples Code 21. 
Usage of remain_stationary movable_object.remain_stationary([, ]) Code 22. 
Semantic clarification action movable_object.remain_stationary: do move() with: keep_position() speed(speed: 0kph, at: all) Figure 25. 
A remain_stationary action Code 23. 
Examples for pedestrian_in_danger with remain_stationary scenario pedestrian_in_danger: person1: person egoVehicle: vehicle my_map: map ego_start_speed: speed = 50kph ego_start_distance: length = 5m person1_start_distance: length = 0m person1_target_speed: speed = 2kph ego_route: lane_section lane3: lane lane0: lane crossing1: crossing with: keep(it.width == 3.5m) my_map.crossing_connects(crossing1, start_lane: lane3, end_lane: lane0, start_s_coord: 55m, start_angle: 90deg) event event1 is person1.space_gap(egoVehicle, longitudinal) ]) movable_object.change_position(target_st: route_point, interpolation: path_interpolation, on_road_network: bool [, ]) movable_object.change_position(target_odr: odr_point, interpolation: path_interpolation, on_road_network: bool [, ]) Code 25. 
Semantic clarification action movable_object.change_position: target_xyz: position_3d target_st: route_point target_odr: odr_point interpolation: path_interpolation on_road_network: bool # The position() and lateral() modifiers use route coordinates # Convert target_xyz or target_odr arguments to route_point if target_odr: target_st: route_point = map.odr_to_route_point(target_odr.road_id, target_odr.lane_id, target_odr.s, target_odr.t) else if taget_xyz: target_st: route_point = map.xyz_to_route_point(target_xyz.x, target_xyz.y, target_xyz.z) # The initial position of the actor is sampled when the action is invoked # start_st is not a parameter of the action # It is only used here to illustrate the logic of the semantic clarifier start_st: route_point = actor.get_route_point() # Create a path from the initial position to the target position # action_path is not a parameter of the action # It is only used here to illustrate the logic of the semantic clarifier action_path: path = map.create_path_route_points([start_st, target_st], interpolation, on_road_network) do move() with: along(action_path) position(target_st.s, at: end) lateral(target_st.t, at: end) physical_movement(must_be_physical) Code 26. 
Examples for change position # Using global x-y-z coordinates # Move in straight line, ignoring road network my_pos: position_3d # Add constraints for fields of my_pos do: my_car.change_position(my_pos, straight_line, False) # Same as: my_car.change_position(target_xyz: my_pos, interpolation: smooth, on_road_network: False) # Using route s-t coordinates # Move along a smooth path, using road network my_st: route_point # Add constraints for fields of my_st do: my_car.change_position(target_st: my_st, interpolation: smooth, on_road_network: True) # Using odr coordinates # Move in straight line, using road network my_car: vehicle my_odr: odr_point # Add constraints for fields of my_odr do: my_car.change_position(target_odr: my_odr, interpolation: smooth, on_road_network: True) 8.8.2.12 Action change_speed The actor modifies its speed until the target speed is achieved. 
The motion model and dynamic limits of the actor should not be violated while executing this action. 
Basic information Table 84. 
Basic information of action change_speed Parents action_for_movable_object Controlled states Scalar longitudinal speed of actor Action ending The action ends when the actor reaches the target speed. 
Note the alternative keep_speed action. 
Parameters Table 85. 
Action change_speed Parameter Type Mandatory Description target speed yes Target value for the speed at the end of the action rate_profile dynamic_profile no Assign a shape for the change of the speed variable. 
This profile affects the acceleration during action execution rate_peak acceleration no Target value for the peak acceleration that must be achieved during the action Inherited parameters and variables Table 86. 
Inherited parameters and variables of action change_speed Parent Inherited parameters and variables osc_action duration 8.8.2.12.1 Examples Code 27. 
Usage of change_speed movable_object.change_speed(target: speed [, rate_profile: dynamic_profile [, rate_peak: acceleration]] [, ]) Code 28. 
Semantic clarification action movable_object.change_speed: target: speed rate_profile: dynamic_profile with: keep(default it == none) rate_peak: acceleration # spd_shape is not a parameter of the action # It is only used here to illustrate the logic of the semantic clarifier spd_shape: common_speed_shape with: keep(it.target == target) keep(it.rate_profile == rate_profile) keep(it.rate_peak == rate_peak) do move() with: if rate_profile == none: speed(target, at: end) else: speed(shape: spd_shape) Here, and in other semantic clarifications, there is usage of the if directive. 
This directive is not defined in ASAM OpenSCENARIO and is used here for illustrative purposes. 
Code 29. 
Examples for change_speed() # Reach target -- only mandatory parameters are specified car2.change_speed(35kph) # Reach target as soon as possible car2.change_speed(35kph, asap) # Reach target with smooth acceleration car2.change_speed(35kph, smooth) # Reach target with constant acceleration of 3 m/s/s car2.change_speed(35kph, constant, 3.0meter_per_sec_sqr) # Reach target in 3 seconds car2.change_speed(35kph, duration: 3.0sec) # Reach target in 3 seconds, keeping a constant acceleration car2.change_speed(35kph, duration: 3.0sec, rate_profile: constant) 8.8.2.13 Action keep_speed The actor keeps its speed until the action is terminated. 
The motion model and dynamic limits of the actor should not be violated while executing this action. 
Basic information Table 87. 
Basic information of action keep_speed Parents action_for_movable_object Controlled states Scalar longitudinal speed of actor. 
Action ending The action ends when the phase in which the action is invoked is terminated. 
Note the alternative change_speed action. 
Inherited parameters and variables Table 88. 
Inherited parameters and variables of action keep_speed Parent Inherited parameters and variables osc_action duration 8.8.2.13.1 Examples Code 30. 
Usage of keep_speed movable_object.keep_speed([, ]) Code 31. 
Semantic clarification action movable_object.keep_speed: do move() with: keep_speed() Code 32. 
Examples for keep_speed() # First go to 35kph and then keep this speed do serial: my_car.change_speed(35kph) my_car.keep_speed() 8.8.2.14 Action change_acceleration The actor modifies its acceleration until the target is reached. 
The motion model and dynamic limits of the actor should not be violated while executing this action. 
Basic information Table 89. 
Basic information of action change_acceleration Parents action_for_movable_object Controlled states Scalar longitudinal acceleration of the actor. 
Action ending The action ends when the actor reaches the target scalar acceleration. 
Note the alternative keep_acceleration action. 
Parameters Table 90. 
Action change_acceleration Parameter Type Mandatory Description target acceleration yes Target value for the scalar acceleration at the end of the action rate_profile dynamic_profile no Assign a shape for the change of the speed variable. 
This profile affects the jerk during action execution rate_peak jerk no Target value for the peak jerk that must be achieved during the action Inherited parameters and variables Table 91. 
Inherited parameters and variables of action change_acceleration Parent Inherited parameters and variables osc_action duration 8.8.2.14.1 Examples Code 33. 
Usage of change_acceleration movable_object.change_acceleration(target: acceleration [, rate_profile: dynamic_profile [, rate_peak: jerk]] [, ]) Code 34. 
Semantic clarification action movable_object.change_acceleration: target: acceleration rate_profile: dynamic_profile with: keep(default it == none) rate_peak: jerk # accel_shape is not a parameter of the action # It is only used here to illustrate the logic of the semantic clarifier accel_shape: common_acceleration_shape with: keep(it.target == target) keep(it.rate_profile == rate_profile) keep(it.rate_peak == rate_peak) do move() with: if rate_profile == none: acceleration(target, at: end) else: acceleration(shape: accel_shape) Here, and in other semantic clarifications, there is usage of the if directive. 
This directive is not defined in ASAM OpenSCENARIO and is used here for illustrative purposes. 
Code 35. 
Examples for change_acceleration() # Reach target -- only mandatory parameters are specified car2.change_acceleration(1.0mpsps) # Reach target as soon as possible car2.change_acceleration(1.0mpsps, asap) # Reach target with smooth jerk car2.change_acceleration(1.0mpsps, smooth) # Reach target with constant jerk of 2m/s/s/s car2.change_acceleration(-2.0meter_per_sec_sqr, constant, 2.0meter_per_sec_cubed) # Reach target in 2 seconds car2.change_acceleration(3.0mpsps, duration: 2.0sec) # Reach target in 2 seconds, keeping a constant jerk car2.change_acceleration(3.0mpsps, duration: 2.0sec, rate_profile: constant) 8.8.2.15 Action keep_acceleration The actor keeps its acceleration until the action is terminated. 
The motion model and dynamic limits of the actor should not be violated while executing this action. 
Basic information Table 92. 
Basic information of action keep_acceleration Parents action_for_movable_object Controlled states Scalar longitudinal acceleration of the actor. 
Action ending The action ends when the phase in which the action is invoked is terminated. 
Note the alternative change_acceleration action. 
Inherited parameters and variables Table 93. 
Inherited parameters and variables of action keep_acceleration Parent Inherited parameters and variables osc_action duration 8.8.2.15.1 Examples Code 36. 
Usage of keep_acceleration movable_object.keep_acceleration([, ]) Code 37. 
Semantic clarification action movable_object.keep_acceleration: do move() with: keep_acceleration() Code 38. 
Examples for keep_acceleration() # Accelerate up to 3 mpsps, keep this acceleration for 2 seconds and then reduce acceleration until it reaches zero do serial: my_car.change_acceleration(3.0mpsps) my_car.keep_acceleration(duration: 2.0sec) my_car.change_acceleration(0.0mpsps) 8.8.2.16 Action follow_path The actor follows the target path as closely as possible, according to the motion model and dynamic limits of the actor. 
The motion model and dynamic limits should not be violated while executing this action. 
This means that, after executing the scenario, the observed path may have differences to the target path. 
Basic information Table 94. 
Basic information of action follow_path Parents action_for_movable_object Controlled states The speed and acceleration at which the actor moves along the path are free (can be controlled by other actions). 
All other motion states are controlled by this action Action ending The action ends when the actor passes the last point of the path Parameters Table 95. 
Action follow_path Parameter Type Mandatory Description absolute path yes Absolute path. 
Includes a list of points relative relative_path yes Relative path. 
Includes a list of points reference physical_object no Use with relative paths. 
Specify the reference entity that defines the origin for the point coordinates. 
Default: the actor itself transform relative_transform no Use with relative paths. 
Coordinates of the points are relative to the reference entity. 
Default = object_relative start_offset length no Offset at which to begin following the path, measured from the path ' s start. 
Default = 0m end_offset length no Offset at which to end following the path, measured from the path ' s end. 
Default = 0m Inherited parameters and variables Table 96. 
Inherited parameters and variables of action follow_path Parent Inherited parameters and variables osc_action duration 8.8.2.16.1 Examples Code 39. 
Usage of follow_path movable_object.follow_path(absolute: path [, start_offset: length] [, end_offset: length] [, ]) movable_object.follow_path(relative: relative_path, reference: physical_object, transform: relative_transform, [, start_offset: length] [, end_offset: length] [, ]) Code 40. 
Semantic clarification action movable_object.follow_path: absolute: path relative: relative_path reference: physical_object with: keep(default it == follow_path.actor) transform: relative_transform with: keep(default it == object_relative) start_offset: length with: keep(default it == 0m) end_offset: length with: keep(default it == 0m) if (relative): target_absolute: path = map.resolve_relative_path(relative, reference, transform) else if (absolute): target_absolute: path = absolute do move() with: along(target_absolute, start_offset: start_offset, end_offset: end_offset) physical_movement(must_be_physical) Code 41. 
Examples for follow_path # Using an absolute path my_abs_path: path # Add constraints for fields of my_abs_path # Absolute path -- simple invocation do: my_car.follow_path(absolute: my_abs_path) # Absolute path -- with offset parameters do: my_car.follow_path(absolute: my_abs_path, start_offset: 2.0m, end_offset: 0.5m) # Using a relative path my_rel_path: relative_path_pose_3d # Add constraints for fields of my_rel_path # Can also use types relative_path_st, relative_path_odr # Relative path -- simple invocation do: my_car.follow_path(relative: my_rel_path) # Uses default values for parameters 'reference' and 'transform' # Relative path -- identical semantics to simple invocation do: my_car.follow_path(relative: my_rel_path, reference: my_car, transform: object_relative) # Relative path -- override default parameters do: my_car.follow_path(relative: my_rel_path, reference: other_car, transform: world_relative) # Relative path -- with offset options do: my_car.follow_path(relative: my_rel_path, start_offset: 2.0m, end_offset: 0.5m) # Uses default values for parameters 'reference' and 'transform' 8.8.2.17 Action follow_trajectory The actor follows the target trajectory as closely as possible, according to the motion model and dynamic limits of the actor. 
The motion model and dynamic limits should not be violated while executing this action. 
This means that, after executing the scenario, the observed trajectory may have differences (tracking errors) with respect to the target trajectory. 
Basic information Table 97. 
Basic information of action follow_trajectory Parents action_for_movable_object Controlled states All motion states (position, velocity, and acceleration, lateral and longitudinal) of the actor Action ending The action ends when the actor passes the last point of the trajectory Parameters Table 98. 
Action follow_trajectory Parameter Type Mandatory Description absolute trajectory yes Absolute trajectory. 
Includes a list of points and a list of corresponding time stamps relative relative_trajectory yes Relative trajectory. 
Includes a list of points and a list of corresponding time stamps reference physical_object no Use with relative trajectories. 
Specify the reference entity that defines the origin for the point coordinates. 
Default: the actor itself transform relative_transform no Use with relative trajectories. 
Coordinates of the points are relative to the reference entity. 
Default = object_relative start_offset length no Offset at which to begin following the trajectory, measured from the trajectory ' s start. 
Default = 0m end_offset length no Offset at which to end following the trajectory, measured from the trajectory ' s end. 
Default = 0m Inherited parameters and variables Table 99. 
Inherited parameters and variables of action follow_trajectory Parent Inherited parameters and variables osc_action duration 8.8.2.17.1 Examples Code 42. 
Usage of follow_trajectory movable_object.follow_trajectory(absolute: trajectory [, start_offset: length] [, end_offset: length] [, ]) movable_object.follow_trajectory(relative: relative_trajectory, reference: physical_object, transform: relative_transform, [, start_offset: length] [, end_offset: length] [, ]) Code 43. 
Semantic clarification action movable_object.follow_trajectory: absolute: trajectory relative: relative_trajectory reference: physical_object with: keep(default it == follow_trajectory.actor) transform: relative_transform with: keep(default it == object_relative) start_offset: length with: keep(default it == 0m) end_offset: length with: keep(default it == 0m) if (relative): target_absolute: trajectory = map.resolve_relative_trajectory(relative, reference, transform) else if (absolute): target_absolute: trajectory = absolute do move() with: along_trajectory(target_absolute, start_offset: start_offset, end_offset: end_offset) physical_movement(must_be_physical) Code 44. 
Examples for follow_trajectory # Using an absolute trajectory my_abs_traj: trajectory # Add constraints for fields of my_abs_traj # Absolute trajectory -- simple invocation do: my_car.follow_trajectory(absolute: my_abs_traj) # Absolute trajectory -- with offset parameters do: my_car.follow_trajectory(absolute: my_abs_traj, start_offset: 2.0m, end_offset: 0.5m) # Using a relative trajectory my_rel_traj: relative_trajectory_pose_3d # Add constraints for fields of my_rel_traj # Can also use types relative_trajectory_st, relative_trajectory_odr # Relative trajectory -- simple invocation do: my_car.follow_trajectory(relative: my_rel_traj) # Uses default values for parameters 'reference' and 'transform' # Relative trajectory -- identical semantics to simple invocation do: my_car.follow_trajectory(relative: my_rel_traj, reference: my_car, transform: object_relative) # Relative trajectory -- override default parameters do: my_car.follow_trajectory(relative: my_rel_traj, reference: other_car, transform: world_relative) # Relative trajectory -- with offset options do: my_car.follow_trajectory(relative: my_rel_traj, start_offset: 2.0m, end_offset: 0.5m) # Uses default values for parameters 'reference' and 'transform' 8.8.2.18 Enum dynamic_profile Basic information Table 100. 
Basic information of enum dynamic_profile Used by change_acceleration, change_lane, change_speed, follow_lane Values Table 101. 
Enum dynamic_profile Value Comment none No specific dynamic profile constant Use constant first derivative smooth Use smooth first derivative asap Reach value as soon as possible 8.8.3 Actions for vehicle The following actions are specifically for actors of type vehicle. 
Additionally, a vehicle can execute any of the actions of the classes they inherit from, like the action_for_movable_object. 
This also means, that a vehicle can be instructed to move on a route with the along() modifier. 
The children of action_for_vehicle are intended to be executed by actors that have an inherent dynamic behavior. 
This inherent dynamic behavior should have physical movement constraints that are typical for vehicles. 
The arguments in the actions for vehicle specify the target values for the state variables of the actor during the scenario. 
However, during execution of the action, the observed values for these state variables might differ from the target values. 
The dynamic constraints of the vehicle should not be violated while executing these actions, unless this is explicitly stated otherwise in the scenario description (for example, by using the physical_movement() modifier). 
8.8.3.1 Action drive Generic action to initiate the motion of vehicles. 
Usually invoked in combination with modifiers. 
Basic information Table 102. 
Basic information of action drive Parents action_for_vehicle Controlled states None directly. 
Depends on the modifiers. 
See chapter on modifiers. 
Action ending The action ends when the phase in which the action is invoked is terminated. 
Inherited parameters and variables Table 103. 
Inherited parameters and variables of action drive Parent Inherited parameters and variables osc_action duration 8.8.3.1.1 Examples Code 45. 
Usage of drive vehicle.drive([, ]) Code 46. 
Examples for drive() # Speed target of 30km/h for the end of the action, with constant acceleration my_car.drive() with: speed(30kph, at: end) acceleration(5kphps) # Drive for 30 seconds at 50km/h along road "my_road" with starting position relative to other_car my_car.drive(duration: 30s) with: speed(50kph) along(my_road) position(distance: 20m, behind: other_car, at: start) 8.8.3.2 Action follow_lane The actor shall stay within the boundaries of the lane as long as the action is active. 
The actor shall be in the same lane from the start to the end of the action. 
Basic information Table 104. 
Basic information of action follow_lane Parents action_for_vehicle Controlled states Lateral motion of the actor Action ending The action ends when the phase in which the action is invoked is terminated. 
Parameters Table 105. 
Action follow_lane Parameter Type Mandatory Description offset length no Default=0.0. 
Offset from center of the lane for the actor to follow, using the lane ' s t-axis rate_profile dynamic_profile no Assign a shape for the change of the lateral position variable (t-axis). 
This profile affects the lateral velocity during action execution rate_peak speed no Target value for the peak lateral velocity that must be achieved during the action target lane no The actor must be in this lane at the start, throughout, and the end of the action. 
If this argument is ignored, the actor follows the current lane when the action is invoked Inherited parameters and variables Table 106. 
Inherited parameters and variables of action follow_lane Parent Inherited parameters and variables osc_action duration 8.8.3.2.1 Examples Code 47. 
Usage of follow_lane vehicle.follow_lane([]) vehicle.follow_lane(offset: length [, rate_profile: dynamic_profile [, rate_peak: speed]] [, ]) vehicle.follow_lane(target: lane [, offset: length] [, rate_profile: dynamic_profile] [, rate_peak: speed] [, ]) Code 48. 
Semantic clarification action vehicle.follow_lane: offset: length with: keep(default it == 0m) rate_profile: dynamic_profile with: keep(default it == none) rate_peak: speed # empty_lane is not a parameter of the action # It is only used here to illustrate the empty_lane: lane target: lane with: keep(default target == empty_lane) # lat_shape is not a parameter of the action # It is only used here to illustrate the lat_shape : common_lateral_shape with: keep(it.rate_profile == rate_profile) keep(it.rate_peak == rate_peak) keep(it.target == offset) do drive() with: if target == empty_lane: keep_lane() else: lane(lane: target, at: all) if rate_profile == none: lateral(distance: offset, line: center) else: lateral(shape: lat_shape, line: center) Here, and in other semantic clarifications, there is usage of the if directive. 
This directive is not defined in ASAM OpenSCENARIO and is used here for illustrative purposes. 
Code 49. 
Examples for follow lane # Follow the centerline of the current lane my_car.follow_lane() my_car.follow_lane(0.0m) my_car.follow_lane(offset: 0.0m) # Follow the centerline of the current lane with duration 30 seconds my_car.follow_lane(duration: 30s) # Follow the current lane, with the current lateral offset my_car.follow_lane(offset: my_car.get_t_coord(on_lane)) # Follow the current lane with a fixed lateral offset... 
# ... 
and move to the target offset using the shape options my_car.follow_lane(-0.4m, smooth, 0.2mps) my_car.follow_lane(offset: -0.4m, rate_profile: smooth, rate_peak: 0.2mps) # Follow a previously declared instance of lane "my_lane" # If my_car is not in my_lane when the action starts, this should produce an error my_car.follow_lane(target: my_lane) # Follow a previously declared instance of lane "my_lane", with lateral offset my_car.follow_lane(target: my_lane, offset: 0.3m) # Follow lane "my_lane" with lateral offset... 
# ... 
and move to offset with constant lateral velocity and duration 1.5 seconds # The peak_rate (peak lateral velocity) is unconstrained and free for the implementation to decide my_car.change_lane(target: my_lane, rate_profile: constant, duration: 1.5s) 8.8.3.3 Action change_lane The actor shall start this action outside of the target lane and move into the target lane by the end of the action. 
The lane at the end of the action must be different from the lane at the start of the action. 
Basic information Table 107. 
Basic information of action change_lane Parents action_for_vehicle Controlled states Lateral motion of the actor Action ending The action ends when the actor is located in the target lane, at the target offset, and with heading angle and velocity vectors aligned with the geometry of the target lane Parameters Table 108. 
Action change_lane Parameter Type Mandatory Description num_of_lanes uint no The target lane is "num_of_lanes" to the side of the reference entity. 
Use in conjunction with "side" side lane_change_side no Select on which side of the reference entity reference physical_object no Default=it.actor. 
Reference to the entity that is used to determine the target lane. 
If this argument is omitted, the actor itself is used as reference offset length no Default=0.0. 
Target offset from center of the target lane that the actor follows at the end of the action rate_profile dynamic_profile no Assign a shape for the change of the lateral position variable (t-axis). 
This profile affects the lateral velocity during action execution rate_peak speed no Target value for the peak lateral velocity that must be achieved during the action target lane yes The actor starts and finishes the action in the target lane Inherited parameters and variables Table 109. 
Inherited parameters and variables of action change_lane Parent Inherited parameters and variables osc_action duration 8.8.3.3.1 Examples Code 50. 
Usage of change_lane vehicle.change_lane(num_of_lanes: int, side: lane_change_side, reference: physical_object, [, offset: length] [, rate_profile: dynamic_profile [, rate_peak: speed]] [, ]) vehicle.change_lane(target: lane [, offset: length] [, rate_profile: dynamic_profile [, rate_peak: speed]] [, ]) Code 51. 
Semantic clarification action vehicle.change_lane: num_of_lanes: int with: keep(default it == 1) side: lane_change_side reference: physical_object with: keep(default it == actor) offset: length with: keep(default it == 0m) rate_profile: dynamic_profile with: keep(default it == none) rate_peak: speed # empty_lane is not a parameter of the action # It is only used here to illustrate the logic of the semantic clarifier empty_lane: lane target: lane with: keep(default target == empty_lane) # lat_shape is not a parameter of the action # It is only used here to illustrate the logic of the semantic clarifier lat_shape : common_lateral_shape with: keep(it.rate_profile == rate_profile) keep(it.rate_peak == rate_peak) keep(it.target == offset) do drive() with: # This semantic clarifier will use two modifiers: lane() and lateral() # This block shows the correct invocation of lane(), depending on the parameter values if target == empty_lane: if side == same: lane(same_as: reference, at: end) else if side == left: lane(num_of_lanes, left_of: reference, at: end) else if side == right: lane(num_of_lanes, right_of: reference, at: end) else: lane(lane: target, at: end) # This block shows the correct invocation of lateral(), depending on the parameter values if rate_profile == none: lateral(distance: offset, line: center, at: end) else: lateral(shape: lat_shape, line: center) Here, and in other semantic clarifications, there is usage of the if directive. 
This directive is not defined in ASAM OpenSCENARIO and is used here for illustrative purposes. 
Code 52. 
Examples for change lane # Changes one (1) lane to the left (using default values) my_car.change_lane(side: left) # Changes one (1) lane to the left with lateral offset in target lane my_car.change_lane(side: left, offset: 0.5m) # Changes to same lane as other car my_car.change_lane(side: same_as, reference: other_car) # Changes to a lane two (2) lanes right of other_car my_car.change_lane(2, right, other_car) my_car.change_lane(num_of_lanes: 2, side: right, reference: other_car) # Changes to a lane two (2) lanes right of other_car, with shape options my_car.change_lane(2, right, other_car, rate_profile: smooth, rate_peak: 0.9mps) # Changes to a lane one (1) lane inside of other_car, depending on map.driving_rule my_car.change_lane(side: map.inner_side(), reference: other_car) # Changes to previously declared instance of lane "my_lane" my_car.change_lane(target: my_lane) # Changes to lane "my_lane", with action duration of 5.5 seconds my_car.change_lane(target: my_lane, duration: 5.5s) # Changes to lane "my_lane", with offset and shape options my_car.change_lane(target: my_lane, offset: -0.2m, rate_profile: constant, rate_peak: 0.4mps) # Changes to lane "my_lane", with constant lateral velocity and duration 4.0 seconds # The peak_rate (peak lateral velocity) is unconstrained and free for the implementation to decide my_car.change_lane(target: my_lane, rate_profile: constant, duration: 4.0s) 8.8.3.4 Action change_space_gap The actor executing this action changes their space gap to the reference entity until the target value is reached. 
The space gap is measured in s-t-coordinates according to the space_gap() method. 
This action should be executed while respecting the dynamic constraints of the actor. 
Once the target space gap is achieved, the action ends. 
Basic information Table 110. 
Basic information of action change_space_gap Parents action_for_vehicle Controlled states Determined by the direction attribute. 
[ahead, behind] controls the longitudinal motion of the actor. 
[left, right, inside, outside] controls the lateral motion of the actor Action ending The action ends when the target space gap is reached. 
Parameters Table 111. 
Action change_space_gap Parameter Type Mandatory Description target length yes Target distance between the actor and the reference entity. 
Distance is measured according to the space_gap() method direction gap_direction yes Placement of the actor with respect to the reference entity. 
[ahead, behind] means distance is measured in the s-axis. 
[left, right, inside, outside] means distance is measured in the t-axis reference physical_object yes The actor reaches the driving distance to this reference entity Inherited parameters and variables Table 112. 
Inherited parameters and variables of action change_space_gap Parent Inherited parameters and variables osc_action duration 8.8.3.4.1 Examples Code 53. 
Usage of change_space_gap vehicle.change_space_gap(target: length, direction: gap_direction, reference: physical_object, [, ]) Code 54. 
Semantic clarification action vehicle.change_space_gap: target: length direction: gap_direction reference: physical_object do drive() with: if direction == ahead: position(target, ahead_of: reference, at: end) else if direction == behind: position(target, behind: reference, at: end) else if direction == left: lateral(target, left_of: reference, at: end) else if direction == right: lateral(target, right_of: reference, at: end) # To support [outside, inside] you need to use map.driving_rule Here, and in other semantic clarifications, there is usage of the if directive. 
This directive is not defined in ASAM OpenSCENARIO and is used here for illustrative purposes. 
It is used as a semantic clarifier to show the "logic" of the action being described. 
Code 55. 
Examples for change_space_gap() # These two invocations are equivalent: my_car.change_space_gap(10.0m, ahead, other_car) my_car.change_space_gap(target: 10.0m, direction: ahead, reference: other_car) # These two invocations are equivalent: my_car.change_space_gap(2.5m, left, other_car) my_car.change_space_gap(target: 2.5m, direction: left, reference: other_car) 8.8.3.5 Action keep_space_gap The actor executing this action keeps a space gap to the reference entity, measured in s-t-coordinates according to the space_gap() method. 
This action should be executed while respecting the dynamic constraints of the actor. 
Basic information Table 113. 
Basic information of action keep_space_gap Parents action_for_vehicle Controlled states Determined by the direction attribute. 
[longitudinal] controls the longitudinal motion of the actor. 
[lateral] controls the lateral motion of the actor Action ending The action ends when the phase in which the action is invoked is terminated. 
Parameters Table 114. 
Action keep_space_gap Parameter Type Mandatory Description reference physical_object yes The actor keeps the driving distance to this reference entity direction distance_direction yes Direction in which the space gap is kept with respect to the reference entity. 
[longitudinal] to keep distance in the s-axis. 
[lateral] to keep distance in the t-axis Inherited parameters and variables Table 115. 
Inherited parameters and variables of action keep_space_gap Parent Inherited parameters and variables osc_action duration 8.8.3.5.1 Examples Code 56. 
Usage of keep_space_gap vehicle.keep_space_gap(reference: physical_object, direction: gap_direction [, ]) Code 57. 
Semantic clarification action vehicle.keep_space_gap: reference: physical_object direction: distance_direction # The space gap is sampled when the action is invoked target: length = actor.space_gap(reference: reference, direction: distance_direction) do drive() with: if (direction == longitudinal) and (target >= 0): position(target, ahead_of: reference, at: all) else if (direction == longitudinal) and (target = 0): lateral(target, right_of: reference, at: all) else if (direction == lateral) and (target ]) Code 60. 
Semantic clarification action vehicle.change_time_headway: target: time direction: headway_direction reference: physical_object do drive() with: if direction == ahead: position(time: target, ahead_of: reference, at: end) else if position == behind: position(time: target, behind: reference, at: end) Here, and in other semantic clarifications, there is usage of the if directive. 
This directive is not defined in ASAM OpenSCENARIO and is used here for illustrative purposes. 
It is used as a semantic clarifier to show the "logic" of the action being described. 
Code 61. 
Examples for change_time_headway() # These two invocations are identical: my_car.change_time_headway(4.1s, ahead, other_car) my_car.change_time_headway(target: 4.1s, direction: ahead, reference: other_car) 8.8.3.7 Action keep_time_headway The actor executing this action keeps a time headway to the reference entity, measured according to the time_headway() method. 
This action should be executed while respecting the dynamic constraints of the actor. 
Basic information Table 119. 
Basic information of action keep_time_headway Parents action_for_vehicle Controlled states Longitudinal motion of the actor. 
Action ending The action ends when the phase in which the action is invoked is terminated. 
Parameters Table 120. 
Action keep_time_headway Parameter Type Mandatory Description reference physical_object yes The actor keeps the time headway to this reference entity Inherited parameters and variables Table 121. 
Inherited parameters and variables of action keep_time_headway Parent Inherited parameters and variables osc_action duration 8.8.3.7.1 Examples Code 62. 
Usage of keep_time_headway vehicle.keep_time_headway(reference: physical_object [, ]) Code 63. 
Semantic clarification action vehicle.keep_time_headway: reference: physical_object # The time headway is sampled when the action is invoked target: time = actor.time_headway(reference: reference) do drive() with: if target >= 0: position(time: target, ahead_of: reference, at: all) else target ]) Code 66. 
Examples for walk # Walk with constant speed while changing yaw angle from 0deg to 90deg my_pedestrian.walk() with: speed(1.0mps) yaw(0deg, at: start) yaw(90deg, at: end) # Walk for 5 seconds along route "my_ped_route" starting at 3 m/s and stopping at the end my_pedestrian.walk(duration: 5.0s) with: along(my_ped_route) speed(3.0mps, at: start) speed(0.0mps, at: end) 8.7 Physical object actors 8.9 Movement modifiers

8.9 Movement modifiers
8.9 Movement modifiers 8.9.1 Modifiers for movement actions The movement of physical objects, including vehicles and pedestrians, is specified using movement actions. 
These actions can be tuned with the use of movement modifiers. 
These modifiers can be applied to either the generic movement actions, like move(), drive(), or walk(), or to the specialized movement actions, like change_speed(), change_lane(), and so on. 
Users are free to combine modifiers and actions, as long as the combination provides a consistent set of constraints for the actor behavior. 
These modifiers must appear either as members of other action modifiers or as members of a movement action after with. 
Code 1. 
Modifier drive() do serial: vehicle1.drive() with: speed([30kph..70kph]) Code 2. 
Modifier follow_lane() do serial: vehicle2.follow_lane(offset: 0.375m, target: lane2) with: position(1m, ahead_of: ego_vehicle, at: start) speed(60kph) Some parameters can be passed by order, meaning without the parameter name. 
If no arguments are passed, the defaults are applied. 
The following three invocations of lane() are supported and have the same effect: Code 3. 
Different kinds of passing parameters lane(lane: 1) lane(1) lane() 8.9.1.1 Common parameters The following parameters are common to all domain model movement modifiers. 
8.9.1.1.1. 
Parameter at All movement modifiers have an optional parameter at with the following possible values: all This constraint holds throughout this phase (default). 
start This constraint holds at the start of the phase. 
end This constraint holds at the end of the phase. 
8.9.1.1.2. 
Parameter movement_mode The parameter movement_mode has the following values: monotonous This movement mode adheres to the laws of physics. 
On top of that it limits the level of surprise that a movement may have. 
other Not necessarily monotonous. 
This is the default. 
8.9.1.1.3. 
Parameter track track Actual or projected. 
The default is actual, meaning that the vehicle reacts to the behavior of the referenced vehicle. 
8.9.1.1.4. 
Parameter shape shape A shape struct is an object that contains a duration() and a compute() method, plus a set of parameters that allow users to shape the way a state variable (like lateral position, speed or acceleration) changes during an action/modifier invocation. 
The duration() method returns the time duration of the shape. 
The compute() method returns concrete values for the relevant state variable as a function of time. 
The following is a typical use of a shape struct. 
Code 4. 
Shape scenario my_scenario: spd_shape: common_speed_shape with: keep(it.target == 50kph) keep(it.rate_profile == smooth) keep(it.rate_peak == 5mpsps) v1: vehicle do serial: v1.drive() with: speed(shape: spd_shape) The example below exhibits the same behavior as the example above. 
Note that, in general, the shape’s target parameter may overlap with at: end constraints introduced in the modifier. 
In this case, the shape’s target parameter can be taken from the speed modifier. 
However, to avoid confusion or contradictions, it is suggested to create shape struct instances that are fully defined. 
Code 5. 
Shape with target parameter from speed modifier scenario my_scenario: spd_shape: common_speed_shape with: keep(it.rate_profile == smooth) keep(it.rate_peak == 5mpsps) v1: vehicle do serial: v1.drive() with: speed(50kph, at: end, shape: spd_shape) This shape example causes the vehicle v1 to drive with 50 kph. 
This speed is achieved with a smooth acceleration profile with a peak acceleration of 5 mpsps, as specified by the rate_profile and rate_peak parameters. 
A set of built-in shape objects is provided in ASAM OpenSCENARIO. 
Users can extend these built-in shape objects with their own desired shape objects. 
Note that using the shape strcuts will specify the exact values for certain state variables (or their derivatives) throughout the corresponding action execution. 
This can limit the degrees of freedom of the actor during the action execution and could have strict implications on other scenario attributes. 
For example, when using a shape struct on a speed modifier, this will also constrain the acceleration attributes of the actor. 
Be careful not to use excessive shape attributes on the modifier that may restrict the generated movements, unless this is your goal. 
For more information on shape objects please read the shape object description below. 
8.9.1.2 Shape object description The shape structs are a way to describe the behavior of a state variable as a function of time within a modifier invocation, enabling a fine-grained control of the actor’s maneuver. 
any_shape is the base struct of the shape hierarchy, thus any user-defined shape structs should inherit from any_shape or one of its children. 
any_shape contains the duration() function which returns the time duration of that shape. 
Concrete shape types implement their shape compute() function which gets a time argument and returns the corresponding value of the state variable that is modified by the shape. 
The time is measured from the start of the scenario phase that invokes the modifier. 
Specific shape objects can have additional arbitrary attributes. 
The shape hierarchy definition is as follows: struct any_shape: def duration() -> time is undefined struct any_acceleration_shape inherits any_shape: def compute(time: time) -> acceleration is undefined struct any_speed_shape inherits any_shape: def compute(time: time) -> speed is undefined struct any_position_shape inherits any_shape: def compute(time: time) -> length is undefined struct any_lateral_shape inherits any_shape: def compute(time: time) -> length is undefined ASAM OpenSCENARIO also provides predefined shapes for common maneuvers. 
The common shapes include a target parameter for the relevant state variable, as well as two parameters related to the first derivative of the state. 
The rate_profile parameter indicates the type of dynamic_profile for the first derivative of the state. 
The rate_peak parameter is the peak value that must be reached by the first derivative of the state during the maneuver. 
These parameters provide a complete set of constraints to resolve the target shape of the state (as a function of time) that should be achieved during execution of the action. 
Code 6. 
Built-in common shapes struct common_acceleration_shape inherits any_acceleration_shape: rate_profile: dynamic_profile rate_peak: jerk target: acceleration struct common_speed_shape inherits any_speed_shape: rate_profile: dynamic_profile rate_peak: acceleration target: speed struct common_position_shape inherits any_position_shape: rate_profile: dynamic_profile rate_peak: speed target: length struct common_lateral_shape inherits any_lateral_shape: rate_profile: dynamic_profile rate_peak: speed target: length Users and implementers can extend the domain model and create their own shape structs with additional parameters to solve specific functional forms or sets of constraints for the shape of the state variable trajectory. 
8.9.1.3 Absolute or relative movement modifiers The scenario modifiers that set a speed, position, or lane can be either absolute or relative. 
Code 7. 
Absolute and relative speed modifiers position([10m..20m], at: start) # Absolute distance from the start of the path speed([10kph..15kph], faster_than: vehicle1) # Relative lane(same_as: vehicle1) # Relative The relative versions require two vehicles moving in parallel. 
They may also have multiple parameters such as faster_than and slower_than, but at most you can specify one. 
These two constraints are checked at compile time. 
These modifiers have a track parameter that specifies whether the vehicle reacts to the actual behavior of the referenced vehicle or to its expected behavior. 
By default, the vehicle reacts to the actual behavior of the referenced vehicle, but there may be cases where the referenced vehicle behaves in ways that you want the vehicle to ignore. 
In those cases, you can require the vehicle to track the projected behavior of the referenced vehicle. 
For example, consider the l2: lane() and the p2: position() modifiers in phase2 of the following scenario. 
Code 8. 
Movement modifiers do serial(): phase1: parallel(duration: [1.5s..3s]): d1: dut.vehicle.drive() d2: vehicle1.drive() phase2: parallel(duration: [1.5s..3s]): d3: dut.vehicle.drive() d4: vehicle1.drive() with: speed(speed: [30kph..200kph]) l1: lane(side_of: dut.vehicle, at: start) p1: position(time: [0.5s..1s], ahead_of: dut.vehicle, at: start) l2: lane(same_as: dut.vehicle, at: end) p2: position(time: [1.5s..2s], ahead_of: dut.vehicle, at: end) Because of these modifiers, at the end of phase2 the following happens: vehicle1 ends on the same lane as the ego, even if the ego has changed lanes. 
vehicle1 ends ahead of the ego, even if it has accelerated. 
This behavior may be exactly what is intended. 
But maybe the following is intended: vehicle1 ends in the lane where the ego was at the start of p2. 
vehicle1 ends [1.5s..2s] seconds ahead of where the ego would have been, if it had continued at the same speed it was at the start of p2. 
In this case, change the last two lines to: Code 9. 
Adapting behavior l2: lane(same_as: dut.vehicle, at: end, track: projected) p2: position(time: [1.5s..2s], ahead_of: dut.vehicle, at: end, track: projected) Negative distance values are allowed and mean "going to the other side". 
Code 10. 
Negative distance values lateral(distance: -2m, side: left) The example shows being two meters to the right. 
8.9.2 Modifier position() Purpose Set the position of an actor along the s-coordinate of the road the related actors are located on. 
Category Scenario modifier Usage Code 11. 
Position modifier position(distance: length | time: time [, ]) position(distance: length | time: time, [ahead_of: physical_object | behind: physical_object] [, ]) position(distance: length | time: time, [ahead_of_point: position_3d | behind_point: position_3d] [, ]) position(at_point: position_3d, project_on_route: bool [, ]) Parameters distance A target length value including a length unit. 
The distance is calculated using the route-based s-coordinate. 
It is mandatory to include one (and only one) of distance or time or at_point arguments. 
time A target time value with a time unit, to determine headway time between the actor and a movable object or point. 
It is mandatory to include one (and only one) of distance or time or at_point arguments. 
ahead_of When ahead_of is specified, the actor must be ahead of the physical_object by the specified value using road coordinates. 
behind When behind is specified, the actor must be behind the physical_object by the specified value. 
ahead_of_point when ahead_of_point is specified, the actor must be a head of the specified point. 
By default the projected route. 
behind_point when behind_point is specified, the actor must be a head of the specified point. 
By default the projected route. 
at_point when at_point is specified, the actor must be at the specified point. 
project_on_route This option is relevant only if at_point is specified. 
If true (the default), project the point on the actor’s route as the reference point. 
If false, use the actual point. 
In all other cases (not using at_point), the distance or time values must be projected on the road. 
If the point cannot be uniqely projected on the road (for example the road ends before reaching this point), an error should be issued. 
 A set of parameters that are relevant for most movement modifiers. 
For example, at. 
For more information please refer to Section 8.9.1.1, “Common parameters”. 
Description The position() modifier lets you specify the position of an actor relative to the start of the path or relative to another actor. 
You can specify the position by distance or time (but not both). 
When ahead_of is specified, the actor must be ahead of vehicle by the specified value in the relevant period. 
behind contradicts ahead_of, so you cannot use them together. 
When time is specified along with ahead_of or behind_of, the physical distance is calculated using the speed of the vehicle that is behind (irrespective of whether it is the actor of the scenario or the referenced vehicle) and the location at that moment of the vehicle that is ahead. 
The speed of the vehicle that is ahead is not taken into the calculation. 
If the at parameter is all, the physical distance at any point in time refers to the speed of vehicle that is behind at that moment and the location of the vehicle that is ahead at that same moment (meaning that the physical distance may vary during the time period). 
The following two examples are equivalent. 
In both cases the physical distance is calculated according to the speed of vehicle2. 
do parallel: vehicle1.drive() with: speed(speed: 30kph, at: end) vehicle2.drive() with: speed(speed: 40kph, at: end) position(time: 3second, behind: vehicle1, at: end) # is identical to: do parallel: vehicle1.drive() with: speed(speed: 30kph, at: end) position(time: 3second, ahead_of: vehicle2, at: end) vehicle2.drive() with: speed(speed: 40kph, at: end) Examples Code 12. 
Position modifier do serial: vehicle1.drive() with: # Absolute from the start of the path position([10m..20m]) do parallel: vehicle1.drive() vehicle2.drive() with: # 40 meters ahead of vehicle1 at end position(40meter, ahead_of: vehicle1, at: end) do parallel: vehicle1.drive() vehicle2.drive() with: # Behind vehicle1 throughout position([20m..30m], behind: vehicle1) do parallel: vehicle1.drive() vehicle2.drive() with: # Behind vehicle1, measured by time position(time: [2s..3s], behind: vehicle1) 8.9.3 Modifier keep_position() Purpose Maintain absolute position of the actor for the current period. 
Category Scenario modifier Usage Code 13. 
Keep position modifier keep_position() Modifier constraints are enforced during both planning and execution. 
Example Code 14. 
Keep position modifier do serial: vehicle1.drive() with: keep_position() 8.9.4 Modifier speed() Purpose Set the speed of an actor for the current period. 
Category Scenario modifier Usage Code 15. 
Speed modifier speed(speed: speed [, direction: lon_lat] [, ]) speed(speed: speed, [faster_than: physical_object | slower_than: physical_object, same_as: physical_object] [, direction: lon_lat] [, ]) Parameters speed A target speed value, including a speed unit. 
faster_than | slower_than | same_as Use one (and only one) of these arguments set the speed target relative to another physical_object, like a vehicle, person or movable_object. 
direction Determines the direction of the controlled speed. 
The default value is longitudinal, which controls the speed state as defined in movable_object states When the value is lateral, this modifies the lateral speed. 
 A set of parameters that are relevant for most movement modifiers. 
For example, at. 
For more information please refer to Section 8.9.1.1, “Common parameters”. 
Description When faster_than is specified, the actor must be faster than the physical_object by the specified value in the relevant period. 
The arguments slower_than, faster_than and same_as contradict each other, and cannot be used together. 
Examples Code 16. 
Speed modifier do serial: vehicle1.drive() with: # Absolute speed range speed([10kph..20kph]) do parallel: vehicle1.drive() vehicle2.drive() with: # Faster than vehicle1 by [1kph..5kph] speed([1kph..5kph], faster_than: vehicle1) do serial: vehicle1.drive() with: # Have that speed at end of the phase speed(5kph, at: end) do parallel: vehicle1.drive() vehicle2.drive() with: # Either slower or faster than vehicle1 speed([-20kph..20kph], faster_than: vehicle1) 8.9.5 Modifier change_speed() Purpose Change the speed of the actor for the current period. 
Category Scenario modifier Usage Code 17. 
Change speed modifier change_speed(speed: speed [, ]) Parameters speed A target speed value, including a speed unit. 
 A set of parameters that are relevant for most movement modifiers. 
For example, at. 
For more information please refer to Section 8.9.1.1, “Common parameters”. 
Example Code 18. 
Change speed modifier do serial: vehicle1.drive() with: change_speed([-20kph..20kph]) 8.9.6 Modifier keep_speed() Purpose Maintain absolute speed of the actor for the current period. 
Category Scenario modifier Usage Code 19. 
Keep speed modifier keep_speed() Example Code 20. 
Keep speed modifier do serial: vehicle1.drive() with: keep_speed() 8.9.7 Modifier acceleration() Purpose Specify the rate of acceleration of an actor. 
Category Scenario modifier Usage Code 21. 
Acceleration modifier acceleration(acceleration: acceleration [, ]) Parameters acceleration A target acceleration value, with acceleration unit. 
 A set of parameters that are relevant for most movement modifiers. 
For example, at. 
For more information please refer to Section 8.9.1.1, “Common parameters”. 
Example Code 22. 
Acceleration modifier # Accelerate by 5kph every second do serial: vehicle1.drive() with: acceleration(5kphps) 8.9.8 Modifier lateral() Purpose Set location inside the line along the lateral axis using road coordinates (T-axis). 
Category Scenario modifier Usage Code 23. 
Lateral modifier lateral(distance: length, side_of: vehicle, side: side_left_right [, measure_by: lat_measure_by] [, ]) Parameters distance The offset from reference line. 
side_of The location relative to a specific vehicle. 
side Set the location on the left or on the right. 
measure_by This parameter specifies the measurement start and end points. 
For example, measuring the distance from the left side of one vehicle to the right side of another vehicle. 
Values can be: left_to_left left_to_center left_to_right center_to_left center_to_center center_to_right right_to_left right_to_center right_to_right closest (default)  A set of parameters that are relevant for most movement modifiers. 
For example, at. 
For more information please refer to Section 8.9.1.1, “Common parameters”. 
Example Code 24. 
Lateral modifier do serial: vehicle1.drive() with: lateral(distance: 1.5meter, measure_by: right_to_right, at: start) # Lateral distance is measured from the right side of the vehicle to the lane edge on the right. 
do serial: vehicle1.drive() with: lateral(distance: 1.5meter, side_of: v1, side: right, measure_by: right_to_left, at: start) # Lateral distance is measured from the right side of the vehicle to the left side of v1 8.9.9 Modifier yaw() Purpose Set the yaw of the vehicle. 
Category Scenario modifier Usage Code 25. 
Yaw modifier yaw(angle: angle [, ]) yaw(angle: angle, relative_to: physical_object [, measure_by: yaw_measure_by ] [, ]) Parameters angle A single value or range with an angle unit. 
This parameter is mandatory. 
relative_to A named instance of the vehicle actor. 
measure_by This option is relevant only if relative_to is specified. 
Defines reference lines of the actor and the referenced physical_object, where width is an x-axis and long is a y-axis. 
Values include: length_to_length length_to_width width_to_length width_to_width relative_to_north relative_to_road (default)  A set of parameters that are relevant for most movement modifiers. 
For example, at. 
For more information please refer to Section 8.9.1.1, “Common parameters”. 
Description Modify the yaw angle of the actor. 
Examples Code 26. 
Yaw modifier # The angle between the y-axis of the actor (vehicle1) and the s-axis of the lane is between 2 and 3 radians. 
do serial: vehicle1.drive() with: yaw([2rad..3rad]) # The angle between the y-axis of the actor (vehicle1) and the y-axis of car1 is between 2 and 3 radians do serial: vehicle1.drive() with: yaw([2rad..3rad], relative_to: car1, measure_by: length_to_length) 8.9.10 Modifier orientation() Purpose Specify the orientation of an actor. 
Category Scenario modifier Usage Code 27. 
Orientation modifier orientation(yaw: angle [, pitch: angle] [, roll: angle] [, relative_to: physical_object] [, measure_by: orientation_measured_by] [, ]) orientation(pitch: angle [, roll: angle] [, yaw: angle] [, relative_to: physical_object] [, measure_by: orientation_measured_by] [, ]) orientation(roll: angle [, yaw: angle] [, pitch: angle] [, relative_to: physical_object] [, measure_by: orientation_measured_by] [, ]) Parameters yaw, pitch, roll is an angle value, including an angle unit. 
Include one, two or three of the angle arguments. 
relative_to is the object relative to whom the angles will be measured. 
If the argument is ignored, the global coordinate system is used. 
measure_by defines how to measure the desired orientation. 
Values include absolute, relative_to_reference, relative_to_road. 
The default is relative_to_road. 
 are set of parameters that are relevant for most movement modifiers. 
For example, at. 
For more information please refer to Section 8.9.1.1, “Common parameters”. 
Example Code 28. 
Orientation modifier # The angle between the x-axis of the actor and the s-axis of the lane is between 2 and 3 radians. 
do serial: vehicle1.drive() with: orientation(yaw: [2rad..3rad]) # The angle between the x-axis of the actor and the x-axis of car1 is between 60 and 80 degrees do serial: vehicle1.drive() with: orientation(yaw: [60deg..80deg], relative_to: car1, measure_by: length_to_length) 8.9.11 Modifier along() Purpose The actor moves along a route. 
Category Scenario modifier Usage Code 29. 
Along modifier along(route: route [, start_offset: length] [, end_offset: length] [, ]) Parameters route The route to move along. 
start_offset How far along the route should the motion start. 
Default = 0m. 
end_offset How far from the end of the route should the motion end. 
Default = 0m. 
 A set of parameters that are relevant for most movement modifiers. 
For example, at. 
For more information please refer to Section 8.9.1.1, “Common parameters”. 
Example Code 30. 
Along modifier # Move along a road my_road: road do: my_car.drive() with: along(my_road) # Move along a path my_path: path = map.create_path(my_list_of_points, smooth) do: my_car.drive() with: along(my_path) # Move along a compound route my_route: route = map.create_route([road_01, lane_A, road_34]) do: my_car.drive() with: along(my_route) 8.9.12 Modifier along_trajectory() Purpose The actor moves along a trajectory. 
Category Scenario modifier Usage Code 31. 
Along trajectory modifier along_trajectory(trajectory: trajectory [, start_offset: length] [, end_offset: length] [, ]) Parameters trajectory The trajectory to move along. 
start_offset How far along the trajectory should the motion start. 
Default = 0m. 
end_offset How far from the end of the trajectory should the motion end. 
Default = 0m. 
 A set of parameters that are relevant for most movement modifiers. 
For example, at. 
For more information please refer to Section 8.9.1.1, “Common parameters”. 
Example Code 32. 
Along trajectory modifier # car1 moves along the trajectory t car1.drive() with: along_trajectory(t) 8.9.13 Modifier distance() Purpose Constrain the distance traveled by an actor during a movement. 
Category Scenario modifier Usage Code 33. 
Distance modifier distance(distance: length) [, ] Parameters distance The distance the actor should travel in the current movement. 
 A set of parameters that are relevant for most movement modifiers. 
For example, at. 
For more information please refer to Section 8.9.1.1, “Common parameters”. 
Description Constrains the distance traveled by an actor during a movement such as drive(). 
Example In the following example, the distance traveled by vehicle1 during the d1 phase should be within 30 to 50 meters. 
Code 34. 
Distance modifier do serial() d1: vehicle1.drive() with: distance([30m..50m]) 8.9.14 Modifier lane() Purpose Set the lane in which an actor moves. 
Category Scenario modifier Usage Code 35. 
Lane syntax lane(lane: uint, side_of: physical_object, side: side_left_right [, standard-movement-parameters]) lane(lane: uint, from: side_left_right [, standard-movement-parameters]) lane(same_as: physical_object [, standard-movement-parameters]) Parameters lane A single unsigned integer or range of unsigned integers indicating a lane or range of lanes to move in relative to a certain reference. 
The parameter value (range) specifies a relative number with respect to a certain reference. 
This reference is given through one of the other parameters. 
If no lane parameter is specified, the default is 1. 
For the interpretation of the uint-value see the other parameter descriptions. 
same_as Option to specify that the vehicle must be in the same lane as the referenced vehicle. 
The default-value for the lane-parameter must be neglected. 
side_of Option to specify that the vehicle must be in another lane than the referenced vehicle. 
Which side is specified with the following side parameter side Depending on the value the actor shall be on the right or left side of the referenced physical_object. 
How many lanes right or left of that physical_object is specified by the lane-parameter. 
from Option to specify that the vehicle is in a certain lane with reference to the road. 
How many lanes from the right or left of the road is specified by the lane-parameter. 
 A set of parameters that are relevant for most movement modifiers. 
For example, at. 
For more information please refer to Section 8.9.1.1, “Common parameters”. 
Description Specify a lane for the actor to drive on. 
The lane can be chosed either relative to another physical_object on the road, or relative to the edges of the road. 
Examples Code 36. 
Lane modifier do serial: vehicle1.drive() with: # Drive in lane closest to the right (right is the default) lane(1) do serial: vehicle1.drive() with: # Drive in lane closest to the left side lane(1, from: left) do parallel: vehicle2.drive() vehicle1.drive() with: # Drive one lane left of vehicle2 lane(side_of: vehicle2, side: left) do parallel: vehicle2.drive() vehicle1.drive() with: # At the end of this phase, be either one or two lanes # to the right of vehicle2 lane([1..2], side_of: vehicle2, side: right, at: end) do parallel: vehicle2.drive() vehicle1.drive() with: # Be in the same lane as vehicle2 lane(same_as: vehicle2) do serial: vehicle1.drive() with: # Drive in lane closest to the inner side (closest to opposing traffic) lane(1, from: map.inner_side()) do serial: vehicle1.drive() with: # Drive in lane closest to the outter side (farthest to opposing traffic) lane(1, from: map.outer_side()) 8.9.15 Modifier change_lane() Purpose Specify that the actor changes lane. 
Category Scenario modifier Usage Code 37. 
Change lane modifier change_lane(lane: int, side: side_left_right [, ]) Parameters lane The number of lanes to change, counting from the lane where the actor starts the action. 
The default is 1. 
side Left or right. 
The side is randomized if not specified. 
 A set of parameters that are relevant for most movement modifiers. 
For example, at. 
For more information please refer to Section 8.9.1.1, “Common parameters”. 
Examples Code 38. 
Change lane modifier # Change lane one lane to the left do serial: vehicle1.drive() with: change_lane(side: left) # Change the lane 1, 2 or 3 lanes to the right do serial: vehicle1.drive() with: change_lane([1..3], right) 8.9.16 Modifier keep_lane() Purpose Specify that the actor stays in the current lane. 
Category Scenario modifier Usage Code 39. 
Keep lane modifier keep_lane() Example Code 40. 
Keep lane modifier do serial: vehicle1.drive() with: keep_lane() 8.9.17 Modifier physical_movement() Purpose Set the actor movement to be physical or non-physical. 
Category Scenario modifier Usage Code 41. 
Physical movement modifier physical_movement(option: movement_options) Parameters option Can be: prefer_physical Perform the movement physical if possible. 
prefer_non_physical Perform the non physical way if the implementation allows that. 
For example, a test track may ignore this request. 
must_be_physical (default) An error message is issued, if this action cannot be physically performed for any reason. 
Description Describes the preferences with regard to the physical modeling of the movement of actors in the scenario. 
Examples Code 42. 
Physical movement modifier do serial: vehicle1.drive() with: speed(10kph) vehicle1.drive() with: # If possible, try to make speed jump from 10kph to 20kph in zero time speed(20kph) physical_movement(prefer_non_physical) 8.9.18 Modifier avoid_collisions() Purpose Allow or disallow an actor to collide with another object. 
Category Scenario modifier Usage Code 43. 
Avoid collisions modifier avoid_collisions(avoid: bool) Parameters avoid Either true or false. 
Description By default, all actors avoid collisions (avoid_collisions(true)). 
This means that a runtime mechanism (if exists) for collision avoidance is on for the drive() scenario specified by the modifier. 
When set to false, the actor moves regardless of surrounding traffic and may collide. 
Example Code 44. 
Avoid collisions modifier do serial: vehicle1.drive() with: avoid_collisions(false) 8.9.19 Enum at Specify at which moments within the phase the constraint must hold. 
Values Table 130. 
Enum at Value Comment start This constraint holds at the start of the phase. 
end This constraint holds at the end of the phase. 
all This constraint holds throughout this phase (default). 
8.9.20 Enum movement_mode Values Table 131. 
Enum movement_mode Value Comment monotonous This movement mode adheres to the laws of physics. 
On top of that it limits the level of surprise that a movement may have. 
other Not necessarily monotonous. 
This is the default. 
8.9.21 Enum track Values Table 132. 
Enum track Value Comment actual Track the actual movement of the reference vehicle. 
This is the default. 
projected Track the "projected" movement of the reference vehicle, as it would have been if it kept the speed and direction at the start of the action. 
8.9.22 Enum lat_measure_by Specify the start and end points for lateral distance measurement. 
For example, measuring the distance from the left side of the actor to the right side of the reference physical_object. 
Values Table 133. 
Enum lat_measure_by Value Comment left_to_left From actor left to physical_object left. 
left_to_center From actor left to physical_object center. 
left_to_right From actor left to physical_object right. 
center_to_left From actor center to physical_object left. 
center_to_right From actor center to physical_object right. 
right_to_left From actor right to physical_object left. 
right_to_center From actor right to physical_object center. 
right_to_right From actor right to physical_object right. 
closest Closest lateral distance between object and physical_object. 
8.9.23 Enum yaw_measure_by Specify how relative the yaw angle is measured. 
Defines from which reference line on the actor and to which reference line on the referenced physical_object the yaw angle is measured. 
Values Table 134. 
Enum yaw_measure_by Value Comment length_to_length From actor length to physical_object length. 
length_to_width From actor length to physical_object width. 
width_to_length From actor width to physical_object length. 
width_to_width From actor width to physical_object width. 
relative_to_north Actor yaw relative to geographic North. 
relative_to_road Actor yaw relative to road s-axis. 
8.9.24 Enum orientation_measured_by Specify how to measure the orientation. 
Values Table 135. 
Enum orientation_measured_by Value Comment absolute Measure orientation in world coordinates. 
relative_to_reference Measure orientation relative to a reference physical_object. 
relative_to_road Measure orientation relative to road coordinates. 
8.9.25 Enum movement_options Specify how actor movement should be implemented. 
Values Table 136. 
Enum movement_options Value Comment prefer_physical Perform the movement physical if possible. 
prefer_non_physical Perform the non physical way if the implementation allows that. 
For example, a test track may ignore this request. 
must_be_physical An error message is issued, if this action cannot be physically performed for any reason. 
8.8 Movement actions 8.10 Environment actors

8.10 Environment actors
8.10 Environment actors 8.10.1 Environment In ASAM OpenSCENARIO, all settings or changes to the environment are conducted through the environment actor. 
For a detailed definition of the actions that can be executed by the environment actor, see Section 8.11.1, "Actions for environment". 
8.10.2 Actor environment The environment actor executes all environment actions. 
Note that the environment model is partitioned in a way that facilitates custom extensions and extensions for future versions of ASAM OpenSCENARIO. 
Therefore, some classes may carry only one member variable for the time being. 
For example, instead of adding 'fog_visual_range' as a direct property of the 'environment' actor, the class 'fog' contains visual_range as a property. 
In that way, an extension like adding properties like 'bounding_box' and 'position' to the class 'fog' is easier and readibility is improved at the same time. 
Note that when defining 'geodetic_position' and 'datetime', the position of instances of 'celestial_light_source' (like 'sun' or 'moon') shall be calculated with underlying models resulting also in a change of their position with elapsing simulation time. 
For fixed positions of instances of 'celestial_light_source', their 'celestial_position' shall be set using the assign_celestial_postion action instead. 
Setting this state shall override calculated positions in case 'geodetic_position' and 'datetime' are specified as well. 
Basic information Table 137. 
Basic information of actor environment Instantiable yes Parents osc_actor Parameters Table 138. 
Actor environment Parameter Type Mandatory Description geodetic_position geodetic_position_2d no Geodetic position of world coordinate frame regarding WGS84. 
Regarding usage for determination of angle of celestial light sources see remark above. 
datetime time no Date and time at start of scenario as Unix time, i.e. 
Number of seconds that have elapsed since January 1, 1970 (midnight UTC/GMT), not counting leap seconds. 
Regarding usage for determination of angle of celestial light sources see remark above. 
sun celestial_light_source no Sun as instance of celestial_light_source. 
moon celestial_light_source no Moon as instance of celestial_light_source. 
State variables Table 139. 
State variables of actor environment Variable Type Mandatory Description weather weather no See weather 8.10.2.1 Methods 8.10.2.1.1 Method local_to_unix_time() Returns the unix time from local date and time input. 
Prototype extend environment: def local_to_unix_time(year: uint, month: uint, day: uint, hour: uint, minute: uint, second: uint, time_zone: float) -> time Return value Returns the unix time to be used for environment actor with the local date, time and the time zone as input. 
Parameters Table 140. 
Parameter for method local_to_unix_time() Parameter Type Description year uint Year with century, e.g. 
2022. 
month uint Month in the range of 1 to 12. 
day uint Day of the month in the range of 1 to 31. 
hour uint Hour (24-hour clock) in the range of 0 to 23. 
minute uint Minute in the range of 0 to 59. 
second uint Seconds in the range of 0 to 60, 60 for representing leap seconds. 
time_zone float Time zone offset indicating a positive or negative time difference from UTC/GMT in hours. 
Using type float because e.g. 
Îles Marquises use -9.5. 
8.10.2.2 Examples Code 1. 
Syntax examples for environment actor # instantiate the environment actor environment: environment # set datetime with unix time keep(environment.datetime == 1643764822.0) # alternative: use local_to_unix_time for convenience and better readability keep(environment.datetime == environment.local_to_unix_time(year: 2022, month: 2, day: 2, hour: 2, minute: 20, second: 22, time_zone: 0)) # note: this can be shortened by dropping the names of the arguments while preserving their order keep(environment.datetime == environment.local_to_unix_time(2022, 2, 2, 2, 20, 22, 0)) # set geodetic position keep(environment.geodetic_position.lat == 48.0231718deg) keep(environment.geodetic_position.lon == 11.68087deg) 8.10.3 Struct weather Structure for weather related effects. 
Basic information Table 141. 
Basic information of struct weather Instantiable yes Used by environment Parameters Table 142. 
Struct weather Parameter Type Mandatory Description air air no See air rain precipitation no Liquid water in form of droplets falling under gravity. 
snow precipitation no Frozen water in delicately-crystalline flakes falling under gravity. 
wind wind no See wind fog fog no See fog clouds clouds no See clouds 8.10.4 Struct air Structure for air related effects. 
Basic information Table 143. 
Basic information of struct air Instantiable yes Parents action_for_environment Used by weather Parameters Table 144. 
Struct air Parameter Type Mandatory Description temperature temperature no Temperature on ground level. 
pressure pressure no Atmospheric pressure on ground level. 
relative_humidity float no Relative humidity on ground level. 
Inherited parameters and variables Table 145. 
Inherited parameters and variables of struct air Parent Inherited parameters and variables osc_action duration 8.10.5 Struct precipitation Structure for air related effects for different types of precipitation. 
Basic information Table 146. 
Basic information of struct precipitation Instantiable yes Used by weather Parameters Table 147. 
Struct precipitation Parameter Type Mandatory Description intensity speed no Global intensity of precipitation given as volumetric flux. 
In case of (partially) solid precipitation, the equivalent melted volume shall be considered. 
Note that volumetric flux is describing a volume flow across an area in units of mmph or millimeter_per_hour. 
After reduction, the unit results in the same unit as for speed. 
As of now, it is not possible to define multiple physical types with the same unit. 
Therefore, the speed type is used for volumetrix flux as well. 
8.10.6 Struct wind Properties relating to wind. 
Basic information Table 148. 
Basic information of struct wind Instantiable yes Parents action_for_environment Used by weather Parameters Table 149. 
Struct wind Parameter Type Mandatory Description speed speed yes The expected value of wind speed. 
To estimate the expected value, rolling mean value over a specific short interval (for example, 3s) can be used. 
direction angle yes The origin direction of the wind (not target direction) in the ground/x-y-plane with clockwise increasing values to match common definitions. 
This results in 0 deg for a wind blowing from the North 90 deg for a wind blowing from the East 90 deg, if x-axis and y-axis are mapped to East and North. 
Inherited parameters and variables Table 150. 
Inherited parameters and variables of struct wind Parent Inherited parameters and variables osc_action duration 8.10.7 Struct fog Visible aerosol consisting of water droplets suspended in the air close to ground level. 
Basic information Table 151. 
Basic information of struct fog Instantiable yes Parents action_for_environment Used by weather Parameters Table 152. 
Struct fog Parameter Type Mandatory Description visual_range length yes Value of optical range of visible light in the standard setting, which corresponds to a certain density of fog. 
Inherited parameters and variables Table 153. 
Inherited parameters and variables of struct fog Parent Inherited parameters and variables osc_action duration 8.10.8 Struct clouds Specification of the clouds in the sky. 
Basic information Table 154. 
Basic information of struct clouds Instantiable yes Parents action_for_environment Used by weather Parameters Table 155. 
Struct clouds Parameter Type Mandatory Description cloudiness uint yes Using okta scale to define which portion of the sky is covered with clouds. 
Ranging from 0 for completely clear sky to 8 for a completely overcast sky. 
Values above 8 shall not be used. 
Inherited parameters and variables Table 156. 
Inherited parameters and variables of struct clouds Parent Inherited parameters and variables osc_action duration 8.10.9 Struct celestial_light_source Celestial light sources, typically sun or moon. 
Basic information Table 157. 
Basic information of struct celestial_light_source Instantiable yes State variables Table 158. 
State variables of struct celestial_light_source Variable Type Mandatory Description position celestial_position_2d yes Position of the light source, see definition of physical type celestial_position_2d. 
8.9 Movement modifiers 8.11 Environment actions

8.11 Environment actions
8.11 Environment actions 8.11.1 Actions for environment These actions are executed by the environment actor. 
They can be used to specify the environmental conditions for the scenario. 
8.11.2 Action air Specify state changes that relate to the air. 
Basic information Table 159. 
Basic information of action air Parents action_for_environment Used by weather Controlled states States related to air. 
Action ending The action ends when the action of the same type is invoked. 
Parameters Table 160. 
Action air Parameter Type Mandatory Description temperature temperature no See definition of air struct. 
pressure pressure no See definition of air struct. 
relative_humidity float no See definition of air struct. 
Inherited parameters and variables Table 161. 
Inherited parameters and variables of action air Parent Inherited parameters and variables osc_action duration 8.11.2.1 Examples Code 1. 
Usage of air action environment.air(temperature: temperature [, pressure: pressure] [, relative_humidity: float] [, ]) environment.air(pressure: pressure [, temperature: temperature] [, relative_humidity: float] [, ]) environment.air(relative_humidity: float [, temperature: temperature] [, pressure: pressure] [, ]) Use one, two or all three action parameters. 
The unused parameters mean that the action will not modify the corresponding variable. 
Code 2. 
Examples for air action # All three variables environment.air(15.0celsius, 1050.0hPa, 0.65) environment.air(temperature: 15.0celsius, pressure: 1050.0hPa, relative_humidity: 0.65) # Only temperature and relative humidity (presure is not modified) environment.air(15.0celsius, relative_humidity: 0.65) environment.air(temperature: 15.0celsius, relative_humidity: 0.65) # Only temperature environment.air(15.0celsius) environment.air(temperature: 15.0celsius) # Only pressure environment.air(pressure: 1050.0hPa) # Only relative_humidity environment.air(relative_humidity: 0.65) 8.11.3 Action rain Specify state changes that relate to rain. 
Basic information Table 162. 
Basic information of action rain Parents action_for_environment Controlled states States related to rain. 
Action ending The action ends when the action of the same type is invoked. 
Parameters Table 163. 
Action rain Parameter Type Mandatory Description intensity speed no See definition of precipitation struct. 
Inherited parameters and variables Table 164. 
Inherited parameters and variables of action rain Parent Inherited parameters and variables osc_action duration 8.11.3.1 Examples Code 3. 
Usage of rain action environment.rain(intensity: speed [, ]) In the following example, the rainfall intensity should be 20 mmph. 
Code 4. 
Examples for rain action environment.rain(20.0mmph) environment.rain(intensity: 20.0mmph) 8.11.4 Action snow Specify state changes that relate to snow. 
Basic information Table 165. 
Basic information of action snow Parents action_for_environment Controlled states States related to snow. 
Action ending The action ends when the action of the same type is invoked. 
Parameters Table 166. 
Action snow Parameter Type Mandatory Description intensity speed no See definition of precipitation struct. 
Inherited parameters and variables Table 167. 
Inherited parameters and variables of action snow Parent Inherited parameters and variables osc_action duration 8.11.4.1 Examples Code 5. 
Usage of snow action environment.snow(intensity: speed [, ]) In the following example, the snowfall intensity should be 10 mmph (melted amount). 
Code 6. 
Examples for snow action environment.snow(10.0mmph) environment.snow(intensity: 10.0mmph) 8.11.5 Action wind Specify state changes related to wind. 
Basic information Table 168. 
Basic information of action wind Parents action_for_environment Used by weather Controlled states States related to wind. 
Action ending The action ends when the action of the same type is invoked. 
Parameters Table 169. 
Action wind Parameter Type Mandatory Description speed speed no See definition of wind struct. 
direction angle no See definition of wind struct. 
Inherited parameters and variables Table 170. 
Inherited parameters and variables of action wind Parent Inherited parameters and variables osc_action duration 8.11.5.1 Examples Code 7. 
Usage of wind action environment.wind(speed: speed, direction: angle [, ]) environment.wind(speed: speed [, ]) environment.wind(direction: angle [, ]) In the following example, the wind speed should be 3 m/s with an angle of 45 degrees. 
Code 8. 
Examples for wind action # Both variables environment.wind(3.0mps, 45deg) environment.wind(speed: 3.0mps, direction: 45deg) # Only wind speed environment.wind(3.0mps) environment.wind(speed: 3.0mps) # Only wind direction environment.wind(direction: 45deg) 8.11.6 Action fog Specify state changes related to fog. 
Basic information Table 171. 
Basic information of action fog Parents action_for_environment Used by weather Controlled states States related to fog. 
Action ending The action ends when the action of the same type is invoked. 
Parameters Table 172. 
Action fog Parameter Type Mandatory Description visual_range length no See definition of fog struct. 
Inherited parameters and variables Table 173. 
Inherited parameters and variables of action fog Parent Inherited parameters and variables osc_action duration 8.11.6.1 Examples Code 9. 
Usage of fog action environment.fog(visual_range: length [, ]) In the following example, the visual range due to fog should be within 0.2 km. 
Code 10. 
Examples for fog action environment.fog(0.2km) environment.fog(visual_range: 0.2km) 8.11.7 Action clouds Specify state changes related to clouds. 
Basic information Table 174. 
Basic information of action clouds Parents action_for_environment Used by weather Controlled states States related to clouds. 
Action ending The action ends when the action of the same type is invoked. 
Parameters Table 175. 
Action clouds Parameter Type Mandatory Description cloudiness uint no See definition of clouds struct. 
Inherited parameters and variables Table 176. 
Inherited parameters and variables of action clouds Parent Inherited parameters and variables osc_action duration 8.11.7.1 Examples Code 11. 
Usage of clouds action environment.clouds(cloudiness: uint [, ]) In the following example, the cloudiness level should be 4 oktas. 
Code 12. 
Examples for clouds action environment.clouds(4) environment.clouds(cloudiness: 4) 8.11.8 Action assign_celestial_position This action assigns the position of a celestial_light_source such as sun or moon. 
This will override possibly calculated positions based on geographic location and time. 
Unless this action is invoked again, the position of the celestial_light_source will remain fixed throughout the scenario. 
Basic information Table 177. 
Basic information of action assign_celestial_position Parents action_for_environment Controlled states Position of celestial_light_source. 
Action ending The action ends when the position is reached. 
Parameters Table 178. 
Action assign_celestial_position Parameter Type Mandatory Description light_source celestial_light_source yes Celestial light source whose position will be assigned. 
azimuth angle no See definition of celestial_position_2d struct. 
elevation angle no See definition of celestial_position_2d struct. 
Inherited parameters and variables Table 179. 
Inherited parameters and variables of action assign_celestial_position Parent Inherited parameters and variables osc_action duration 8.11.8.1 Examples Code 13. 
Usage of assign_celestial_position environment.assign_celestial_position(light_source: celestial_light_source, azimuth: angle, elevation: angle [, ]) environment.assign_celestial_position(light_source: celestial_light_source, azimuth: angle [, ]) environment.assign_celestial_position(light_source: celestial_light_source, elevation: angle [, ]) This action assigns the position of a celestial object such as the sun or the moon. 
Using the action will override the celestial positions that would be calculated based on geographic location (geodetic_position) and calendar time (datetime). 
Unless this action is invoked again, the celestial position will remain fixed throughout the scenario. 
Code 14. 
Examples for assign_celestial_position # For moon position environment.assign_celestial_position(environment.moon, 270deg, 90deg) environment.assign_celestial_position(environment.moon, azimuth: 270deg, elevation: 90deg) # For sun position environment.assign_celestial_position(environment.sun, 100deg, 40deg) environment.assign_celestial_position(environment.sun, azimuth: 100deg, elevation: 40deg) # For sun, assign only azimuth environment.assign_celestial_position(environment.sun, azimuth: 100deg) # For sun, assign only elevation environment.assign_celestial_position(environment.sun, elevation: 40deg) 8.10 Environment actors 8.12 Road abstraction classes

8.12 Road abstraction classes
8.12 Road abstraction classes 8.12.1 Class definitions 8.12.2 Struct map A map is the top-level actor that contains the description of the abstract road network. 
Basic information Table 180. 
Basic information of struct map Used by OpenSCENARIO Parameters Table 181. 
Struct map Parameter Type Mandatory Description map_file string no Name of the external map file routes list of route yes The list of routes that are part of the abstract road network junctions list of junction yes The list of junctions that are part of the abstract road network driving_rule driving_rule yes Specify on which side of the road the vehicles drive 8.12.2.1 Methods 8.12.2.1.1 Method odr_to_route_point() Takes a position in ASAM OpenDRIVE coordinates and returns the corresponding ASAM OpenSCENARIO route-coordinates for the point. 
The method returns an error if the point is not on a route. 
Prototype map.odr_to_route_point(…​) → route_point Return value Returns a route_point. 
Parameters Table 182. 
Parameters for method odr_to_route_point() Parameter Type Description road_id string ASAM OpenDRIVE roadId lane_id string Optional. 
ASAM OpenDRIVE laneId. 
If omitted, the t-coordinate is measured from the ASAM OpenDRIVE road reference line. 
If included, the t-coordinate is measured from the ASAM OpenDRIVE lane centerline of the lane. 
s length The s-coordinate in ASAM OpenDRIVE coordinates t length The t-coordinate in ASAM OpenDRIVE coordinates 8.12.2.1.2 Method xyz_to_route_point() Takes a position in world coordinates and returns the corresponding ASAM OpenSCENARIO route-coordinates for the point. 
If the point is not on a route, returns with an error. 
Prototype map.xyz_to_route_point(…​) → route_point Return value Returns a route_point. 
Parameters Table 183. 
Parameters for method xyz_to_route_point() Parameter Type Description x length The x-coordinate in the world-coordinate system. 
y length The y-coordinate in the world-coordinate system. 
z length The z-coordinate in the world-coordinate system. 
8.12.2.1.3 Method route_point_to_xyz() Converts the coordinates specified in route-coordinates into the corresponding world-coordinates. 
Returns a route point in Cartesian (x, y, z) coordinates. 
Prototype map.route_point_to_xyz(…​) → xyz_point Return value Returns an xyz_point. 
Parameters Table 184. 
Parameters for method route_point_to_xyz() Parameter Type Description route_point route_point ASAM OpenSCENARIO route_point to be converted. 
8.12.2.1.4 Method outer_side() Farther from opposing traffic. 
Prototype map.outer_side(): side_left_right Return value Returns right if map.driving_rule is right_hand_traffic, left otherwise. 
8.12.2.1.5 Method inner_side() Closer to opposing traffic. 
Prototype map.inner_side(): side_left_right Return value Returns left if map.driving_rule is right_hand_traffic, right otherwise. 
8.12.2.1.6 Method create_route() Creates a compound_route that contains all the provided route instances, in the same sequential order as the input list. 
Routable point types are connected according to the connect_points_by argument. 
If the connect_points_by field is empty, this method defaults to the option waypoint. 
Prototype map.create_route(…​) → compound_route Return value Returns a compound_route that contains all the specified routes. 
Parameters Table 185. 
Parameters for method create_route() Parameter Type Description routes list of route The route instances to be combined to form the new compound_route. 
connect_points_by connect_route_points Defines how to connect the points in the list of route. 
Default: waypoint. 
legal_route bool The compound route only contains legal route elements. 
Default: true. 
When actors are placed on lanes with no inherent traffic flow direction, like a sidewalk, the initial orientation of the actor within this lane might be ambiguous. 
In this case, it is suggested to use two instances of route_point to disambiguate the preferred initial orientation of the actor. 
The example below demonstrates a pedestrian walking across sidewalk_1 (in the positive t-direction) before taking the crosswalk towards sidewalk_2. 
Syntax Code 1. 
Syntax example map: map my_cross: crossing sidewalk_1, sidewalk_2: lane map.crossing_connects(my_cross, sidewalk_1, sidewalk_2, start_s_coord: 5.0m) sw_pt_1: route_point with: keep(it.route == sidewalk_1) keep( it.s == 5.0m) keep( it.t == -1.0m) sw_pt_2: route_point with: keep(it.route == sidewalk_1) keep( it.s == 5.0m) # same s-coordinate as sw_pt_1 keep( it.t == 0.5m) # t-coordinate to the left of sw_pt_1 create_route([sw_pt_1, sw_pt_2, my_cross, sidewalk_2]) The below example demonstrates a pedestrian walking along sidewalk_1 in negative s-direction before taking the crosswalk towards sidewalk_2. 
Code 2. 
Syntax example map: map my_cross: crossing sidewalk_1, sidewalk_2: lane map.crossing_connects(my_cross, sidewalk_1, sidewalk_2, start_s_coord: 5.0m) sw_pt_1: route_point with: keep(it.route == sidewalk_1) keep(it.s == 10.0m) keep(it.t == 0.0m) sw_pt_2: route_point with: keep(it.route == sidewalk_1) keep(it.s == 5.0m) # s-coordinate smaller than sw_pt_1 keep(it.t == 0.0m) # same t-coordinate as sw_pt_1 create_route([sw_pt_1, sw_pt_2, my_cross, sidewalk_2]) 8.12.2.1.7 Method create_route_point() Creates a route_point. 
Prototype map.create_route_point(…​) → route_point Return value Returns a route_point. 
Parameters Table 186. 
Parameters for method create_route_point() Parameter Type Description route route The route where the point resides s length s-coordinate in the route t length t-coordinate in the route 8.12.2.1.8 Method create_xyz_point() Creates an xyz_point. 
Prototype map.create_xyz_point(…​): xyz_point Return value Returns an xyz_point. 
Parameters Table 187. 
Parameters for method create_xyz_point() Parameter Type Description x length x-coordinate in world-coordinate system y length y-coordinate in world-coordinate system z length z-coordinate in world-coordinate system 8.12.2.1.9 Method create_odr_point() Creates an odr_point. 
Prototype map.create_odr_point(…​) → odr_point Return value Returns an odr_point. 
Parameters Table 188. 
Parameters for method create_odr_point() Parameter Type Description road_id string ASAM OpenDRIVE roadId lane_id string Optional. 
ASAM OpenDRIVE laneId. 
If omitted, the t-coordinate is measured from the ASAM OpenDRIVE road reference line. 
If included, the t-coordinate is measured from the respective ASAM OpenDRIVE lane centerline. 
s length s-coordinate in ASAM OpenDRIVE coordinates t length t-coordinate in ASAM OpenDRIVE coordinates 8.12.2.1.10 Method create_path() Creates a path in world x-y-z-coordinates from a list of pose_3d points. 
Prototype map.create_path(points: list of pose_3d, interpolation: path_interpolation) → path Return value Returns a path in world x-y-z-coordinates. 
Parameters Table 189. 
Parameters for method create_path() Parameter Type Description points list of pose_3d List of points in world x-y-z-coordinates. 
interpolation path_interpolation Choose how to join the points of the path. 
Syntax Code 3. 
Syntax example for create_path() pose1, pose2, pose3: pose_3d keep(pose1.position.x == 23.423) keep(pose1.position.y == 3.43) # Repeat for pose2 and pose3 my_path: path = create_path([pose1, pose2, pose3], smooth) 8.12.2.1.11 Method create_path_odr_points() Creates a path in world x-y-z-coordinates from a list of odr_point points. 
Prototype map.create_path_odr_points(points: list of odr_point, interpolation: path_interpolation, on_road_network: bool) → path Return value Returns a path in world x-y-z-coordinates. 
Parameters Table 190. 
Parameters for method create_path_odr_points() Parameter Type Description points list of odr_point Sequence of odr_point that will be converted to world x-y-z-coordinates to create a path. 
interpolation path_interpolation Choose how to join the points of the path. 
on_road_network bool If set to true, the points of the path must be joined while keeping the whole path on the road network. 
Syntax Code 4. 
Syntax example for create_path_odr_points() pt1: odr_point = create_odr_point(road_id: 12, lane_id: 1, s: 10m, t: 0.2m) pt2: odr_point = create_odr_point(road_id: 12, lane_id: 2, s: 25m, t: 0.0m) pt3: odr_point = create_odr_point(road_id: 13, lane_id: 1, s: 30m, t: 0.0m) my_path: path = create_path_odr_points([pt1, pt2, pt3], smooth, true) 8.12.2.1.12 Method create_path_route_points() Creates a path in world x-y-z-coordinates from a list of route_point points. 
Prototype map.create_path_route_points(points: list of route_point, interpolation: path_interpolation, on_road_network: bool) → path Return value Returns a path in world x-y-z-coordinates. 
Parameters Table 191. 
Parameters for method create_path_route_points() Parameter Type Description points list of route_point Sequence of route_point that will be converted to world x-y-z-coordinates to create a path. 
interpolation path_interpolation Choose how to join the points of the path. 
on_road_network bool If set to true, the points of the path must be joined while keeping the whole path on the road network. 
Syntax Code 5. 
Syntax example for create_path_route_points() pt1, pt2, pt3: route_point keep(pt1.route == my_road) keep(pt1.s == 120.0m) keep(pt1.t == 5.3m) # Add similar constraints for pt2 and pt3 my_path: path = create_path_route_points([pt1, pt2, pt3], smooth, true) 8.12.2.1.13 Method create_trajectory() Creates a trajectory in world x-y-z-coordinates from a list of pose_3d points and time stamps. 
Prototype map.create_trajectory(points: list of pose_3d, time_stamps: list of time,interpolation: path_interpolation) → trajectory stanReturn value Returns a trajectory in world x-y-z-coordinates. 
Parameters Table 192. 
Parameters for method create_trajectory() Parameter Type Description points list of pose_3d List of points in world x-y-z-coordinates. 
time_stamps list of time Time stamps for each element in points. 
The lists time_stamps and points must have the same length. 
interpolation path_interpolation Choose how to join the points of the trajectory. 
Code 6. 
Syntax example for create_trajectory() pose1, pose2, pose3: pose_3d keep(pose1.position.x == 23.423) keep(pose1.position.y == 3.43) # Repeat for pose2 and pose3 time_stamps: list of time = [0s, 2s, 5s] my_trajectory: trajectory = create_trajectory([pose1, pose2, pose3], time_stamps, smooth) 8.12.2.1.14 Method create_trajectory_odr_points() Creates a trajectory in world x-y-z-coordinates from a list of odr_point points. 
Prototype map.create_trajectory_odr_points(points: list of odr_point, time_stamps: list of time, interpolation: path_interpolation, on_road_network: bool) → trajectory Return value Returns a trajectory in world x-y-z-coordinates. 
Parameters Table 193. 
Parameters for method create_trajectory_odr_points() Parameter Type Description points list of odr_point Sequence of odr_point that will be converted to world x-y-z-coordinates to create a trajectory. 
time_stamps list of time Time stamps for each element in points. 
The lists time_stamps and points must have the same length. 
interpolation path_interpolation Choose how to join the points of the trajectory. 
on_road_network bool If set to true, the points of the trajectory must be joined while keeping the whole trajectory on the road network. 
Syntax Code 7. 
Syntax example for create_trajectory_odr_points() pt1: odr_point = create_odr_point(road_id: 12, lane_id: 1, s: 10m, t: 0.2m) pt2: odr_point = create_odr_point(road_id: 12, lane_id: 2, s: 25m, t: 0.0m) pt3: odr_point = create_odr_point(road_id: 13, lane_id: 1, s: 30m, t: 0.0m) time_stamps: list of time = [0s, 2s, 5s] my_trajectory: trajectory = create_trajectory_odr_points([pt1, pt2, pt3], time_stamps, smooth, true) 8.12.2.1.15 Method create_trajectory_route_points() Creates a trajectory in world x-y-z-coordinates from a list of route_point points. 
Prototype map.create_trajectory_route_points(points: list of route_point, time_stamps: list of time, interpolation: path_interpolation, on_road_network: bool) → trajectory Return value Returns a trajectory in world x-y-z-coordinates. 
Parameters Table 194. 
Parameters for method create_trajectory_route_points() Parameter Type Description points list of route_point Sequence of route_point that will be converted to world x-y-z-coordinates to create a trajectory. 
time_stamps list of time Time stamps for each element in points. 
The lists time_stamps and points must have the same length. 
interpolation path_interpolation Choose how to join the points of the trajectory. 
on_road_network bool If set to true, the points of the trajectory must be joined while keeping the whole trajectory on the road network. 
Syntax Code 8. 
Syntax example for create_trajectory_route_points() pt1, pt2, pt3: route_point keep(pt1.route == my_road) keep(pt1.s == 120.0m) keep(pt1.t == 5.3m) # Add similar constraints for pt2 and pt3 time_stamps: list of time = [0s, 2s, 5s] my_trajectory: trajectory = create_trajectory_route_points([pt1, pt2, pt3], time_stamps, smooth) 8.12.2.1.16 Method resolve_relative_path() Creates a path from a relative_path by implementing the following steps: Sample the pose of the reference entity. 
Use this pose as the origin to establish the appropriate coordinate system for the list of points that are provided in the relative_path. 
Compute the world x-y-z-coordinates of the list of points. 
Return this list of points in a path. 
Prototype map.resolve_relative_path(relative_path: relative_path, reference: physical_object, transform: relative_transform) → path Return value Returns a path in world x-y-z-coordinates. 
Parameters Table 195. 
Parameters for method map.resolve_relative_path() Parameter Type Description relative_path relative_path The relative path to be resolved to absolute x-y-z-coordinates. 
reference physical_object Reference entity that marks the origin to resolve the list of points. 
transform relative_transform Type of transformation to resolve relative points into absolute coordinates 8.12.2.1.17 Method resolve_relative_trajectory() Creates a trajectory from a relative_trajectory by implementing the following steps: Sample the pose of the reference entity. 
Use this pose as the origin to establish the appropriate coordinate system for the list of points provided in the relative_trajectory. 
Compute the world x-y-z-coordinates of the list of points. 
Return this list of points in a trajectory. 
The time stamps remain unchanged. 
Prototype map.resolve_relative_trajectory(relative_trajectory: relative_trajectory, reference: physical_object, transform: relative_transform) → trajectory Return value Returns a trajectory in world x-y-z-coordinates. 
Parameters Table 196. 
Parameters for method resolve_relative_trajectory() Parameter Type Description relative_trajectory relative_trajectory The relative trajectory to be resolved to absolute x-y-z-coordinates. 
reference physical_object Reference entity that marks the origin to resolve the list of points. 
transform relative_transform Type of transformation to resolve relative points into absolute coordinates 8.12.2.1.18 Method get_map_file() Prototype map.get_map_file(): string Return value Returns a string with the path and file name of the map_file. 
8.12.2.2 Modifiers 8.12.2.2.1 Modifier number_of_lanes() Creates constraints for the number of lanes within a route by lane type, lane use and/or lane directionality. 
Parameters Table 197. 
Parameters for modifier map.number_of_lanes() Parameter Type Description route route Mandatory. 
The route that will have these constraints. 
num_of_lanes uint Mandatory. 
The desired number of lanes. 
lane_type lane_type Optional. 
Apply the constraint to the number of lanes with this type. 
lane_use lane_use Optional. 
Apply the constraint to the number of lanes with this use. 
directionality directionality Optional. 
Apply the constraint to the number of lanes with this directionality. 
Syntax city_road: road map.number_of_lanes(city_road, 1, pedestrian) map.number_of_lanes(city_road, 2, driving, directionality: uni_direction) map.number_of_lanes(city_road, 1, lane_use: mixed_traffic_vru) highway_ls: lane_section num: int with: keep(it >= 3) # constrained number map.number_of_lanes(highway_ls, 0, pedestrian) map.number_of_lanes(highway_ls, num, driving, directionality: uni_direction) map.number_of_lanes(highway_ls, 2, non_driving, lane_use: stop) map.number_of_lanes(highway_ls, 1, non_driving, lane_use: median) 8.12.2.2.2 Modifier routes_are_in_sequence() Specifies that one route follows another in successive order. 
Parameters Table 198. 
Parameters for modifier map.routes_are_in_sequence() Parameter Type Description preceding route The first route succeeding route The second route, which follows after the first route. 
road road Optional. 
The road that will contain this sequence of routes. 
Syntax lane1, lane2: lane routes_are_in_sequence(preceding: lane1, succeeding: lane2) my_road: road ls_a, la_b: lane_section routes_are_in_sequence(preceding: ls_a, succeeding: ls_b, road: my_road) 8.12.2.2.3 Modifier roads_follow_in_junction() Defines a legal route through a junction. 
Table 199. 
Parameters for modifier map.roads_follow_in_junction() Parameter Type Description junction junction The junction to be used. 
in_road road The chosen road that leads into the junction. 
out_road road The chosen road that leads away from the junction. 
direction junction_direction Indicates the direction of the out_road relative to the in_road. 
clockwise_count uint out_road is clockwise_count roads from in_road, counting clockwise. 
Values larger than number_of_roads are illegal. 
Example: For a four-way junction, clockwise_count can have the following values: 1: Left 2: Straight 3: Right 4: U-turn number_of_roads uint Total number of in_roads connected to the junction. 
in_lane lane The chosen lane within in_road. 
out_lane lane The chosen lane within out_road. 
junction_route route The element(s) that connect the in_lane or in_road to the out_lane or out_road within the junction. 
resulting_route route The route going from in_lane or in_road to the out_lane or out_road. 
8.12.2.2.4 Modifier routes_overlap() Specifies that two routes overlap longitudinally, see routes overlap. 
For example, two lanes in a lane section are considered to overlap. 
Two parallel roads running in the opposite direction are also considered to overlap. 
Table 200. 
Parameters for modifier map.routes_overlap() Parameter Type Description route1 route The first of the overlapping routes. 
route2 route The second of the overlapping routes. 
overlap_kind route_overlap_kind The type of expected overlap. 
Notice route1 is considered the first route to interpret the values of the enum. 
8.12.2.2.5 Modifier lane_side() Specifies the side relation between two instances of lane. 
Table 201. 
Parameters for modifier map.lane_side() Parameter Type Description lane1 lane The first lane. 
side side_left_right Locate lane1 on this side of lane2. 
lane2 lane The second lane. 
count uint For a count of n, there are n-1 lanes between the two instances. 
lane_section lane_section Optional. 
The lane_section where the lanes reside. 
Syntax example: lane_a, lane_b: lane map.lane_side(lane_a, left, lane_b) my_ls: lane_section lane_c, lane_d: lane map.lane_side(lane_c, right, lane_d, 2, my_ls) 8.12.2.2.6 Modifier compound_lane_side() Specifies side relation between two instances of compound_lane. 
Table 202. 
Parameters for modifier map.compound_lane_side() Parameter Type Description lane1 compound_lane The first compound_lane. 
side side_left_right Locate lane1 on this side of lane2. 
lane2 compound_lane The second compound_lane. 
count uint For a count of n, there are n-1 lanes between the two instances. 
route route Optional. 
The route where the compound lanes reside. 
8.12.2.2.7 Modifier end_lane() The lane ends in its lane_section and has no successor in the next lane_section. 
Parameters Table 203. 
Parameters for modifier map.end_lane() Parameter Type Description lane lane This lane ends in its current lane_section. 
Syntax ls_a, ls_b: lane_section my_road: road map.routes_are_in_sequence(preceeding: ls_a, succeeding: ls_b, road: my_road) my_ending_lane: lane with: keep(it.lane_section == ls_a) map.end_lane(my_ending_lane) 8.12.2.2.8 Modifier start_lane() The lane starts in its lane_section and has no predecessor in the previous lane_section. 
Parameters Table 204. 
Parameters for modifier map.start_lane() Parameter Type Description lane lane This lane starts in its current lane_section. 
Syntax ls_a, ls_b: lane_section my_road: road map.routes_are_in_sequence(preceding: ls_a, succeeding: ls_b, road: my_road) my_starting_lane: lane with: keep(it.lane_section == ls_b) map.start_lane(my_starting_lane) 8.12.2.2.9 Modifier crossing_connects() Connect a crossing between two lanes. 
The s-coordinate of the crossing increases from the start_lane to end_lane. 
If the start_angle argument is not specified, the default solves the connection with start_angle of 90 deg and a straight line to the end_lane. 
Parameters Table 205. 
Parameters for modifier map.crossing_connects() Parameter Type Description crossing crossing The crossing that will be connected to the specified lanes. 
start_lane lane The lane where crossing starts (starting from the lane’s centerline). 
end_lane lane The destination lane where the crossing ends (ending on the lane’s centerline). 
start_s_coord length The crossing origin derived from a s-position along the centerline of start_lane. 
start_angle angle Optional. 
The angle at which the straight centerline of the crossing originates from the start lane. 
Default is perpendicular. 
Syntax my_cross: crossing sidewalk_1, sidewalk_2: lane map.crossing_connects(my_cross, sidewalk_1, sidewalk_2, 5m) my_cross: crossing sidewalk_3, sidewalk_4: lane map.crossing_connects(my_cross, sidewalk_3, sidewalk_4, 5m, 60deg) In the future geometric constraints could be used within this modifier if the approach to the end_lane was an unusual shape rather than a straight line. 
8.12.2.2.10 Modifier routes_are_opposite() Specifies that two routes are in opposite directions. 
Table 206. 
Parameters for modifier map.routes_are_opposite() Parameter Type Description route1 route The first uni-directional route. 
route2 route The second uni-directional route. 
If route1 has no opposite, then route2 is null. 
containing_road road The road to which both routes belong. 
lateral_overlap lateral_overlap_kind Specifies if the routes overlap lateral, meaning they become a single two-way lane. 
8.12.2.2.11 Modifier set_map_file() Setting a map file. 
Parameters Table 207. 
Parameters for modifier map.set_map_file() Parameter Type Description file string The path and file name for the map file. 
Syntax map.set_map_file("path/to/map/my_odr_map.xodr") 8.12.3 Enum driving_rule Values Table 208. 
Enum driving_rule Value Comment left_hand_traffic Traffic drives on the left side of the road right_hand_traffic Traffic drives on the right side of the road 8.12.4 Struct junction A junction connects roads. 
Basic information Table 209. 
Basic information of struct junction Used by map Parameters Table 210. 
Struct junction Parameter Type Mandatory Description roads list of road yes List of road elements that are connected to this junction 8.12.5 Struct route A route is a location where a movable_object can move, creating a behavioral pathway for the actors in the scenario. 
An instance of route can be a single route_element (for example, lane), or it can be composed of a sequence with multiple instances of route_element. 
The s-t-coordinates in a route: Each route has an s-t-coordinate system. 
The s-axis increases longitudinally along the route. 
The t-axis is perpendicular to the s-axis, following the right-hand-rule, with positive values to the left side of the s-axis. 
In modifiers that specify movement relative to another reference entity, this implies using the s-t-coordinates of the lane where the reference vehicle is located. 
Example: car1.drive() with: position(100m, ahead_of: car2) measures the 100 m relative to the lane that car2 is in. 
The result of requesting drive() along a split route or a bi-directional route is undefined. 
The request should result in an error, unless the direction is specified in some other way. 
Basic information Table 211. 
Basic information of struct route Children compound_lane, compound_route, path, route_element Used by map Parameters Table 212. 
Struct route Parameter Type Mandatory Description length length no Nominal length of the route, measured along the s-axis of the route. 
Does not apply to route_point directionality directionality yes Directionality for movement of traffic_participant actors on the route min_lanes uint no Minimum number of drivable lanes along this route. 
Applies only to these children: road, lane_section max_lanes uint no Maximum number of drivable lanes along this route. 
Applies only to these children: road, lane_section anchors list of string no The strings in here can be matched to unique items in the map files specified in file_name 8.12.5.1 Methods 8.12.5.1.1 Method start_point() Returns the start point of the route, where the s-coordinate has its minimum value (typically zero). 
Prototype route.start_point(…​) → route_point Return value Returns a route_point. 
8.12.5.1.2 Method end_point() Returns the end point of the route, where the s-coordinate has its maximum value. 
The difference between the maximum and minimum values of the s-coordinate on the route is equal to the length of the route measured along the s-axis of the route. 
Prototype route.end_point(…​) → route_point Return value Returns a route_point. 
8.12.6 Enum directionality Directionality of the route Values Table 213. 
Enum directionality Value Comment uni_direction A traffic_participant can move legally in only one direction along the longitudinal s-axis. 
Usually applies to lane_type driving and vru_vehicles bi_direction A traffic_participant can move legally in both directions along the longitudinal s-axis. 
Usually applies to lane_type driving and vru_vehicles split Applies for multi-lane elements: there are lanes with opposing uni_direction traffic flow within the route free A traffic_participant can legally move in any direction (longitudinal or lateral). 
Usually applies to lane_type pedestrian or lane_use mix_traffic_vru none No expected traffic flow. 
Usually applies to lane_type non_driving other Other type of directionality 8.12.7 Struct route_element A route_element that is a lower-level route, which can be used individualy, or can eb part of a compound_route. 
Basic information Table 214. 
Basic information of struct route_element Parents route Children crossing, lane, lane_section, odr_point, path, road, route_point, xyz_point Inherited parameters and variables Table 215. 
Inherited parameters and variables of struct route_element Parent Inherited parameters and variables route length, directionality, min_lanes, max_lanes, anchors 8.12.8 Struct road A road is composed by ordered lists of lane_section, organized end-to-end (longitudinal direction, or s-direction). 
A road is composed of instances of lane_section arranged end-to-end. 
A road can only be connected with another road in a junction. 
A road has two separate ordered lists of lane_section: The s_positive (mandatory) list of lane_section contains the uni-directional lanes flowing in the positive road-s-direction. 
The s_negative (optional) list of lane_section contains the uni-directional lanes flowing in the negative road-s-direction. 
Both lists can include lanes with other directionalities. 
Successive lane_section elements in the list can have different properties (number of lanes, lane types, lane use, directionality, and so on). 
A road has an s-t-coordinate system. 
The s-axis of the road coincides with the s-axis of s_positive. 
A road can only be connected with another road in a junction. 
Basic information Table 216. 
Basic information of struct road Parents route_element Has connection to junction Parameters Table 217. 
Struct road Parameter Type Mandatory Description s_positive list of lane_section yes List of lane_section elements that flow in the positive direction of the road s-axis s_negative list of lane_section no List of lane_section elements that flow in the negative direction of the road s-axis Inherited parameters and variables Table 218. 
Inherited parameters and variables of struct road Parent Inherited parameters and variables route length, directionality, min_lanes, max_lanes, anchors 8.12.9 Struct lane_section A block of one or more lanes, organized side-by-side (lateral direction, or T-direction). 
A section composed of lanes arranged side-by-side. 
A road can be composed of one or multiple instances of lane_section arranged end-to-end. 
Lane sections are useful for these purposes: Change the number of lanes over the course of a single road. 
Change the type of lanes within a single road. 
Change the use of lanes within a single road. 
Change the directionality of lanes within a single road. 
The representation of lane_section is similar to the implementation in ASAM OpenDRIVE. 
The number of lanes is constant in the whole lane section. 
Lanes cannot change lane_type or lane_use or directionality within the lane section. 
A lane section has an s-t-coordinate system. 
The s-axis of the lane section coincides with the s-axis of the lane chosen with the (mandatory) s_axis property. 
Basic information Table 219. 
Basic information of struct lane_section Parents route_element Used by road Parameters Table 220. 
Struct lane_section Parameter Type Mandatory Description road road yes Where the lane_section resides lanes list of lane yes List of lanes that compose the lane_section s_axis lane yes Choose, which lane is used to determine the s-axis of the lane_section. 
Must be a member of it.lanes Inherited parameters and variables Table 221. 
Inherited parameters and variables of struct lane_section Parent Inherited parameters and variables route length, directionality, min_lanes, max_lanes, anchors 8.12.10 Struct lane A lane is pathway that has limits for movement. 
These limits are typically indicated by lane lines providing an indication of boundaries to traffic participants. 
A lane has an s-t-coordinate system. 
The lane s-axis goes along the centerline of the lane. 
The lane t-axis is perpendicular to the s-axis, following the right-hand-rule. 
For a lane with directionality == uni_directional, the legal traffic always moves in the positive s-direction. 
One or multiple adjacent lanes arranged side-by-side compose a lane_section. 
Basic information Table 222. 
Basic information of struct lane Parents route_element Used by lane_section Parameters Table 223. 
Struct lane Parameter Type Mandatory Description lane_section lane_section yes Where the lane resides lane_type lane_type yes Type of lane lane_use lane_use yes A subtype of the lane_type. 
Use compatible pairs of lane_type and lane_use width length no Nominal width of the lane Inherited parameters and variables Table 224. 
Inherited parameters and variables of struct lane Parent Inherited parameters and variables route length, directionality, min_lanes, max_lanes, anchors 8.12.11 Struct crossing A crossing is overlaid on existing lanes. 
It allows different types of usage to take place on the same surface. 
A typical example is a crosswalk overlaid on drivable lanes. 
Basic information Table 225. 
Basic information of struct crossing Parents route_element Parameters Table 226. 
Struct crossing Parameter Type Mandatory Description start_lane lane yes Crossing starts on this lane end_lane lane yes Crossing ends on this lane start_s_coord length yes On the starts_from lane, the crossing connects at this point in the lane s-axis (and zero in the t-axis) end_s_coord length yes On the ends_on lane, the crossing connects at this point in the lane s-axis (and zero in the t-axis) width length yes Nominal width of the crossing, measured perpendicular to the crossing s-axis crossing_type crossing_type yes Type of crossing Inherited parameters and variables Table 227. 
Inherited parameters and variables of struct crossing Parent Inherited parameters and variables route length, directionality, min_lanes, max_lanes, anchors 8.12.12 Enum lane_type Basic information Table 228. 
Basic information of enum lane_type Used by lane Values Table 229. 
Enum lane_type Value Comment driving Driving lane for road vehicles. 
See the driving_lane_use subtype non_driving Non-driving lanes in road vehicles infrastructure. 
See the non_driving_lane_use subtype vru_vehicles Lanes designated for VRU vehicles. 
See the vru_vehicles_lane_use subtype pedestrian Lanes for pedestrians. 
See the pedestrian_lane_use subtype other If the lane has another type 8.12.13 Enum lane_use Subtype of the lane_type enum. 
lane_use contains all values from all use types Basic information Table 230. 
Basic information of enum lane_use Used by lane Values Table 231. 
Enum lane_use Value Comment normal A normal driving lane for road vehicles (OSI). 
Should be used in combination with lane_type == driving. 
exit A deceleration lane in parallel to the main road (OSI). 
Should be used in combination with lane_type == driving. 
entry An acceleration lane in parallel to the main road (OSI). 
Should be used in combination with lane_type == driving. 
on_ramp A ramp from rural or urban roads joining a motorway (OSI). 
Should be used in combination with lane_type == driving. 
off_ramp A ramp leading off a motorway onto rural or urban roads (OSI). 
Should be used in combination with lane_type == driving. 
conecting_ramp A ramp that connects two motorways (OSI). 
Should be used in combination with lane_type == driving. 
hov A lane for High Occupancy Vehicles (HOV), usually in highways. 
Should be used in combination with lane_type == driving. 
bus A lane restricted for use only by busses. 
Should be used in combination with lane_type == driving. 
mixed_traffic_vru A lane for mixed car and vru (vehicle and pedestrian) traffic, normally in urban areas. 
Should be used in combination with lane_type == driving or vru_vehicles. 
parking A lane with parking spaces (OSI). 
Should be used in combination with lane_type == non_driving. 
stop A hard shoulder on motorways for emergency stops (OSI). 
Should be used in combination with lane_type == non_driving. 
restricted A lane on which road vehicles should not drive (OSI). 
Should be used in combination with lane_type == non_driving. 
border A hard border on the edge of a road (OSI). 
Should be used in combination with lane_type == non_driving. 
shoulder A soft border on the edge of a road (OSI). 
Should be used in combination with lane_type == non_driving. 
curb An elevated surface with different height compared to the drivable lanes. 
Should be used in combination with lane_type == non_driving. 
median An innacessible lane for road vehicles and pedestrians. 
Typically used to separate the traffic. 
Should be used in combination with lane_type == non_driving. 
bicycle A lane that is designated for bicycles (OSI). 
Should be used in combination with lane_type == vru_vehicles. 
motorcycle A lane that is designated for motorcycles. 
Should be used in combination with lane_type == vru_vehicles. 
sidewalk A lane that is designated for pedestrians (OSI). 
Should be used in combination with lane_type == pedestrian. 
protected_sidewalk A lane for pedestrians with a barrier to separate it from road traffic. 
Should be used in combination with lane_type == pedestrian. 
none The lane has no use. 
other The lane has another use. 
8.12.14 Enum side_left_right Values Table 232. 
Enum side_left_right Value Comment left On the left side of the lane right On the right side of the lane 8.12.15 Enum lon_lat Values Table 233. 
Enum lon_lat Value Comment longitudinal Refers to longitudinal direction lateral Refers to lateral direction 8.12.16 Struct crossing_type Basic information Table 234. 
Basic information of struct crossing_type Used by crossing Parameters Table 235. 
Struct crossing_type Parameter Type Mandatory Description marking crossing_marking no Define the type of markings on the crossing use crossing_use no Define the type of use for the crossing elevation crossing_elevation no Define the type of elevation for the crossing 8.12.17 Enum crossing_marking Basic information Table 236. 
Basic information of enum crossing_marking Used by crossing_type Values Table 237. 
Enum crossing_marking Value Comment unmarked No crossing-markings on the road marked The road or walking surface has markings that indicate a crossing zebra Common type of marked crossing with thick zebra stripes other Other type of markings for the crossing 8.12.18 Enum crossing_use Basic information Table 238. 
Basic information of enum crossing_use Used by crossing_type Values Table 239. 
Enum crossing_use Value Comment pedestrian Crossing is used by pedestrians (person, animal) and/or vehicles that usually move on sidewalks (wheelchair, stroller) animal Animal crossing. 
For example, on a rural road or highway bicycle Crossing for bicycles rail_road Crosing for rail vehicles (train, subway, tram, …​) other Other use for crossing 8.12.19 Enum crossing_elevation Basic information Table 240. 
Basic information of enum crossing_elevation Used by crossing_type Values Table 241. 
Enum crossing_elevation Value Comment road_level Crossing is at same level as driving surface curb_level Crossing is elevated from driving surface, often at the same level as a walking surface (sidewalk) or curb refuge_island Along the crossing, the elevation may change between road and curb levels. 
For example, with refugre island(s) in the middle other Another elevation type 8.12.20 Struct compound_route A compound_route is a connected sequence of route elements. 
Basic information Table 242. 
Basic information of struct compound_route Parents route Parameters Table 243. 
Struct compound_route Parameter Type Mandatory Description route_elements list of route_element yes A list of route_element. 
Inherited parameters and variables Table 244. 
Inherited parameters and variables of struct compound_route Parent Inherited parameters and variables route length, directionality, min_lanes, max_lanes, anchors 8.12.21 Struct compound_lane A connected sequence of lanes. 
Basic information Table 245. 
Basic information of struct compound_lane Parents route Parameters Table 246. 
Struct compound_lane Parameter Type Mandatory Description lanes list of lane yes A list of lane Inherited parameters and variables Table 247. 
Inherited parameters and variables of struct compound_lane Parent Inherited parameters and variables route length, directionality, min_lanes, max_lanes, anchors 8.12.22 Enum junction_direction In a junction, indicate the direction of the out_road relative to the in_road, measuring the angle clockwise. 
All angles +/- 10 deg. 
Values Table 248. 
Enum junction_direction Value Comment straight The out_road is 0deg realtive to the in_road right The out_road is 90deg realtive to the in_road u_turn The out_road is 180deg realtive to the in_road left The out_road is 270deg realtive to the in_road other If none of the above apply 8.12.23 Enum route_overlap_kind What type of longitudinal overlap is expected for a pair of routes. 
Values Table 249. 
Enum route_overlap_kind Value Comment equal Both routes have the same length, and coincide at the start and end points start Both routes coincide at their start points end Both routes coincide at their end points inside The first route is fully inside the second route. 
Their start and end points do not have to concide any Any part of the first route ovelaps with any part of the second route. 
other If none of the above apply 8.12.24 Enum lateral_overlap_kind Type of lateral overlap is expected for a pair of routes. 
Values Table 250. 
Enum lateral_overlap_kind Value Comment never The two routes never overlap laterally. 
They never share a common lane. 
sometimes In some segments of the route, the two routes can share a common lane. 
always The always routes share a common lane. 
8.12.25 Struct route_point A point on the route network specified in route (S-T) coordinates. 
Basic information Table 251. 
Basic information of struct route_point Parents route_element Used by relative_path_st, relative_trajectory_st Parameters Table 252. 
Struct route_point Parameter Type Mandatory Description route route Yes route in which this point is located s length No Coordinate along the s-axis of the corresponding route t length No Coordinate along the t-axis of the corresponding route Inherited parameters and variables Table 253. 
Inherited parameters and variables of struct route_point Parent Inherited parameters and variables route length, directionality, min_lanes, max_lanes, anchors 8.12.26 Struct xyz_point A pose in space specified in Cartesian (XYZ) coordinates. 
Basic information Table 254. 
Basic information of struct xyz_point Parents route_element Parameters Table 255. 
Struct xyz_point Parameter Type Mandatory Description position position_3d No Position in Cartesian (XYZ) coordinates Inherited parameters and variables Table 256. 
Inherited parameters and variables of struct xyz_point Parent Inherited parameters and variables route length, directionality, min_lanes, max_lanes, anchors 8.12.27 Struct odr_point A point expressed in ASAM OpenDRIVE coordinates. 
Basic information Table 257. 
Basic information of struct odr_point Parents route_element Used by relative_path_odr, relative_trajectory_odr Parameters Table 258. 
Struct odr_point Parameter Type Mandatory Description road_id string Yes ASAM OpenDRIVE identifier for the road lane_id string No ASAM OpenDRIVE identifier for the lane. 
If specified, the t-coordinate is measured from the lane centerline. 
If not specified, the t-coordinate is measured from the ASAM OpenDRIVE reference line s length No Coordinate along the ASAM OpenDRIVE s-axis t length No Coordinate along the ASAM OpenDRIVE t-axis Inherited parameters and variables Table 259. 
Inherited parameters and variables of struct odr_point Parent Inherited parameters and variables route length, directionality, min_lanes, max_lanes, anchors 8.12.28 Enum connect_route_points When building a compound_route, determine which route_element shall be used to compose the compound_route if routable point types (i.e. 
xyz_point, route_point or odr_point) are part of the list. 
Values Table 260. 
Enum connect_route_points Value Comment road Use the road element that contains this point lane_section Use the lane_section element that contains this point lane Use the lane element that contains this point crossing Use the crossing element that contains this point waypoint Use the point itself. 
The route must pass exactly through this point 8.12.29 Struct path An absolute path expressed in Cartesian (XYZ) coordinates, measured in the global world coordinate system. 
Basic information Table 261. 
Basic information of struct path Parents route, route_element Parameters Table 262. 
Struct path Parameter Type Mandatory Description points listi of pose_3d Yes List of points in world x-y-z-coordinates. 
The individual pose_3d elements can have unconstrained coordinates. 
interpolation path_interpolation yes Choose how to join the points of the path. 
Inherited parameters and variables Table 263. 
Inherited parameters and variables of struct path Parent Inherited parameters and variables route length, directionality, min_lanes, max_lanes, anchors 8.12.30 Struct relative_path A relative path is a sequence of points measured with respect to a reference entity. 
These points can be expressed in Cartesian (XYZ), route (S-T) or ASAM OpenDRIVE coordinates. 
Basic information Table 264. 
Basic information of struct relative_path Children relative_path_odr, relative_path_pose_3d, relative_path_st Parameters Table 265. 
Struct relative_path Parameter Type Mandatory Description interpolation path_interpolation yes Choose how to join the points of the path. 
8.12.31 Struct relative_path_pose_3d A relative path expressed in Cartesian (XYZ) coordinates, measured in the local coordinate frame of the reference entity. 
Basic information Table 266. 
Basic information of struct relative_path_pose_3d Parents relative_path Parameters Table 267. 
Struct relative_path_pose_3d Parameter Type Mandatory Description points listi of pose_3d Yes List of points in world x-y-z-coordinates. 
The individual pose_3d elements can have unconstrained coordinates. 
Inherited parameters and variables Table 268. 
Inherited parameters and variables of struct relative_path_pose_3d Parent Inherited parameters and variables relative_path interpolation 8.12.32 Struct relative_path_st A relative path expressed in route (S-T) coordinates, measured with respect to a reference entity. 
Basic information Table 269. 
Basic information of struct relative_path_st Parents relative_path Parameters Table 270. 
Struct relative_path_st Parameter Type Mandatory Description points list of route_point Yes Sequence of route_point that form the relative path Inherited parameters and variables Table 271. 
Inherited parameters and variables of struct relative_path_st Parent Inherited parameters and variables relative_path interpolation 8.12.33 Struct relative_path_odr A relative path expressed in ASAM OpenDRIVE coordinates, measured with respect to a reference entity. 
Basic information Table 272. 
Basic information of struct relative_path_odr Parents relative_path Parameters Table 273. 
Struct relative_path_odr Parameter Type Mandatory Description points list of odr_point Yes Sequence of odr_point that form the relative path Inherited parameters and variables Table 274. 
Inherited parameters and variables of struct relative_path_odr Parent Inherited parameters and variables relative_path interpolation 8.12.34 Enum path_interpolation Choose how to join the list of points in a path or trajectory Values Table 275. 
Enum path_interpolation Value Comment straight_line Join the points with straight lines smooth Join the points with a smooth line 8.12.35 Enum relative_transform Type of transformation to resolve relative points into absolute coordinates Basic information Table 276. 
Basic information of enum relative_transform Used by follow_path, follow_trajectory, replay_path, replay_trajectory Values Table 277. 
Enum relative_transform Value Comment world_relative Use the global coordinate system axes object_relative Use the reference object local coordinate system axes road_relative Use the s-t coordinate system of the road where the reference object is located lane_relative Use the s-t coordinate system of the lane where the reference object is located 8.12.36 Struct trajectory An absolute trajectory expressed in Cartesian (XYZ) coordinates, measured in the global world coordinate system. 
Basic information Table 278. 
Basic information of struct trajectory Used by hidden Parameters Table 279. 
Struct trajectory Parameter Type Mandatory Description points listi of pose_3d Yes List of points in world x-y-z-coordinates. 
The individual pose_3d elements can have unconstrained coordinates. 
time_stamps listi of time Yes Time stamps for each element in points. 
The lists time_stamps and points must have the same length. 
interpolation path_interpolation yes Choose how to join the points of the trajectory. 
8.12.37 Struct relative_trajectory A relative trajectory is a sequence of points measured with respect to a reference entity, where the points must be traversed at specific moments in time. 
These points can be expressed in Cartesian (XYZ), route (S-T) or ASAM OpenDRIVE coordinates. 
Basic information Table 280. 
Basic information of struct relative_trajectory Children relative_trajectory_odr, relative_trajectory_pose_3d, relative_trajectory_st Parameters Table 281. 
Struct relative_trajectory Parameter Type Mandatory Description time_stamps listi of time Yes Time stamps for each element in points. 
The lists time_stamps and points must have the same length interpolation path_interpolation yes Choose how to join the points of the trajectory. 
8.12.38 Struct relative_trajectory_pose_3d A relative trajectory expressed in Cartesian (XYZ) coordinates, measured in the local coordinate frame of the reference entity. 
Basic information Table 282. 
Basic information of struct relative_trajectory_pose_3d Parents relative_trajectory Parameters Table 283. 
Struct relative_trajectory_pose_3d Parameter Type Mandatory Description points listi of pose_3d Yes List of points in world x-y-z-coordinates. 
The individual pose_3d elements can have some unspecified coordinates. 
Inherited parameters and variables Table 284. 
Inherited parameters and variables of struct relative_trajectory_pose_3d Parent Inherited parameters and variables relative_trajectory time_stamps, interpolation 8.12.39 Struct relative_trajectory_st A relative trajectory expressed in route (S-T) coordinates, measured with respect to a reference entity. 
Basic information Table 285. 
Basic information of struct relative_trajectory_st Parents relative_trajectory Parameters Table 286. 
Struct relative_trajectory_st Parameter Type Mandatory Description points list of route_point Yes Sequence of route_point that form the relative trajectory Inherited parameters and variables Table 287. 
Inherited parameters and variables of struct relative_trajectory_st Parent Inherited parameters and variables relative_trajectory time_stamps, interpolation 8.12.40 Struct relative_trajectory_odr A relative trajectory expressed in ASAM OpenDRIVE coordinates, measured with respect to a reference entity. 
Basic information Table 288. 
Basic information of struct relative_trajectory_odr Parents relative_trajectory Parameters Table 289. 
Struct relative_trajectory_odr Parameter Type Mandatory Description points list of odr_point Yes Sequence of odr_point that form the relative trajectory Inherited parameters and variables Table 290. 
Inherited parameters and variables of struct relative_trajectory_odr Parent Inherited parameters and variables relative_trajectory time_stamps, interpolation 8.11 Environment actions 8.13 Physical types and structs

8.13 Physical types and structs
8.13 Physical types and structs 8.13.1 Scalar types 8.13.1.1 Type length Physical type for length. 
type length is SI(m: 1) unit nanometer of length is SI(m: 1, factor: 0.000000001) unit nm of length is SI(m: 1, factor: 0.000000001) unit micrometer of length is SI(m: 1, factor: 0.000001) unit millimeter of length is SI(m: 1, factor: 0.001) unit mm of length is SI(m: 1, factor: 0.001) unit centimeter of length is SI(m: 1, factor: 0.01) unit cm of length is SI(m: 1, factor: 0.01) unit meter of length is SI(m: 1, factor: 1) unit m of length is SI(m: 1, factor: 1) unit kilometer of length is SI(m: 1, factor: 1000) unit km of length is SI(m: 1, factor: 1000) unit inch of length is SI(m: 1, factor: 0.0254) unit feet of length is SI(m: 1, factor: 0.3048) unit mile of length is SI(m: 1, factor: 1609.344) unit mi of length is SI(m: 1, factor: 1609.344) 8.13.1.2 Type time Physical type for time. 
type time is SI(s: 1) unit millisecond of time is SI(s: 1, factor: 0.001) unit ms of time is SI(s: 1, factor: 0.001) unit second of time is SI(s: 1, factor: 1) unit sec of time is SI(s: 1, factor: 1) unit s of time is SI(s: 1, factor: 1) unit minute of time is SI(s: 1, factor: 60) unit min of time is SI(s: 1, factor: 60) unit hour of time is SI(s: 1, factor: 3600) unit h of time is SI(s: 1, factor: 3600) 8.13.1.3 Type speed Physical type for speed. 
type speed is SI(m: 1, s: -1) unit meter_per_second of speed is SI(m: 1, s: -1, factor: 1) unit mps of speed is SI(m: 1, s: -1, factor: 1) unit kilometer_per_hour of speed is SI(m: 1, s: -1, factor: 0.277777778) unit kmph of speed is SI(m: 1, s: -1, factor: 0.277777778) unit kph of speed is SI(m: 1, s: -1, factor: 0.277777778) unit mile_per_hour of speed is SI(m: 1, s: -1, factor: 0.447038889) unit mph of speed is SI(m: 1, s: -1, factor: 0.447038889) unit miph of speed is SI(m: 1, s: -1, factor: 0.447038889) unit mmph of speed is SI(m: 1, s: -1, factor: 0.000000278) unit millimeter_per_hour of speed is SI(m: 1, s: -1, factor: 0.000000278) 8.13.1.4 Type acceleration Physical type for acceleration. 
type acceleration is SI(m: 1, s: -2) unit meter_per_sec_sqr of acceleration is SI(m: 1, s: -2, factor: 1) unit mpsps of acceleration is SI(m: 1, s: -2, factor: 1) unit mpss of acceleration is SI(m: 1, s: -2, factor: 1) unit kilometer_per_hour_per_sec of acceleration is SI(m: 1, s: -2, factor: 0.277777778) unit kmphps of acceleration is SI(m: 1, s: -2, factor: 0.277777778) unit mile_per_hour_per_sec of acceleration is SI(m: 1, s: -2, factor: 0.447038889) unit miphps of acceleration is SI(m: 1, s: -2, factor: 0.447038889) 8.13.1.5 Type jerk Physical type for jerk. 
type jerk is SI(m: 1, s: -3) unit meter_per_sec_cubed of jerk is SI(m: 1, s: -3, factor: 1) unit mpspsps of jerk is SI(m: 1, s: -3, factor: 1) unit mile_per_sec_cubed of jerk is SI(m: 1, s: -3, factor: 1609.344) unit mipspsps of jerk is SI(m: 1, s: -3, factor: 1609.344) 8.13.1.6 Type angle Physical type for angle. 
type angle is SI(rad: 1) unit degree of angle is SI(rad: 1, factor: 57.295779513) unit deg of angle is SI(rad: 1, factor: 57.295779513) unit radian of angle is SI(rad: 1, factor: 1) unit rad of angle is SI(rad: 1, factor: 1) 8.13.1.7 Type angular_rate Physical type for angular_rate. 
type angular_rate is SI(rad: 1, s: -1) unit degree_per_sec of angular_rate is SI(rad: 1, s: -1, factor: 57.295779513) unit degps of angular_rate is SI(rad: 1, s: -1, factor: 57.295779513) unit radian_per_sec of angular_rate is SI(rad: 1, s: -1, factor: 1) unit radps of angular_rate is SI(rad: 1, s: -1, factor: 1) 8.13.1.8 Type angular_acceleration Physical type for angular_acceleration. 
type angular_acceleration is SI(rad: 1, s: -2) unit degree_per_sec_sqr of angular_acceleration is SI(rad: 1, s: -2, factor: 57.295779513) unit degpsps of angular_acceleration is SI(rad: 1, s: -2, factor: 57.295779513) unit radian_per_sec_sqr of angular_acceleration is SI(rad: 1, s: -2, factor: 1) unit radpsps of angular_acceleration is SI(rad: 1, s: -2, factor: 1) 8.13.1.9 Type mass Physical type for mass. 
The pound and lb units refer to pounds-mass. 
type mass is SI(kg: 1) unit gram of mass is SI(kg: 1, factor: 0.001) unit kilogram of mass is SI(kg: 1, factor: 1) unit kg of mass is SI(kg: 1, factor: 1) unit ton of mass is SI(kg: 1, factor: 1000) unit pound of mass is SI(kg: 1, factor: 0.45359237) unit lb of mass is SI(kg: 1, factor: 0.45359237) 8.13.1.10 Type temperature Physical type for temperature. 
type temperature is SI(K: 1) unit K of temperature is SI(K: 1, factor: 1) unit kelvin of temperature is SI(K: 1, factor: 1) unit celsius of temperature is SI(K: 1, factor: 1, offset: 273.15) unit C of temperature is SI(K: 1, factor: 1, offset: 273.15) unit fahrenheit of temperature is SI(K: 1, factor: 0.555555556, offset: 255.372222222) unit F of temperature is SI(K: 1, factor: 0.555555556, offset: 255.372222222) 8.13.1.11 Type pressure Physical type for pressure. 
type pressure is SI(kg: 1, m: -1, s: -2) unit newton_per_meter_sqr of pressure is SI(kg: 1, m: -1, s: -2, factor: 1) unit Pa of pressure is SI(kg: 1, m: -1, s: -2, factor: 1) unit pascal of pressure is SI(kg: 1, m: -1, s: -2, factor: 1) unit hPa of pressure is SI(kg: 1, m: -1, s: -2, factor: 100) unit atm of pressure is SI(kg: 1, m: -1, s: -2, factor: 101325) 8.13.1.12 Type luminous_intensity Physical type for luminous_intensity. 
type luminous_intensity is SI(cd: 1) unit cd of luminous_intensity is SI(cd: 1, factor: 1) unit candela of luminous_intensity is SI(cd: 1, factor: 1) 8.13.1.13 Type luminous_flux Physical type for luminous_flux. 
type luminous_flux is SI(cd: 1, rad: 2) unit lm of luminous_flux is SI(cd: 1, rad: 2, factor: 1) unit lumen of luminous_flux is SI(cd: 1, rad: 2, factor: 1) 8.13.1.14 Type illuminance Physical type for illuminance. 
type illuminance is SI(cd: 1, rad: 2, m: -2) unit lx of illuminance is SI(cd: 1, rad: 2, m: -2, factor: 1) unit lux of illuminance is SI(cd: 1, rad: 2, m: -2, factor: 1) 8.13.1.15 Type electrical_current Physical type for electrical_current. 
type electrical_current is SI(A: 1) unit ampere of electrical_current is SI(A: 1, factor: 1) unit A of electrical_current is SI(A: 1, factor: 1) 8.13.1.16 Type amount_of_substance Physical type for amount_of_substance. 
type amount_of_substance is SI(mol: 1) unit mole of amount_of_substance is SI(mol: 1, factor: 1) unit mol of amount_of_substance is SI(mol: 1, factor: 1) 8.13.2 Compound types 8.13.2.1 Struct position_3d Compound type for three-dimensional position in x, y, z-direction. 
struct position_3d: x: length y: length z: length def norm() -> length is undefined 8.13.2.2 Struct geodetic_position_2d Compound type for geodetic position as latitude and longitude in a geographical coordinate system. 
Positive latitude angles in North direction from equator. 
Positive longitude angles in East direction from prime Meridian. 
struct geodetic_position_2d: latitude: angle longitude: angle 8.13.2.3 Struct celestial_position_2d Compound type for celestial position in azimuth and elevation in a Horizontal Coordinate System, in which the y-axis-direction is 0 deg and the x-axis-direction is 90 deg. 
As a result, North is 0 deg and East is 90 deg, if x-axis and y-axis are mapped to East and North respectively. 
The origin of Horizontal Coordinate System equals the World Coordinate System origin. 
struct celestial_position_2d: azimuth: angle elevation: angle 8.13.2.4 Struct orientation_3d Compound type for three-dimensional orientation of objects using Tait–Bryan angles roll, pitch and yaw. 
The rotations are to be performed yaw first (around the z-axis), pitch second (around the new y-axis) and roll third (around the new x-axis) to follow the definition according to ISO 8855. 
struct orientation_3d: roll: angle pitch: angle yaw: angle 8.13.2.5 Struct pose_3d Compound type for pose in trhee-dimensional space, including compound types for three-dimensional position and orientation. 
struct pose_3d: position: position_3d orientation: orientation_3d 8.13.2.6 Struct translational_velocity_3d Compound type for three-dimensional translational velocity in x, y, z-direction. 
struct translational_velocity_3d: x: speed y: speed z: speed def norm() -> speed is undefined 8.13.2.7 Struct orientation_rate_3d Compound type for three-dimensional orientation rate of objects using Tait–Bryan angles roll, pitch and yaw. 
The rotations are to be performed yaw first (around the z-axis), pitch second (around the new y-axis) and roll third (around the new x-axis) to follow the definition according to ISO 8855. 
struct orientation_rate_3d: roll: angular_rate pitch: angular_rate yaw: angular_rate 8.13.2.8 Struct velocity_6d Compound type for velocity including compound types for three-dimensional translational velocity and orientation rate. 
struct velocity_6d: translational: translational_velocity_3d angular: orientation_rate_3d 8.13.2.9 Struct translational_acceleration_3d Compound type for three-dimensional translational acceleration in x, y, z-direction. 
struct translational_acceleration_3d: x: acceleration y: acceleration z: acceleration def norm() -> acceleration is undefined 8.13.2.10 Struct orientation_acceleration_3d Compound type for three-dimensional orientation acceleration of objects using Tait–Bryan angles roll, pitch and yaw. 
The rotations are to be performed yaw first (around the z-axis), pitch second (around the new y-axis) and roll third (around the new x-axis) to follow the definition according to ISO 8855. 
struct orientation_acceleration_3d: roll: angular_acceleration pitch: angular_acceleration yaw: angular_acceleration 8.13.2.11 Struct acceleration_6d Compound type for acceleration including compound types for three-dimensional translational and orientational acceleration. 
struct acceleration_6d: translational: translational_acceleration_3d angular: orientation_acceleration_3d 8.12 Road abstraction classes 8.14 Standard library

8.14 Standard library
8.14 Standard library The standard library of ASAM OpenSCENARIO is available in the standard.osc file provided with this release. 
The standard.osc file is a machine-readable representation of the domain model in ASAM OpenSCENARIO syntax. 
Note that the standard.osc file provided with this release is not a fully-functional library. 
Implementations of ASAM OpenSCENARIO still need to provide implementations of classes, methods, actions, and modifiers described in the language reference manual, domain model reference or any other normative text in this document. 
The section Importing the standard library explains how to make the standard library’s functionalities available to users of ASAM OpenSCENARIO. 
The standard.osc file is non-normative. 
The normative part is defined in the document. 
The standard.osc file is available for download via additional resources. 
8.13 Physical types and structs 9 User guide

9 User guide
9 User guide Please note that the following section and its sub-sections are non-normative. 
This guide contains: Section 9.1, "Writing reusable scenarios" These methodology guidelines are based on existing industry experience and lengthy technical discussions, which took place as part of the standardization process. 
The guidelines enable users to easily create reusable scenario assets. 
Section 9.2, "Formatting ASAM OpenSCENARIO code" The coding style guide is intended to help you write source code in the ASAM OpenSCENARIO domain-specific language in a uniform way. 
Section 9.3, "Extending the domain model" This document discusses possible extensions and adjustments that can be made through the extension mechanism. 
8.14 Standard library 9.1 Writing reusable scenarios

9.1 Writing reusable scenarios
9.1 Writing reusable scenarios 9.1.1 Introduction These methodology guidelines are based on existing industry experience and lengthy technical discussions, which took place as part of the standardization process. 
The guidelines enable users to easily create reusable scenario assets. 
9.1.1.1 Motivation ASAM OpenSCENARIO enables the creation of reusable scenarios through language constructs that are a fundamental part of modern software development. 
These include: Extensibility Object-oriented inheritance Hierarchical composition For example, it is possible to take a reusable cut-in scenario and an oncoming-traffic scenario to create a larger composite scenario that includes both scenarios. 
The chapter contains the following methodology guidelines: Use .osc as file extension Use abstract scenarios Use wide-ranges Be careful with initializations Use abstract road locations Use labels Use generic actions Use generic scenarios 9.1.2. 
Use .osc as file extension Prefer using .osc as file extension. 
For consistency and easy identification, use .osc as file extension for all ASAM OpenSCENARIO files. 
For example, for a cut-in scenario definition use the file name cut_in.osc. 
9.1.3 Use abstract scenarios Prefer declaring abstract scenarios instead of concrete scenarios. 
One of the key features of ASAM OpenSCENARIO is abstraction. 
Instead of repeating the entire scenario description in each scenario variation, the language allows factoring out the commonality between scenarios and capturing this in abstract reusable scenarios. 
Later on, the abstract scenarios can be used for concrete purposes or they can be composed to achieve other abstract scenarios. 
This approach also allows the incremental accretion of concretizations, which supports incremental development of scenarios by delaying the specification of details until these details are known. 
Assume that a cut-in scenario is listed in the requirements or requested by the development team. 
If the requirement calls for a generic abstract cut-in, for example, "try different kinds of cut-in", the language provides the proper abstraction to represent the request in executable format including all the scenario dependencies in constraints. 
Note that even if the requirement calls for a concrete cut-in with specific values or specific location, it might still be useful to first create an abstract scenario representation. 
Such a scenario can then be further constrained to achieve the concrete request and eventually many others. 
Implementing the concrete request directly in a concrete scenario may work against the user in the medium or long term, as validation typically involves running multiple cut-ins in various locations. 
There is a high probability that another variation of cut-ins will be required in current or future projects. 
The recommended solution is to define the needed abstract scenario as a reusable asset. 
A cut-in scenario intent is defined as follows: Start behind the ego on an adjacent lane. 
Move in front of the ego. 
Change the lane in front of the ego. 
Capturing the distilled scenario intent above without hard-coding of specific speeds, distances, lanes, and locations will enable a more reusable scenario that does not require code duplication to achieve variations. 
Once the reusable scenario is in place, it is possible to further constrain the scenario for the needed concrete values. 
Working with abstraction and thinking of reuse is a fundamental concept in modern software engineering. 
As opposed to creating lengthy code with multiple repetitions, engineers identify functions that can be parameterized and can be used across the code base. 
They may also factor out abstract classes and derive sub-classes to achieve variations without code duplication. 
These practices enable productivity and save development time and maintenance cost. 
It is important to point out that concrete scenarios are still needed for specific purposes, including simulation execution or to ensure exact exchangeability. 
While concrete scenarios can be be manually implemented in ASAM OpenSCENARIO, they can also be exported as a result of a scenario concretization tool chain. 
Determining the proper level of abstraction for scenarios is the recommended practice to maximize reuse, and to minimize the problem of accidentally narrowing the test space by encoding concrete details at too early a stage in development. 
9.1.4 Use wide-ranges Use wide-ranges to enable reusability. 
This tip is related to the guideline Section 9.1.3, “Use abstract scenarios”. 
When selecting ranges and placing constraints on values, provide wide-ranges for parametrized attributes to enable running corner-case scenarios. 
9.1.5 Be careful with initializations Do not set initial speed or scenario conditions. 
Users may be tempted to select an interesting concrete speed and starting point for each vehicle. 
Such concrete values may be part of specific requirements. 
However setting the initial speed and conditions on the scenario makes it less reusable. 
Examples: You cannot execute this scenario after scenarios that require different ending points. 
If the initial positions of the vehicles in a cut-in scenario are set, performing two consecutive cut-ins is not possible. 
The recommended approach to maintain reusability is to decompose such a scenario into two parts: A generic reusable scenario that is independent from the initial speed and conditions. 
Provide the specific conditions later. 
There are two possible use models here: Let an OpenSCENARIO tool figure out the needed initial speed and conditions to accommodate the specified scenario. 
This is one of the biggest motivations of ASAM OpenSCENARIO to enable high volume of achieved concrete scenarios. 
If specific initial conditions are needed, create these in a less reusable scenario wrapper that activates a reusable scenario with the needed initial condition and speeds. 
The way to specify initial conditions for a reusable scenario is with the generic actions at attribute on the first action of the scenario. 
The at: start constrains the needed attribute just for the beginning of the phase. 
This way the initial conditions can be changed later. 
The following example shows a scenario that requires an initial speed of 40 to 60 kph. 
Code 1. 
Constraint speed scenario my_scenario: s: speed with: keep (it in [40kph..60kph]) do serial: init: car1.drive() with: speed(speed: s, at: start) #note that it is recommended to specify an initial range for speed and not a concrete speed The example can be made concrete by providing a concrete speed: Code 2. 
Concrete speed extend my_scenario: keep (s == 43kph) You can always run more actions in parallel on top of the same actor to further constrain the initial behavior of the actor. 
The following example illustrates that option. 
Code 3. 
Further constraints after start scenario my_other_scenario: do parallel: init: car1.drive() with: # starts at t=0 speed(speed: 40kph, at: start) a1: car1.drive() with: # further initial conditions for car1. 
This affects the same initial drive lateral(speed: 2kph, at:start) 9.1.6 Use abstract road locations Use abstract definitions of roads and locations. 
ASAM OpenSCENARIO allows an abstract definition of roads and locations. 
It is highly recommended to use these abstract definitions. 
Do not hard-code the specific location and specific map in which the scenario takes place. 
The recommended approach is to provide the minimal amount of road description to allow reusing the scenario in multiple locations. 
Furthermore, OpenSCENARIO tools may allow finding random locations on the map to create unexpected, surprising scenarios. 
9.1.7 Use labels Use labels for external scenario tuning. 
ASAM OpenSCENARIO supports assigning labels for the different phases of the scenario. 
For example, a cut-in scenario may be composed of phases with the following labels defined: start_behind get_ahead change_lane These labels are useful for commenting, tagging, and readability. 
Labels also have a key reuse aspect: A user can extend scenarios using labels. 
In this example you can build a 'stack' of constraints: Use the change_lane label to layer a constraint on the desired speed used during the change_lane phase. 
9.1.8 Use generic actions Prefer using generic actions over specialized actions for readability and extendibility. 
While beginners may find a function-like API easier to read, using the generic actions allows for more external tuning and reuse. 
For example, it is possible to specify an extension. 
This is how to use a speed modifier in the extension: Specify the desired speed at the end of the change_lane phase. 
Put this specification on top of the generic drive. 
It is not possible to achieve such an extension without using the reach_speed specialized actions. 
Code 4. 
Using a generic action to extend a scenario phase scenario sut.my__scenario: car1: vehicle car2: vehicle do serial: phase1: car1.drive(duration: 24s) with: speed([40kph..80kph], at: end) lane([2..4]) phase2: car1.drive(duration: 24s) with: speed([70kph..60kph], at: end) With generic actions, phase2 can be extended and more modifiers can be added to the second drive. 
9.1.9 Use generic scenarios Create generic scenarios to run on all execution platforms. 
In general, a scenario description is meant to run on all execution platforms. 
Specific platform limitations should not be part of the generic scenario. 
Do not hard-code parameters in the generic scenario that would lead to non-physical movements. 
The aforementioned restrictions can be applied as an extension to a reusable scenario, allowing for a clean separation of the generic and use-case specific aspects. 
For example, a generic overtake scenario could be extended with additional parameters specific to a proving ground use case with an automated driver model. 
9 User guide 9.2 Formatting ASAM OpenSCENARIO code

9.2 Formatting ASAM OpenSCENARIO code
9.2 Formatting ASAM OpenSCENARIO code 9.2.1 Coding style guide This coding style guide is intended to help you write source code in the ASAM OpenSCENARIO domain-specific language in a uniform way. 
9.2.1.1 Introduction This guide focuses on uniform formatting and naming for source code. 
It does not contain best practices nor is it a reference for the language. 
You should follow the recommendations in this document if you are a scenario developer writing scenarios for real use. 
By following the recommendations in this guide the code becomes easy to understand for you and other users. 
9.2.2 Formatting 9.2.2.1 Indentation Use four space characters per indentation level. 
Do not use tab characters. 
Use the following text editor settings: Tab size: 4 Insert spaces 9.2.2.2 Encoding Use UTF-8 as encoding. 
9.2.2.3 Whitespace Whitespace characters provide better readability when used in the correct places. 
Use only space characters as whitespace. 
Replace tabs with four spaces as described in Section 9.2.2.1, “Indentation”. 
The correct use of space characters within ASAM OpenSCENARIO source code is as follows: One space after a comma (in argument lists and other lists) One space after a colon (for example for inheritance) One space before and after a keyword One space before and after an operator No spaces before and after brackets and braces (for example, in function calls or for indexing) No space between value and unit The following code snippet shows some examples of the correct use of space characters. 
Code 1. 
Correct use of space characters func(arg[1], arg2) if x == 4: print x, y foo == [x, y, z] func(1) abc[key] = lst[index] i = i + 1 actor bus: car(category: bus): keep(width == 1.8m) keep(length == 4.5m) swerve_story: serial: side_vehicle.drive() with: path(s_side_vehicle) keep_speed() with: until (top.time > 5sec) 9.2.2.4 Comments Single lines of comments and inline comments can be added using the 'pound' symbol (#). 
# This is a single line comment. 
i = i + 42 # This is an inline comment Blocks of comments can be simulated by using several single lines of comments. 
# This is a block of comments example. 
# The following call to foo is commented out # Reason: see issue xyz # More explanation here... 
# # foo() 9.2.2.5 Line breaks Consider breaking up statements that are too long to fit into one line. 
Use the line continuation special character 'backslash' (\) for marking the continuation. 
This is a line of text that is too long for a single \ line, so continue after the backslash in a new line. 
9.2.3 Naming Naming conventions are a widely discussed topic with great influence on readability influenced by fashion changes, habit, and personal taste. 
Here are the recommendations valid for naming conventions in ASAM OpenSCENARIO source code. 
9.2.3.1. 
Use snake_case only Use snake_case (aka lowercase_with_underscore) for all source code elements that are not keywords. 
Code 2. 
Example for correctly formatted code # 1: Define an actor actor car_group: average_distance: length number_of_cars: uint # 2: Define a road element struct struct geometric_road: road_element: min_radius: length max_radius: length side: av_side # 3: Define a scenario scenario dut.traverse_junction_at_yield: s: road_with_sign with(sign_type: yield) do dut.car.traverse_junction() with: ... 
# 4: Define a containing scenario scenario dut.mix_three_dangers: weather_kind: weather_kind keep(weather_kind != clear) do mix: cut_in_and_slow() traverse_junction_at_yield() weather(kind: weather_kind) 9.2.3.2 Single character names Do not use the following characters as single character names because they can be easily misread as zero (0) or one (1): No single lowercase 'el' (l) No single uppercase 'eye' (I) No single lowercase 'oh' (o) No single uppercase 'oh' (O) 9.2.4 Example Here is a more complex example showing all the rules. 
Code 3. 
Example for correctly formatted code in ASAM OpenSCENARIO scenario slower_large_vehicle_in_adjacent_lane ego_vehicle: vehicle with: keep(p_vehicle_model == APTIV_ego_vehicle) v1: vehicle with: keep(vehicle_category == Bus) keep(p_vehicle_model == BlueBird_Vision_2014) keep(p_vehicle_model.Color == Blue) ego_model: ego_vehicle.p_vehicle_model ego_route: ego_vehicle.route v1_model: v1.p_vehicle_model v1_route: v1.route ego_start_speed: speed ego_start_distance: length v1_start_speed: speed v1_start_distance: length simulation_platform_choice: string simulation_time_threshold_reached: time ego_ttc_threshold: time ego_distance_to_bias: length lane_choice: string ego_lane: lane map: file_path keep(map == "/maps/example.xodr") simple_3_lane_road_01: lane_section lane1^: lane lane2^: lane lane3^: lane simple_3_lane_road_01.lanes = [lane1^, lane2^, lane3^] keep(simple_2_lane_road_01 == map.road(id:"1").*lane_section(s:"0")) lane3^ = rightmost_lane(map.*right) keep(lane2^ -[:LEFT_OF]-> lane3^) keep(lane1^ -[:LEFT_OF]-> lane2^) # Logic parameter syntax keep(ego_lane in: { if: lane_choice == "Left" THEN: SET ego_lane = "lane1^", if: lane_choice == "Right" THEN: SET ego_lane = "lane3^"}) keep(ego_model == APTIV_ego_vehicle) keep(ego_route == ego_drive_left) keep(v1_model == BlueBird_Vision_2014) keep(v1_route == v1_drive) keep(ego_start_speed == 80.46719999999999 [kph]) keep(ego_start_distance == 5 [m]) keep(v1_start_speed == 48.28032 [kph]) keep(v1_start_distance == 55.0 [m]) keep(simulation_platform_choice == "CarMaker") keep(simulation_time_threshold_reached == 120 [s]) keep(ego_ttc_threshold == 1 [s]) keep(ego_distance_to_bias == 1 [m]) keep(lane_choice == "Left") # Relationship syntax keep(v1_start_speed -[:SLOWER_THAN]-> ego_start_speed) def distance_between_ego_vehicle_and_v1(vehicle, vehicle) -> length is external "kpi.py" def get_ttc_with_vehicle_to_vehicle(vehicle, vehicle, string) -> time is external "kpi_TTC.py" !ego_speed: speed = ego_vehicle.speed !ego_end_of_road: Position = ego_vehicle.end_of_road !ego_off_road: Position = ego_vehicle.off_road !simulation_time: time = simulation.time !ego_vehicle_lane: lane = ego_vehicle.lane !ego_collision_monitor: integer = sensor.collision.v.fr1.count !ego_ttc_with_v1: time = sample(ego_vehicle.get_ttc_with_vehicle_to_vehicle(ego_vehicle:vehicle, v1:vehicle, [simulation_platform_choice])) !ego_distance_to_v1: length = sample(distance_between_egoVehicle_and_v1(v1:vehicle, ego_vehicle:vehicle, [simulation_platform_choice])) event observation_complete is(one_of(@end_conditions)) event ego_ttc_threshold_reached1 is(!ego_ttc_with_v1  0) event end_conditions[2] is(!ego_off_road > 0) event end_conditions[3] is(!simulation_time > [simulation_time_threshold_reached]) event end_conditions[4] is(!ego_collision_monitor > 0) event end_conditions[5] is((ego_vehicle.s_road - v1.s_road) > 40) do parallel(): ego_init_drive_01: ego_vehicle.drive(ego_route) with: position(at_distance: ego_start_distance, beyond_start_of: ego_route) speed(at_speed: ego_start_speed) at(at:start) v1_init_drive_01: v1.drive(v1_route) with: position(at_distance: v1_start_distance, ahead_of: ego_vehicle) speed(at_speed: v1_start_speed) at(at:start) until(@observation_complete) 9.2.5 Related topics If you cannot find a recommendation for your source code formatting or naming problem in this chapter, follow the Style Guide for Python Code (PEP 8). 
9.1 Writing reusable scenarios 9.3 Extending the domain model

9.3 Extending the domain model
9.3 Extending the domain model 9.3.1 Introduction ASAM OpenSCENARIO allows users to extend the normative domain model using the extension mechanism. 
The extension mechanism allows to: Define actors and actions from scratch. 
Tune the normative domain model to project needs. 
Map the ASAM OpenSCENARIO domain model to other existing standards or commercial domain models. 
The extension mechanism is defined in Section 7.3.9, "Extension". 
This document discusses possible extensions and adjustments that can be made through the extension mechanism. 
9.3.2 ASAM OpenSCENARIO extension features The ASAM OpenSCENARIO language provides multiple features for extensions and adjustments. 
Users can use one of the following programming paradigms: Aspect Oriented Programming (AOP) AOP allows adding any struct member to extend structs without introducing new type names. 
Note that you can also extend enumerated types to include new values. 
Object Oriented Programming (OOP) OOP with traditional inheritance allows the introduction of a new struct name to the type system. 
This is done by deriving (also called inheriting) the new name from an existing one. 
With the extension mechanism, users can define or extend actions, actors, and structs to add specific members. 
Typical reasons for extending the domain model are: Layering constraints to add an ODD or a test constraint to steer the desired generated values and probabilities to explore unvisited areas or to match a specific distribution Adding fields for controlling or monitoring purposes Adding new or overriding existing coverage definitions Adding or tuning checkers Extending the definition of an enumerated type to include another value The domain model pre-provided structs and types can be extended as any user-defined type using the ASAM OpenSCENARIO language capabilities. 
The following guidelines show how to extend the ASAM OpenSCENARIO domain model for specific purposes. 
9.3.3 Adding a new behavior Primitive behaviors are implemented in ASAM OpenSCENARIO using actions. 
Actions can be executed or observed in a scenario. 
If you need to activate or observe a new behavior or automation function as part of your development and V&V process, you can add and use that new behavior or function. 
9.3.3.1 Recommended process The following process is recommended for adding new behaviors: Identify the container actor. 
Check the ASAM OpenSCENARIO domain model, to see if one of the existing actors matches your needs. 
For example, if you want to make an entity of type person jump, you can extend the actor person and add a jump action to it. 
If no actor matches your needs, define a new actor. 
For example, if you want to make a horse gallop across the road, define a new actor horse and associate the gallop action to it. 
Add the needed action to the actor. 
9.3.3.2 Examples 9.3.3.2.1 Adding an action to an existing standard actor The following example adds the action jump to the existing actor person. 
Code 1. 
Extending person with jump extend person: age: uint with: keep(it in [1..120]) action jump: height: length jump_num: uint with: keep(it in [1..5]) keep(age > 60 => height < 0.1m) Comments: A constraint was added between the new jump scenario and the age. 
Note that all person actors and derivatives have an age attribute, which is randomized now. 
Connecting the abstract action to the execution platform (meaning implementing or observing the jump) is implementation-specific and outside of the scope of the ASAM OpenSCENARIO standard. 
9.3.3.2.2 Adding an action to activate the ACC function This example demonstrates how an action sets a state variable. 
Conditions are, that the ACC automation function can be activated or deactivated at a certain cruising speed. 
Code 2. 
Extending actor vehicle to request ACC-mode in different speeds extend vehicle: action request_acc_mode: cruise_speed: speed turn_on: bool 9.3.3.2.3 Adding a new actor A horse is not part of the ASAM OpenSCENARIO domain model. 
In this example, a new actor for a horse is created. 
It makes sense to derive a horse from animal. 
Code 3. 
Adding a horse actor with a gallop action actor horse: animal: scenario gallop: speed: speed 9.3.3.2.4 Using conditional inheritance ASAM OpenSCENARIO allows extending a struct under certain conditions. 
For example, you may want to add a boolean siren field to entities of type emergency vehicle. 
The following code demonstrates how to do this. 
Code 4. 
Conditionally adding a siren field actor vehicle: is_emergency: bool #each vehicle can be an emergency or not actor emergency_vehicle: vehicle(is_emergency:true): siren: bool Comments: The actor emergency_vehicle is defined to be a vehicle. 
Its value vehicle_category is emergency. 
emergency_vehicle inherits all vehicle attributes with the addition of a siren boolean field. 
Note that randomizing a vehicle may generate an emergency vehicle, which in turn has a siren field that is randomly turned on or off. 
9.3.3.3 Extending an existing struct Often users do not need a brand-new actor or action. 
They only want to extend existing entities with new struct members, such as a new field, constraint, cover point, event, and so on. 
The following example demonstrates these capabilities. 
Code 5. 
Adding a struct member to an existing struct enum size: [small, medium, large] extend vehicle: my_size: size # field extension keep (speed < 60kph) # layer a constraint event stopped # add an event 9.3.3.3.1 Extending enumerated types ASAM OpenSCENARIO allows the extension of enumerated types. 
This may affect all structs that contain a field of that type. 
For example, if a new car model is defined, both generation and coverage automatically adjusts to contain the new added car model. 
Assume the following definition: type size: [small, medium, large] actor vehicle; my_size: size # size can be either small, medium, or large To add another option of the vehicle, in this case the vehicle should also be huge, you can extend the enumerated type as follows: extend size: [huge] The base definition with the extension is equivalent to the following code: enum size: [small, medium, large, huge] actor vehicle; my_size: size # can be small, medium, large, huge 9.3.3.3.2 An example for extending Create a reach_acceleration action that gets a vehicle to a certain acceleration. 
The following example achieves the desired result. 
Code 6. 
Extend an actor with reach_acceleration scenario vehicle.reach_acceleration: target_acceleration: acceleration do drive() with: acceleration(target_acceleration, at: end) Once this code is loaded into an OpenSCENARIO tool, a new reach_acceleration specialized action is available and can be used in any user scenario. 
This simple example triggers a single drive action. 
Users may create more sophisticated compositions for more complicated maneuvers using composition of other actions and scenarios. 
9.3.4 Extending the Abstract Road network The modifiers explained in Section 8.5, "Abstract road network" help users build certain parts of a route of a road network. 
This section provides an example of how these can be further extended. 
9.3.4.1 An example of extending a crossing A potential addition to a crossing that allows for start_line and end_line in addition to start_lane and end_lane. 
Suggestion: Allow for start_line and end_line to also be used to define crossings, since all a lane is to crossing_connects() is a centerline of the lane. 
Future definition: A crossing is an overlay or virtual path that acts as a route and has a direct relationship to lanes or lines made with free_space_points. 
When a crossing is a route, it may also be used in the following way with four instances of route_point that form two straight lines: Any straight line could be used as a starting line and ending line just like a start_lane and end_lane. 
However, geometry is still reserved for future implementation. 
The following description does not create an accurate definition for the creation of a line from points. 
The origin of a crossing for s-coordinates is determined from a lane centerline and s-position along that line. 
However, its origin can also originate along a line defined by two free space points. 
The start_lane assigns which lane starts the crossing. 
Alternatively, start_line assigns which line starts the crossing. 
The end_lane assigns which lane completes the crossing. 
Alternatively, end_line assigns which line completes the crossing. 
In the case of straight line geometry, the crossing ends at the natural connection with the centerline of the end lane or a line defined by two free-space points. 
map: map free_space_line1: list of route_point = [point1, point2] sidewalk1: lane crossing1: crossing with: keep(it.width == 3.5m) map.crossing_connects(crossing1, start_line: free_space_line1, end_lane: sidewalk1, start_s_coord: 5m, start_angle: 90deg) Figure 26. 
Crossing with line from free space points The red dot is the origin on the start_line and the blue dot is an end_point in end_lane. 
A crossing may also be specified with a specific start_angle: map: map free_space_line1: list of free_space_point = [point1, point2] free_space_line2: list of free_space_point = [point3, point4] crossing1: crossing with: keep(it.width == 3.5m) map.crossing_connects(crossing1, start_line: free_space_line1, end_line: free_space_line2, start_s_coordinate: 5m, start_angle: 85deg) Figure 27. 
Picture of crossing with specified start_angle 9.3.5 Mapping to other languages and domain models Today, the automotive industry uses multiple languages and domain models to describe scenarios, actors, and actions. 
These languages and domain models are either proprietary or inconsistent to one another and not standardized. 
The domain model of ASAM OpenSCENARIO contains generic and specialized actions: The generic actions provide a flexible mechanism to describe a rich set of scenarios. 
The specialized actions are a simplified interface for a few of the commonly used actions. 
Users can also add specialized actions to map the ASAM OpenSCENARIO domain model into existing commercial or proprietary solutions. 
9.2 Formatting ASAM OpenSCENARIO code 10 Migrating from ASAM OpenSCENARIO 1.2.0

10 Migrating from ASAM OpenSCENARIO 1.2.0
10 Migrating from ASAM OpenSCENARIO 1.2.0 Please note that the following section and its sub-sections are non-normative. 
This chapter guides through the ASAM OpenSCENARIO 1.2.0 concepts and shows how to convert the concepts and entire scenarios into this version of ASAM OpenSCENARIO. 
The migration guide starts with an explanation of some differences in terminology, followed by the conversion of some of the basic concepts and a minimal scenario. 
Next, conversions of actions and conditions are presented. 
The appendix contains examples of some complete scenarios. 
Migration guidelines describe some important ASAM OpenSCENARIO 1.2.0 concepts briefly, but at least basic knowledge of the ASAM OpenSCENARIO 1.2.0 standard is required to migrate scenarios. 
This version of ASAM OpenSCENARIO was created to be more expressive. 
Because of the higher expressiveness it is possible to find multiple mappings for some of the concepts. 
These mappings are not intended to be exhaustive, but rather they show when it is better to use one or the other type of conversion. 
Full runtime compatibility can be achieved for simpler ASAM OpenSCENARIO 1.2.0 scenarios, which use a subset of ASAM OpenSCENARIO 1.2.0 features. 
Limitations and incompatibilities are listed in the following sections. 
Automated scenario conversion from ASAM OpenSCENARIO 1.2.0 to this version of ASAM OpenSCENARIO may be possible, within the boundaries of compatible features. 
It could be done following similar guidelines, but it is outside the scope of this document. 
9.3 Extending the domain model 10.1 Types

10.1 Types
10.1 Types This version of ASAM OpenSCENARIO has a complete type system and ASAM OpenSCENARIO 1.2.0 types convert easily into this system. 
Values of all types in ASAM OpenSCENARIO 1.2.0 in XML can be specified in two ways: With a literal value With the parameter reference ($param_name) , where the parameter should be of the proper type, but ASAM OpenSCENARIO 1.2.0 has no mechanism to enforce this. 
Parameter references are described in Section 10.2, "Parameters". 
Table 291. 
Types comparison table Type ASAM OpenSCENARIO 1.2.0 ASAM OpenSCENARIO 2.0.0 Notes Boolean (logical value) boolean (literals true, false) bool Timestamp (including date and time) dateTime (for example 2002-05-30T09:30:10) date_time Floating-point double float IEEE 64-bit floating-point Signed integer int int 32-bit signed integer in ASAM OpenSCENARIO 1.2.0, 64-bit signed integer in ASAM OpenSCENARIO 2.0.0 Unsigned 32-bit integer unsignedInt uint 32-bit unsigned integer in ASAM OpenSCENARIO 1.2.0, 64-bit unsigned integer in ASAM OpenSCENARIO 2.0.0 Unsigned 16-bit integer unsignedShort uint 16-bit unsigned integer in ASAM OpenSCENARIO 1.2.0, 64-bit unsigned integer in ASAM OpenSCENARIO 2.0.0 Unicode string string string Enums Fixed enums only, defined by standard enum Extensible enumeration types, with optional integer values Physical types Most of the floating-point values in ASAM OpenSCENARIO 1.2.0 map to a physical type instance with the appropriate SI unit, for example, length, speed) 10 Migrating from ASAM OpenSCENARIO 1.2.0 10.2 Parameters

10.2 Parameters
10.2 Parameters In ASAM OpenSCENARIO 1.2.0, scenario parameters are an important language feature. 
ASAM OpenSCENARIO parameter declaration states that the particular value is expected to be set from outside of the scenario. 
Parameter assignment binds the scenario object field to the parameter defined above. 
Parameter declaration provides the default value for the parameter in case that the parameter variation mechanism is not used. 
ASAM OpenSCENARIO 1.2.0 expands on this concept and provides a mechanism to define distributions to further describe how the parameter or the parameter set is to be varied. 
In this version of ASAM OpenSCENARIO, all of the scenario and object fields are by default considered to be varied. 
Variation is subject to constraints (defined within the scenario), and limits that are implied by the simulation environment. 
In this section, a technique to mimic the more explicit ASAM OpenSCENARIO 1.2.0 parameter mechanism is presented. 
Scenario parameters are mapped to the fields of the top-level scenario. 
10.2.1 Parameter conversion mechanism Local parameters can be declared within the definition of these elements: entity maneuver controller environment trajectory route They are usually declared in the catalog. 
This local declaration then allows to set of the concrete parameter’s values in a place where a concrete entity is created from the catalog reference. 
In this case, a very similar mechanism as with scenario parameters is used. 
Both scenario level parameters and local parameters are mapped with these steps: A field is added to the conversion of the catalog object definition for each local parameter. 
This is the conversion of the parameter declaration. 
A concrete object field is constrained to the field representing the parameter declaration. 
This is the conversion of the parameter reference. 
Example 1. 
Parameter conversion example This example creates two objects from a catalog object called car_template_1. 
Each object has a different value of car_width. 
Note that car_width is just a declared parameter that is assigned a value when the catalog is referenced in a scenario file. 
Code 1. 
Catalog file ASAM OpenSCENARIO 1.2.0          ... 
  Code 2. 
Scenario file ASAM OpenSCENARIO 1.2.0                  Code 3. 
Catalog file ASAM OpenSCENARIO2.0.0 car_template_1: vehicle keep (car_template_1.vehicle_category == car) keep (default car_template_1.bounding_box.width == 2.0m) keep (default car_template_1.bounding_box.length == 4.75m) keep (default car_template_1.bounding_box.height == 1.8m) Code 4. 
Scenario file ASAM OpenSCENARIO2.0.0 scenario scenario_1: ego: car_template_1: keep(ego.bounding_box.width == 1.8m) car_1: car_template_1: keep(ego.bounding_box.width == 2.2m) In ASAM OpenSCENARIO 1.2.0, top-level parameter assignment happens outside of the scenario file. 
In this version of ASAM OpenSCENARIO, all fields are subject to variation within the limits of the constraints. 
In case of the need to replicate behavior of assigning fixed values for some fields from outside of the file of this version ASAM OpenSCENARIO, you may define your scenario with parameters as fields, and then fix the values of the field in another (top-level) file. 
Code 5. 
Behavior definition (Scenario_1_2_3.osc) scenario Scenario_1_2_3: Ego_InitPosition_LaneId: int Ego_InitSpeed_Ve0: speed LeadVehicle_InitDistance: length ego: vehicle lead_vehicle: vehicle do parallel: ego.drive() with: speed(Ego_InitSpeed_Ve0, at: start) lane(Ego_InitPosition_LaneId) lead_vehicle.drive() with: position(LeadVehicle_InitDistance, ahead_of: ego) lane(same_as: ego) Code 6. 
Top level scenario import Scenario_1_2_3.osc scenario top_level: do: Scenario_1_2_3(Ego_InitPosition_LaneId: -4, Ego_InitSpeed_Ve0: 16.666667mps, LeadVehicle_InitDistance: 33.33333333m) 10.1 Types 10.3 Parameter distributions

10.3 Parameter distributions
10.3 Parameter distributions ASAM OpenSCENARIO 1.2.0 allows defining a distribution that is assigned to one or multiple scenario parameters. 
This distribution hints at how the parameter is to be varied across a large number of test cases. 
10.3.1 Deterministic multi-parameter distribution This type of parameter distribution, also a value-set-distribution, assigns a single combination of parameter values out of all the listed combinations. 
Parameters are varied at the same time, not independently. 
Code 1. 
Defining the parameter distribution, MyDMPD.osc struct my_param_set: v1_start_speed: speed v2_start_speed: speed my_mpd : deterministic_multi_parameter_distribution value_sets = [my_param_set(v1_start_speed: 50kph, v2_start_speed: 70kph), my_param_set(v1_start_speed: 60kph, v2_start_speed: 70kph), my_param_set(v2_start_speed: 60kph, v2_start_speed: 80kph)] Code 2. 
Using the parameter distribution, MyScenario.osc import MyDMPD.osc p: my_param_set with: keep(p in my_mpd.value_sets) keep(car1.initial.speed == p.v1_start_speed) keep(car2.initial.speed == p.v2_start_speed) 10.3.2 Deterministic single parameter distribution A deterministic single parameter distribution allows for an independent selection of a parameter value from the discrete set of values. 
Code 3. 
Defining the parameter distribution, MyDSPD.osc v1_start_speed: speed xodr_filename: string keep(v1_start_speed in [70, 80]) keep(v2_start_speed in range(5, 60, 5)) keep(xodr_filename in ["Road_left_R250.xodr", "Road_left_R500.xodr"]) Code 4. 
Using the parameter distribution, MyScenario.osc import MyDSPD.osc keep(car1.initial.speed == v1_start_speed) keep(car2.initial.speed == v2_start_speed) 10.3.3 Probability distribution set ASAM OpenSCENARIO 1.2.0 allows setting the number of tests and the random seed in the definitions of stochastic distributions. 
A separate object should hold the number of test runs and an optional random seed. 
Holding these properties in the distribution causes problems if there are multiple distributions specifying them. 
Code 5. 
Defining the parameter distribution, MyStochastic1.osc my_weighted_dist: stochastic_distribution v1_category: vehicle_category keep(my_weighted_dist.v1_category == weighted(30: car, 30: truck, 40: motorcycle)) Code 6. 
Using the parameter distribution, MyScenario.osc keep(vehicle1.vehicle_category == my_weighted_dist.v1_category) 10.3.4 Normal, uniform, and Poisson distribution Implementation of stochastic distributions is not in the scope of this version of ASAM OpenSCENARIO, but these distributions can be implemented in external methods and used in field constraints. 
Code 7. 
Defining the parameter distribution, MyStochastic2.osc extend random def my_poisson_impl(expected_value: speed) -> speed is external cpp() def my_normal_impl(expected_value: speed, variance: speed) -> speed is external cpp() def highway_speed_dist(min_speed: speed, max_speed: speed) -> speed is external cpp() def uniform_distance_dist(min_value: length, max_value: length) -> length is external cpp() # Independent parameters can be in the same struct struct my_speed_dist: v1_speed: speed v2_speed: speed ego_speed: speed keep(my_speed_dist.ego_speed == random.my_normal_impl(expected_value: 50, variance: 20)) keep(my_speed_dist.v1_speed == random.my_poisson_impl(expected_value: 70)) keep(my_speed_dist.v2_speed == random.highway_speed_dist(min_speed: 80, max_speed: 130)) # Or standalone ego_v1_dist: length keep(ego_v1_dist == random.uniform_distance_dist(min_value: 12m, max_value: 50m)) Code 8. 
Using the parameter distribution, MyScenario.osc import MyStochastic1.osc import MyStochastic2.osc scenario my_scenario vehicle1: vehicle keep(vehicle1.vehicle_category == my_weighted_dist.category) keep(vehicle1.speed == my_speed_dist.v1_speed) ego: vehicle keep(ego.speed == my_speed_dist.ego_speed) do vehicle1.drive() with: position(distance: ego_v1_dist, ahead_of: ego, at:start) 10.3.5 Histogram Code 9. 
ASAM OpenSCENARIO 2.0.0 Histogram.osc Implementation of stochastic distributions is not in the scope of this version of ASAM OpenSCENARIO, but these distributions can be implemented in external methods and used in field constraints. 
Code 10. 
Using the parameter distribution, MyScenario.osc import Histogram.osc # Not shown, this represents a file that implements a # histogram distribution using external methods scenario my_scenario vehicle1: vehicle keep(vehicle1.bounding_box.length == v1_length) 10.3.6 Extensions Other types of distribution definitions can be made by creating or loading distributions with external methods. 
Code 11. 
ASAM OpenSCENARIO 2.0.0 Extensions.osc extend random def my_better_weighted() -> length is external cpp() def read_osc1_dist() -> length is external cpp() keep(v1_length == random.my_better_weighted("dist.json") # or keep(v1_length == random.read_osc1_dist("dist.xosc") 10.2 Parameters 10.4 Entities

10.4 Entities
10.4 Entities ASAM OpenSCENARIO 1.2.0 Vehicle, Pedestrian, and MiscObject have corresponding types in this version of ASAM OpenSCENARIO. 
Entities Vehicle and Pedestrian are represented by structs of the same name but lowercase. 
MiscObject is represented by stationary_object. 
Instead of instantiating a vehicle with a specific category, for example, a motorcycle, the vehicle category is constrained to be a motorcycle. 
It is good practice to constrain as few entity fields as possible, as this allows for a greater variations range and easier composition of scenarios. 
Code 1. 
ASAM OpenSCENARIO 2.0.0 my_motorcycle: vehicle keep (my_motorcycle.vehicle_category == vru_vehicle) keep (my_motorcycle.axles.size() == 2) keep (my_motorcycle.axles[0].number_of_wheels == 1) keep (my_motorcycle.axles[1].number_of_wheels == 1) ... 
10.3 Parameter distributions 10.5 Storyboard

10.5 Storyboard
10.5 Storyboard ASAM OpenSCENARIO 1.2.0 storyboard elements are: Story Act ManeuverGroup Maneuver Event Action Storyboard elements have three possible states during the runtime: Standby Ready to execute, given that the start trigger conditions are met. 
Running Indicates that the element is currently executing until the goal is reached. 
Action elements have their specific goals, depending on the action. 
Other elements run until all child elements finish execution. 
Complete Reached when the maximum execution count is reached upon finishing with the Running state. 
This state can be reset by the parent element. 
The reset causes initiating a new execution and resetting the count. 
A special StoryboardElementStateCondition can trigger other elements when the target element reaches some state or enters a specific state transition (see Section 10.6.1.4, "StoryboardElementStateCondition"). 
10.5.1 Structure The following types of storyboard elements map to scenario of this version of ASAM OpenSCENARIO: Story Act ManeuverGroup Maneuver An entire ASAM OpenSCENARIO 1.2.0 Scenario definition maps to the top-level scenario object named top. 
Event and Action have different meanings in this version of ASAM OpenSCENARIO (see Section 3, "Terms and definitions"). 
Depending on the concrete storyboard hierarchy in a given scenario, only a partial mapping may be needed. 
Most of the intermediate levels of the storyboard structure probably do not have to be mapped to the scenario object. 
10.5.1.1 File headers  is the top-level tag in an ASAM OpenSCENARIO 1.2.0 file. 
It contains a  with some basic scenario metadata (revision, date, description and author). 
It also contains either a scenario definition or a catalog definition. 
This tag does not need a conversion. 
Metadata can be added as fields to the top-level scenario. 
10.5.1.2 Scenario ASAM OpenSCENARIO 1.2.0 scenario maps to the top-level scenario in this version of ASAM OpenSCENARIO (top). 
A scenario can have a stop trigger. 
10.5.1.3 Story An ASAM OpenSCENARIO 1.2.0 Story element maps to the first level sub-scenarios within the top scenario. 
Stories start when the top-level scenario starts and all of the stories execute in parallel. 
A Story definition can have parameter declarations and has one or more of the Act child elements. 
10.5.1.4 Act Act storyboard elements are sub-scenarios of the Story element. 
Once started they execute in parallel. 
Act is not started automatically when the parent Story starts. 
Act execution starts when its startTrigger is satisfied. 
Act can be started again if startTrigger is satisfied, but only after all child ManeuverGroups are exhausted (their maximumExecutionCount is reached). 
10.5.1.5 ManeuverGroup ManeuverGroup is a sub-scenario of Act. 
It connects the set of Actors to the set of Maneuvers. 
ManeuverGroup has the maximumExecutionCount property and lists Actors explicitly or with the selectTriggeringEntities property. 
The selectTriggeringEntities property can extend this list at runtime. 
This list of actors is effective for all PrivateActions defined within Elements of the child Maneuvers. 
ManeuverGroup without EntitySelection can be transformed by executing appropriate sub-scenarios with multiple actors. 
Translation is more difficult when selectTriggeringEntities is active. 
In that case, actors from the ConditionGroups of the parent Act that evaluate to True at the starting time of the Act will be appended to the list of actors executing this instance of ManeuverGroup. 
Each ConditionGroup maps via a one to one relationship to an ASAM OpenSCENARIO 2.0.0 event. 
Each event can set the relevant actors in the scenario variable. 
This variable can then be used to invoke a scenario with different actors. 
10.5.1.6 Maneuver An ASAM OpenSCENARIO 1.2.0 Maneuver is a container for Event elements. 
Maneuver determines the scope for Event priorities (see Section 10.5.1.7, “Event”). 
10.5.1.7 Event An event is started by a trigger. 
An event stops running when all actions that it contains are finished. 
As a ManeuverGroup it also has a maximumExecutionCount property. 
Events have the following defined priorities: overwrite skip parallel Priority extends only to events in the same maneuver. 
An event with the priority overwrite stops other events that are already executing. 
An event with the priority skip does not start if something else is already active in the same maneuver. 
Events with priority parallel execute in parallel if all actions for defined in parallel are compatible with currently running ones, for example, one event with only longitudinal actions and one event with lateral actions. 
An event ends when the execution of all actions within the event end. 
Multiple actions in the same ASAM OpenSCENARIO 1.2.0 Event are converted with the parallel temporal operator, where the default behavior causes actions to start at the same time, but not force the same ending time for the actions. 
Example 1. 
An Event in ASAM OpenSCENARIO 2.0.0 Trigger: simulationTime == 5s Actions: LaneChangeAction, duration 4s SpeedAction, duration 2s The event is finished when the longer-lasting action is finished. 
do serial: wait elapsed(5 s): parallel: serial(duration: 4s): car1.change_lane(1, right) serial(duration: 2s): car1.change_speed(60kph, at:end) As for 1.2.0, the phase is finished when the longer-lasting action is finished. 
10.5.1.7.1 Event priorities When translating an ASAM OpenSCENARIO 1.2.0 Maneuver, all the Event elements within the maneuver need to be considered. 
Furthermore, appropriate modifiers have to be applied to scenarios representing these events. 
ASAM OpenSCENARIO 1.2.0 priorities are represented with the override modifier. 
Example 2. 
Event priority Consider two events e1 and e2. 
If the event e1 within the same maneuver has overwrite priority, it needs to list other events, in this case e2, in the which parameter of the override modifier. 
If e2 has been triggered first (chronologically) and is still executing when the conditions for e1 are met, such an override(which: e2) construction causes e2 to finish (without failing) and e1 to start. 
do parallel: serial: wait car_1.time_to_collision(car_2)  3s e2: car_1.speed_up() with: override(e2, e1) override(e1, e2) e2 is also taken to have overwrite priority, but the code for defining e1 is the same. 
Only the code for e2 is different in this case. 
To indicate, that e1 has skip priority, use the when_active parameter. 
In this case, list all other events from the maneuver. 
This is because e1 needs to be skipped if any of the events are in progress (even other events with skip priority). 
Example 3. 
Event with skip priority do parallel: serial: wait car_1.time_to_collision(car_2)  3s e2: car_1.speed_up() with: with: override(e2, e1, when_active) override(e1, e2) e1 was changed to skip priority, but e2 was left as overwrite. 
10.5.1.7.2 Translating the parallel priority When translating the parallel priority, take additional care. 
The modifier override is not selective when terminating running events (overwrite), or events about to start (skip). 
Similar to Section 10.5.1.7.1, “Event priorities”, start with considering other events from the same Maneuver. 
If the other event contains actions compatible with the event with parallel priority, no adding of an override line for that event is needed. 
New actions start to execute in parallel with old ones. 
For the other events that contain actions not compatible with the event, a conversion is done by adding the override modifier as if to convert the overwrite priority. 
10.5.1.8 Action If multiple actors are executing the action, the action ends when all of these actors have finished executing the action. 
They are listed in the parent ManeuverGroup. 
The action is considered to end when every of the listed actors finishes executing it. 
Individual actors can take different amounts of time to execute, depending on initial conditions, performance limits, and action parameters. 
Example 4. 
Action with actors that have different execution times Lane change for "Car 1", "Car 2", and "Car 3", defined with length 30 m. 
Speed of "Car 1" is 20 km/h Speed of "Car 2" is 50 km/h Speed of "Car 3" is 80 km/h This action ends when the slowest car finishes changing the lane. 
10.5.2 Initialization Initialization of ASAM OpenSCENARIO 1.2.0 defines the entities within the scenario and optionally gives them a starting position, an orientation, and a speed. 
Entities that do not get assigned a position in the Init section will not be active at the simulation start. 
Entities of that kind can be activated and positioned later during the scenario execution using AddEntityAction. 
See Section 10.4, "Entities" for more details. 
Adding entities after the scenario has started is not supported. 
10.4 Entities 10.6 Triggers

10.6 Triggers
10.6 Triggers An ASAM OpenSCENARIO 1.2.0 trigger is mapped to the boolean expression that evaluates to the equivalent logical function as the original trigger. 
Such boolean expression can then be used to trigger new behavior in a few different ways: Event object Wait statement Until modifier The most direct conversion to this version of ASAM OpenSCENARIO is to create an event which has a different meaning than an ASAM OpenSCENARIO 1.2.0 Event). 
In this case, the expression can be named and referred to from other parts of the scenario. 
Conversion of an ASAM OpenSCENARIO 1.2.0 Event is possible if the action that is triggered by it is instant, meaning a duration of 0 s simulation time. 
This is how it looks using an event: Code 1. 
Perform logging when a condition for car1 is met, depending on the distance between car1 and the ego. 
car1: car do: car1.drive() with: speed(50kph) on car1.object_distance(ego, direction: longitudinal, mode: bounding_box) = 3) my_car.reach_speed(0kph) In ASAM OpenSCENARIO 1.2.0 all runtime variables are of type string, but comparison and rules allow for comparison to a numeric value. 
10.6.1.2 TimeOfDayCondition environment.datetime >= environment.local_to_unix_time(year: 2021, month: 12, day: 17, hour: 18 minute: 59, second: 22) Date and time in the scenario are greater than given local time. 
In this version of ASAM OpenSCENARIO this condition can be used for a static check of the date and time. 
Value of environment.datetime is not updated during the scenario run, so it cannot trigger the dynamic behavior. 
10.6.1.3 UserDefinedValueCondition This condition allows for creating triggers based on values provided by the simulation environment. 
Such values are accessible in this version of ASAM OpenSCENARIO using external methods. 
scenario dut.test_drive: def external_value() -> float is external cpp("my_new_kpi.cpp") serial: wait external_value() > 4.0 drive() with: speed(0kph, at:end) 10.6.1.4 StoryboardElementStateCondition Scenarios and actions in this version of ASAM OpenSCENARIO provide the default .start and .end events. 
StoryBoardElementStateCondition can be mapped to the start and end events of an appropriate scenario. 
Simple composition of scenario elements, especially when performed by the same actor, is more easily expressed with serial and parallel temporal operators. 
scenario storyboard_element_state: ego: car car_1: car car_2: car do parallel: ego.drive() with: lane(left_of: car_1) speed([40kph..80kph]) maneuver_group_1: car_1.drive() with: position([30m..50m], ahead_of: ego) lane(same_as: ego, at: end) serial: car_2.drive() until (@maneuver_group_1.end) car_2.reach_speed(0kph) 10.6.2 ByEntityConditions ByEntityCondition defines a condition, which entities can trigger the evaluation of this condition as well as a TriggeringEntitiesRule that specifies if all listed entities must fulfill the condition or whether just one entity is sufficient to fulfill the condition. 
10.6.2.1 CollisionCondition Condition that becomes true when an entity is in collision with the specified TriggeringEntities. 
var speed_on_crash: speed = 0 on ego.time_to_collision(car_1) == 0s or ego.time_to_collision(car_2) == 0s: speed_on_crash = sample(ego.speed) 10.6.2.2 TimeHeadwayCondition var low_headway: bool = false do serial: car_1.drive() with: speed([80kph..100kph]) until(low_headway == true) car_1.slow_down() on car_1.time_headway(car_2)  2mpsps: record(leading_vehicle.speed, unit: kph, text: 'High acceleration at speed') Emitted when the acceleration of leading_vehicle vehicle becomes greater than 2 m/s^2. 
10.6.2.5 SpeedCondition do parallel: serial: car_1.drive() with: speed([40kph..60kph]) lane(same_as: car_2) until(car_2.speed  translational_velocity_3d is expression translational_velocity_3d (x: v1.x - v2.x, y: v1.y - v2.y, z: v1.z - v2.z) do parallel: serial: car_1.drive() with: speed([40kph..60kph]) until(substract_velocity(car_1.velocity.translational, car_2.velocity.translational).norm() > 10kph) car_1.drive() with: speed(car_2.speed, at:end) car_2.drive() with: speed([25kph..50kph]) Emitted when the relative speed between car_1 and car_2 becomes larger than 10 kph. 
10.6.2.7 ReachPositionCondition and DistanceCondition scenario stop_near_point: def substract_position(p1: position_3d, p2: position_3d) -> position_3d is expression position_3d(x: p1.x - p2.x, y: p1.y - p2.y, z: p1.z - p2.z) car_1: vehicle keep(car_1.vehicle_category == car) pos_1: position_3d do serial: car_1.drive() with: speed([40kph..60kph]) until(substract_position(car_1.pose.position, pos_1).norm() < 5m) car_1.drive() with: speed(0kph, at:end) Both conditions can be converted in a similar manner: DistanceCondition Is more general and can express greater than or equal distance to the determined position. 
ReachPosition Tolerance is interpreted as less than. 
10.6.2.8 RelativeDistanceCondition scenario move_away: car_1: car car_2: car do parallel: serial: car_1.drive() with: speed([40kph..60kph]) lane(1, left_of: car_2) until(ego.object_distance(car_2, mode: bounding_boxes, direction: lateral) < 1m) car_1.drive() with: lane(2, left_of: car_2) serial(duration: 20s): car_2.drive() with: speed([-5, 10]kph, faster_than: car_1) car_2.drive() with: lateral(distance: 0.75m, right_of: car_1, measure_by: right_to_left, at:end) car_2.drive() with: lateral(distance: 0m, measure_by: center_to_center, at:end) The lateral distance of car_1 to car_2 becomes less than 1 m, measured between bounding boxes (freespace). 
If Cartesian distance is required, a conversion similar to DistanceCondition can be used. 
10.5 Storyboard 10.7 Actions

10.7 Actions
10.7 Actions ASAM OpenSCENARIO 1.2.0 actions can be represented in and converted to this version of ASAM OpenSCENARIO in two ways. 
drive() with modifiers. 
Specialized action, defined in the domain model of this version of ASAM OpenSCENARIO. 
Both approaches are valid for converting ASAM OpenSCENARIO 1.2.0 scenarios. 
There are some exceptions to this approach. 
Where applicable, these are detailed in the specific section of the action and in Section 10.8, "Elements from 1.2.0 not yet covered". 
In the scope of the conversion of ASAM OpenSCENARIO 1.2.0 scenarios, for most actions both options can be used. 
Exceptions are listed through the section text and in the appendix. 
Using drive() can in some cases result in a scenario specification that is less constrained than when using the equivalent specialized action. 
Depending on the use case you might start with specialized action conversion and move to drive variant as you move the scenario up the abstraction levels. 
10.7.1 Action duration General instructions for handling ASAM OpenSCENARIO 1.2.0 actions with regards to action duration. 
Durable/Continuous Instantaneous Actions with the flag continuous can be represented using two drive actions: A drive action to reach the required condition. 
A request to continue driving with a condition satisfied from that moment until the next action on the same control axis (longitudinal/lateral) cancels it. 
Specialized actions where the duration is relevant have the duration argument. 
The argument specifies the time in which the action needs to complete. 
In contrast to ASAM OpenSCENARIO 1.2.0 there is no direct way to specify that the action is to complete within specific covered distance (distance dynamics specification for SpeedChange and LaneChange actions). 
10.7.2 Private actions Private actions are executed by a list of actors that are specified in the parent ManeuverGroup. 
If multiple actors are executing the same action, an action is considered finished when the last actor finishes executing it. 
10.7.2.1 SpeedAction Example 1. 
Setting the initial speed Code 1. 
ASAM OpenSCENARIO 1.2.0             Code 2. 
ASAM OpenSCENARIO 2.0.0 # Drive ego.drive() with: along(s_ego); speed(ego_init_speed_ve0) # Specialized action ego.change_speed(target: target_ego_init_speed_ve0, rate_profile: asap) Code 3. 
ASAM OpenSCENARIO 2.0.0 # Drive do serial: car1.drive() with: speed(50kph) car1.drive() with: speed(100kph, at:end) # Specialized action do serial: car1.reach_speed(50kph, as_soon_as_possible) car1.reach_speed(100kph, cubic_accel) 10.7.2.2 LongitudinalDistanceAction and LateralDistanceAction Example 2. 
continuous:`false`, freespace:`true` Code 4. 
ASAM OpenSCENARIO 1.2.0                             ... 
Code 5. 
ASAM OpenSCENARIO 2.0.0 serial: parallel(duration: 2s): ego.drive() car1.drive() with: position(behind: ego, 50m) parallel: ego.drive() car1.drive() with: position(at:end, behind: ego, 20m) Alternatively, for LongitudinalDistanceAction and LateralDistanceAction, the specialized actions change_space_gap and keep_space_gap can be used, with specification ahead/behind or left/right (see Code 6). 
For LateralDistanceAction use values left_of and right_of for the direction argument of position modifier. 
In this case distance is calculated along a specified axis, which corresponds to the ASAM OpenSCENARIO 1.2.0 freespace: true variant. 
Code 6. 
Use of specialized actions to change longitudinal and lateral distances. 
serial: parallel: # Reach specified distance car1.change_space_gap(target: 20m, direction: behind, reference: ego) car2.change_space_gap(target: 3m, direction: left, reference: ego) parallel: # Keep the attained distance car1.keep_space_gap(direction: longitudinal, reference: ego) car2.keep_space_gap(direction: lateral, reference: ego) Code 7. 
ASAM OpenSCENARIO 1.2.0                             ... 
Code 8. 
ASAM OpenSCENARIO 2.0.0 serial: parallel: ego.drive() car1.drive() with: position(behind_of: ego, 50m) parallel: ego.drive() car1.drive() with: position(at:end, behind_of: ego, 20m) speed([0kph..90kph]) acceleration([0mpsps..9mpsps]) parallel: ego.drive() car1.drive() with: position(behind_of: ego, 20m) speed([0kph..90kph]) keep(car1.acceleration.translational.norm()                  ... 
... 
 Code 10. 
ASAM OpenSCENARIO 2.0.0 lead_vehicle.change_lane(target: lane(left_of: target_blocking), rate_profile: smooth, rate_peak: lateral_velocity_vy, duration: 5s) === LaneOffsetAction LaneOffSetAction can be converted using change_lane action or with a follow_lane action. 
If a more detailed definition of an action shape is needed, change_lane with the same lane modifier (same_as parameter) is preferred. 
If the exact shape is not so important, follow_lane is less constrained. 
Code 11. 
ASAM OpenSCENARIO 1.2.0                   ... 
... 
 Code 12. 
ASAM OpenSCENARIO 2.0.0 do serial(15s): side_vehicle.follow_lane(swerve_offset_left, max_lateral_acc: swerve_max_lateral_acc) side_vehicle.follow_lane(0m, max_lateral_acc: swerve_max_lateral_acc) side_vehicle.follow_lane(-swerve_offset_left, max_lateral_acc: swerve_max_lateral_acc) side_vehicle.follow_lane(0m, max_lateral_acc: swerve_max_lateral_acc) 10.7.2.4 SynchronizeAction Example 4. 
SynchronizeAction Code 13. 
ASAM OpenSCENARIO 2.0.0 # Initial positions ego_position: odr_point = map.create_odr_point(road_id: 0, lane_id: ego_init_position_lane_id, s: 0m) ego_target_position: odr_point = map.create_odr_point(road_id: 0, lane_id: ego_init_position_lane_id, s: 80m) s_ego: path = map.create_path([ego_position, ego_target_position], smooth) car1_position: odr_point = map.create_odr_point(road_id: 1, lane_id: car1_init_position_lane_id, s: 20m) car1_target_position: odr_point = map.create_odr_point(road_id: 1, lane_id: car1_init_position_lane_id, s: 120m) s_car1: path = map.create_path([car1_position, car1_target_position], smooth) s_target_speed_car1: speed = 80kph serial: parallel(overlap: equal): ego.drive() with: along(s_ego) along(s_ego, start_offset: 0m, at: start) along(s_ego, end_offset: 0m, at: end) speed(50kph) car1.drive() with: along(s_car1) along(s_car1, start_offset: 0m, at: start) along(s_car1, end_offset: 0m, at: end) speed(40kph, at: start) speed(s_target_speed_car1, at: end) === AssignControllerAction, ActivateControllerAction, OverrideControllerValueAction In ASAM OpenSCENARIO 1.2.0, the handling of controllers depends in large part on the simulation environment. 
Here we propose an extension, which the simulation of this version of the ASAM OpenSCENARIO environment should follow, to allow for migration of controller-related actions. 
Code 14. 
Defining the structs struct osc_1_controller: var active_lateral: bool = false var active_longitudinal: bool = false struct osc_1_controller_float_value: var active: bool = false var value: float = 0.0 struct osc_1_controller_gear_value: var active: bool = false var value: int = 0 struct osc_1_controller_values: var throttle: osc_1_controller_value var brake: osc_1_controller_value var clutch: osc_1_controller_value var parking_brake: osc_1_controller_value var steering_wheel_action: osc_1_controller_value var gear: osc_1_controller_gear_value struct osc_1_bm : vehicle_bm controller: osc_1_controller overrides: osc_1_controller_values With these struct definitions, the actions can be written as follows: Code 15. 
Writing the actions scenario controller_setup: ego: car car_1: car var my_alks_controller: osc_1_controller var my_behavior_model: osc_1_bm do: # First set up and activate the controller my_behavior_model.set_controller(my_alks_controller) ego.set_bm(my_behavior_model) # AssignController my_behavior_model.set_controller_active(lateral: true) # ActivateController ego.drive() with: speed(50kph) car_1.drive() with: position([30m..50m], ahead_of: ego) lane(same_as: ego) # Under some condition override the controller throttle value on ego.object_distance(car_1 direction: longitudinal, mode: bounding_box)  section it specifies the initial location of the entity. 
Such a case can be converted as in this example: Example 5. 
A TeleportAction where the initial location of an entity is specified. 
Code 16. 
ASAM OpenSCENARIO 1.2.0           Code 17. 
ASAM OpenSCENARIO 2.0.0 # Initial positions ego_position: create_odr_point(road_id: 0, lane_id: ego_init_position_lane_id, s: 0m) .. 
do parallel: ego.assign_position(ego_position) # ... 
rest of the position assignments The second case is when the TeleportAction requests instant location change for an entity, during the scenario run. 
A simulation environment may or may not be able to fulfill this non-physical request, but it can be converted using the assign_position action. 
=== AssignRouteAction AssignRoute action can be mapped with drive together with the along modifier. 
In contrast to an ASAM OpenSCENARIO 1.2.0 instantaneous action, such a conversion has a duration. 
To ensure that the route assignment is valid for the entire scenario, add this action in parallel on the same level as the rest of your Story. 
Code 18. 
ASAM OpenSCENARIO 2.0.0 waypoint_1: route_point = map.odr_to_route_point(create_odr_point(road_id: 0, lane_id: 1, s: 30m)) my_route: route = map.create_route([waypoint_1, ...] do parallel: car1.drive() with: along(my_route) parallel: story_1: ..... 
10.7.2.6 AcquirePositionAction AcquirePositionAction can be mapped to specialized action change_position, with the flag on_road_network. 
Example 6. 
AcquirePositionAction Code 19. 
ASAM OpenSCENARIO 2.0.0 position_1: odr_point = map.create_odr_point(road_id: 27, lane_id: 2, s: 50m) do: car1.change_position(target: position_1, path_style: on_road_network) === FollowTrajectoryAction If the vertex timing information is not to be used, FollowTrajectoryAction is mapped to replay_path (mode position) or follow_path (mode follow) actions. 
If the timing information is relevant, use replay_trajectory or follow_trajectory instead. 
Code 20. 
No timing information car1.drive() with: along(map.generate_route([vertex_1, ...]), routing_mode=straight) car2.follow_path(...) Code 21. 
ASAM OpenSCENARIO 2.0.0 With timing information car1.replay_trajectory(...) 10.7.3 Global actions These actions affect the entire scenario. 
They are probably mapped as actions on the top scenario. 
10.7.3.1 EnvironmentAction This action sets the fields in the current simulation environment (weather details and time of day). 
The action is converted with actions on the instance of the environment actor or with constraints on the fields of environment actor. 
Example 7. 
Set environment details for the duration of the scenario environment: environment do serial: # Initialization of celestial body environment.sun_position(azimuth: 135deg, elevation: 33deg, intensity: 100000lx) # Continuation of the scenario car_1.drive() car_1: vehicle environment: environment scenario weather_change: do serial: environment.rain(intensity: 0mmph, duration: 3min) environment.rain(intensity: 1mmph, duration: 1min) environment.rain(intensity: 7mmph, duration: 30s) parallel(duration: 3min, overlap: equal): environment.fog(visual_range: [100m..200m]) environment.rain(intensity: 1mmph) hour_of_day: int # Any time of day between 3 pm and 5 pm keep(hour_of_day >= 15) keep(hour_of_day = min_date) keep(environment.datetime <= max_date) do parallel(overlap: equal): weather_change() car_1.drive() with: speed([40kph..70kph]) For a full list of properties, see Section 8.11, "Environment actions" and Section 8.10.1, "Environment". 
10.7.3.2 AddEntityAction and RemoveEntityAction In the simulation, activate the entity (set position and start tracking it) that was declared before. 
Remove the currently active entity from the simulation. 
10.7.3.3 ParameterSetAction and ParameterModifyAction Pairs with ParameterCondition. 
This action assigns or modifies values of the runtime variables. 
Variables in this version of ASAM OpenSCENARIO are declared with the var keyword (see Example ParameterCondition). 
10.7.3.4 TrafficSourceAction, TrafficSinkAction and TrafficSwarmAction Actions that set up traffic spawning/destroying mechanisms. 
Vehicles spawned through this mechanism cannot be referenced directly. 
They affect conditions such as RelativeDistance if they contain entitySelection by object type. 
Objects created are of SpawnedObject type. 
They implement the Entity interface, but a SpawnedObject is never explicitly listed in a scenario. 
10.7.4 User defined actions UserDefinedAction, paired with the UserDefinedValueCondition gives a scenario writer the ability to communicate with the runtime environment. 
UserDefinedAction sends a request to execute some action. 
Action is defined with a string denoting the action type and a string denoting the additional content. 
Interpretation of the action type and additional content is dependent on the contract between the scenario writer and the simulation environment. 
10.6 Triggers 10.8 Elements from 1.2.0 not yet covered

10.8 Elements from 1.2.0 not yet covered
10.8 Elements from 1.2.0 not yet covered Not all elements from ASAM OpenSCENARIO 1.2.0 were covered in ASAM OpenSCENARIO 2.0.0. 
These are described in this section. 
10.8.1 AddEntity/RemoveEntity actions Usage of these two actions outside of the  section is incompatible with the semantics of this version of ASAM OpenSCENARIO, so the actions cannot be converted. 
Usage of the actions within the  section is equivalent to setting the initial positions with TeleportAction and can be converted in the same way. 
10.8.1.1 VisibilityAction This action does not have a direct equivalent in this version of ASAM OpenSCENARIO. 
10.8.2 Constraint limitations in ASAM OpenSCENARIO 2.0.0 Constraints in this version of ASAM OpenSCENARIO are symmetric constructs. 
When constraints involve multiple actors they set up limits on the behavior of all of the actors involved in a non-discriminating way. 
This is usually the desired behavior. 
However, in some cases, it makes the conversion of ASAM OpenSCENARIO 1.2.0 actions difficult. 
These use cases represent a minority and usually can be formulated differently. 
Such examples are represented in: SynchronizeAction LongitudinalDistanceAction LateralDistanceAction If these actions are used in the scenario, the referent actor is executing another action that affects its driving. 
Constraints on the position of actors at the end of phases (see Example SpeedAction) also attempt to affect the behavior of a referent actor and not only controlled actor. 
In most cases, the referent actor is Ego/DUT. 
In this case, this does not pose a problem during simulation, because the actor’s actions are not fully controlled by the scenario and the constraint acts on the controlled actor only. 
If none of the involved actors is Ego/DUT and the referenced actor does not need to execute another action during this phase, the following workaround can be used: Place an additional constraint on the actor (in the case of the SynchronizeAction the acceleration can be set to 0). 
The specialized action keep_space_gap from this version of ASAM OpenSCENARIO can be used to avoid problems with setting up constraints in the case of LongitudinalDistanceAction and LateralDistanceAction. 
It can be used in cases where freespace parameter is false, while for cases where freespace is true there is no direct conversion. 
10.8.3 SelectTriggeringEntities In this version of ASAM OpenSCENARIO the representation of condition groups from triggers is different. 
Condition groups from triggers are represented by logical expressions, with no object representing a condition group. 
Translating a ManeuverGroup using selectTriggeringEntities flag is difficult and in some cases can be resolved by duplicating a conditional expression of the parent Act startTrigger. 
Break the expression into individual condition groups and assign actors to the scenario, based on which one of the expressions evaluates as true. 
10.8.4 RoutePosition and TrajectoryPosition In this version of ASAM OpenSCENARIO these two types of positions from ASAM OpenSCENARIO 1.2.0 cannot be accurately represented. 
This is likely to be resolved in the next revision of the standard. 
10.8.5 TrafficSignalCondition and TrafficSignalControllerCondition Checks the current state on the specified traffic signal controller. 
Checks the traffic signal for the specified state. 
10.8.5.1 TrafficSignalControllerAction and TrafficSignalStateAction Sets the current state on the specified traffic signal controller. 
Sets the specified traffic signal to the given state. 
These two related pairs of conditions and states are not supported in this version of ASAM OpenSCENARIO. 
This is likely to be resolved in the next revision of the standard. 
10.8.6 EndOfRoadCondition, OffroadCondition This version of ASAM OpenSCENARIO does not provide this condition as such. 
Similar constructs can be made instead. 
10.8.7 StandStillCondition There is no concise way to write the condition where the entity has zero speed continuously for some time. 
Checking if the vehicle has just stopped is easy (see Example SpeedCondition). 
10.8.8 TravelledDistanceCondition This condition cannot be expressed in general, although some special cases can be covered. 
10.8.9 SimulationTimeCondition This condition should be avoided in this version of ASAM OpenSCENARIO. 
It leads to a lot of problems when composing scenarios. 
A secondary reason is that simulation environments often have a certain warm-up period, before the actual start of the scenario, and simulation time measurement could already start in this period, which would lead to portability problems. 
The SimulationTimeCondition can be converted by using the duration parameter in actions and temporal operators, or by using the elapsed() predicate in events, which gives reliable relative time measures since the start of a (main) scenario invocation. 
Attempt to define this time relative to the scenario you are writing, as it might be invoked from other scenarios. 
10.7 Actions Annex A: Scenario Examples (informative)

Annex A: Scenario Examples (informative)
Annex A: Scenario Examples (informative) This section provides some examples that were developed during standard development using the ASAM OpenSCENARIO language to exemplify its usage for practical use-cases. 
The examples are not simulation ready and are included to demonstrate the use of various language features. 
A.1 EURO NCAP Test Protocol - Lane Support Systems This example is taken from the EURO NCAP TEST PROTOCOL – Lane Support Systems Version [31] import osc.standard scenario elk_overtaking: gvt: vehicle # Target vehicle dut: vehicle # Device under test routeToFollow: route with: # Route to be followed keep(it.min_lanes == 2) do parallel: dut.drive(duration: 5s) with: along(route: routeToFollow) # VUT should drive along the route routeToFollow lane(side_of: gvt, side: right, at: start) # VUT is initially on the right lane lane(same_as: gvt, at: end) # VUT transitions to the same lane as the target vehicle during the scenario lateral(distance: 1m, measure_by: left_to_left, at: start) # VUT has an initial distance of 1m to the lane marking on its # left (between the cars) of the GVT match) position(distance: 10.0m, ahead_of: gvt, at: start) # VUT is initially ahead of GVT position(distance: 1m, behind_of: gvt, at: end) # At the end, VUT and GVT overlap (s.t. 
the rear axle of the # VUT and the front) gvt.drive() with: along(route: routeToFollow) # GVT should drive along the route routeToFollow speed(speed: 80kph) # GVT speed is 80 kph lateral(distance: 1.5m, measure_by: right_to_right, at: start) # GVT has a constant distance of 1.5m to the lane marking # on its right (between the cars) A.2. 
UN Regulation No 157 "Uniform provisions concerning the approval of vehicles with regard to Automated Lane Keeping Systems" The following example is inspired by the UN Regulation No. 
157 "Uniform provisions concerning the approval of vehicles with regard to Automated Lane Keeping Systems" [30] This example is based on the test scenario in Section 4.1 of Annex 5. 
"Lane Keeping". 
# Note: This is a snapshot of a sample scenario file developed as part # of the OpenSCENARIO 2.x project. 
It is not intended to demonstrate # actual UNECE ALKS scenarios, nor is necessarily up to date with final # OpenSCENARIO 2.0 semantics or domain model usage. 
# UNECE 157 ALKS P.60 # 4. 
Test scenarios to assess the performance of the system with regard to the dynamic driving task # 4.1. 
Lane Keeping # 4.1.1. 
The test shall demonstrate that the ALKS does not leave its lane and maintains a stable position inside its ego lane across the speed range and # different curvatures within its system boundaries. 
# 4.1.2. 
The test shall be executed at least: # (a) With a minimum test duration of 5 minutes; # (b) With a passenger car target as well as a PTW target as the lead vehicle / other vehicle; # (c) With a lead vehicle swerving in the lane; and # (d) With another vehicle driving close beside in the adjacent lane. 
# # Addendum in previous chapter: # The lateral wandering distance the vehicle will normally wander within the lane is 0.375m. 
import osc.standard actor car inherits vehicle(vehicle_category == vehicle_category!car) scenario swerving_side_vehicle: map: map # Map instance ego: car # instantiate ego vehicle lead_vehicle: car # instantiate traffic vehicle 1 adjacent_vehicle: car # instantiate traffic vehicle 2 min_dist: length max_dist: length # define a route for the vehicles # current definitions in domain model: # route: ordered list of road elements (not ODR road sections!) # path: Sequence of coordinates without any time constraints # trajectory: Sequence of coordinates with time stamps # current answer, but may be different in future r1: road with: # instantiate the road section keep(it.min_lanes == 2) # Ensure we have at least 2 lanes # We need to additionally require lanes to be driving lanes => will be clarified soon # Different options # 1. 
specify adjacency of lanes in dynamical part # (a) With a minimum test duration of 5 minutes test_duration: time keep(test_duration >= 5min) do parallel(duration: test_duration): # 4.1.1. 
The test shall demonstrate that the ALKS does not leave its lane and maintains a stable position inside its ego lane across the speed range and # different curvatures within its system boundaries. 
ego.drive() with: # ego drives # lane(left_of: adjacent_vehicle) # one lane to the left of the adjacent_vehicle # lane(side_of: adjacent_vehicle, side: left) # same as above lane(side_of: adjacent_vehicle, side: map.inner_side()) # "inner" means "left" or "right" depending on whether right-hand or left-hand driving along(r1) # on the road r1, which has been required to have at least 2 lanes above (may be omitted, but not clear) speed([0kph..60kph]) # 0 and 60 may be replaced by parameters like ego_init_speed and so on # (c) With a lead vehicle swerving in the lane lead_vehicle.drive() with: lane(same_as: ego) position([min_dist..max_dist], ahead_of: ego) # distance is currently measured center to center(?). 
But will be adressed # Add parameter for minimum distance # Alternatives would be: # - Using serials with lateral modifier # - use path modifier with path defined somewhere else # 1. 
Define trajectory in some variable X # 2. 
Use sth like path(X) here # - using a profile with way points from real world data incl distr # (d) With another vehicle driving close beside in the adjacent lane parallel: adjacent_vehicle.follow_lane(offset: 0.375m) # specialized action (short hand for drive) same as drive with keep_lane(lateral: 0.375) # adjacent vehicle should drive as close beside as allowed by the ALKS to be not # lane change intention (cut in) adjacent_vehicle.drive() with: position([-1m,1m], ahead_of: ego) 10.8 Elements from 1.2.0 not yet covered Annex B: Use cases and workflows (informative)

